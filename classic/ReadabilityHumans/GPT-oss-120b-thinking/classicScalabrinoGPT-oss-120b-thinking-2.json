{"score":"70","reasoning":"The method is straightforward and uses clear variable names, making the main flow easy to follow. However it contains repeated blocks for removing the person from the old address, which could be extracted to reduce duplication. Error handling is simple but the empty else branch for empty input is ambiguous. Overall readability is decent but could be improved with refactoring.","tokens":664,"name":"61.jsnp"}
{"score":"80","reasoning":"The code is concise and uses a descriptive test method name that explains its purpose The structure follows a clear sequence of opening a session beginning a transaction persisting an entity flushing and rolling back The lack of comments and minimal error handling slightly reduces readability but overall it is easy to understand","tokens":514,"name":"133.jsnp"}
{"score":"90","reasoning":"The method is short and self explanatory, uses clear names, Javadoc explains purpose, directly maps registration fields to a new ParameterMemento, no complex logic, making it highly readable","tokens":671,"name":"67.jsnp"}
{"score":"85","reasoning":"The code is concise and well‑structured, using clear method calls to register SQL functions. Naming is descriptive and consistent, aiding comprehension. Minor drawbacks include lack of inline comments explaining each function’s purpose and reliance on external context for the dialect class, which slightly reduces readability for newcomers.","tokens":619,"name":"21.jsnp"}
{"score":"65","reasoning":"The test method is clear in purpose and uses descriptive names, but the many long instanceof checks and nested parentheses reduce readability. Repeated assertTranslation calls are easy to follow, yet the extensive conditional blocks and lack of helper methods make the flow harder to scan quickly","tokens":1059,"name":"89.jsnp"}
{"score":"70","reasoning":"The test method is clearly structured with a query executor and a result checker, and the assertions describe the expected behavior. However the heavy use of casts, nested parentheses and long lines make it harder to follow, and the anonymous inner classes add verbosity. Overall readability is moderate","tokens":938,"name":"98.jsnp"}
{"score":"85","reasoning":"The test method is concise and well structured with clear naming and proper indentation. It opens a session, runs a query expected to fail, catches the specific exception, and closes the session. The flow is easy to follow making the code highly readable","tokens":739,"name":"81.jsnp"}
{"score":"70","reasoning":"The code is fairly readable with clear indentation and standard Java constructs, but the anonymous Integrator contains duplicated integrate methods and a private helper that adds complexity. Naming is generic and lack of comments makes intent less obvious, reducing overall comprehension","tokens":709,"name":"174.jsnp"}
{"score":"78","reasoning":"The method name and parameters are descriptive, the branching logic is clear, and helper methods are used to build the replacement string. Indentation and spacing are consistent. Minor drawbacks are reliance on external helpers without context and a mix of StringHelper and plain replace calls, which may cause slight confusion. Overall readability is good","tokens":797,"name":"112.jsnp"}
{"score":"85","reasoning":"The method is concise and follows a clear pattern of configuring a Hibernate Configuration object. Each property is set on a separate line, making the intent obvious. Use of descriptive constants improves readability. Minor drawbacks are long method chains and lack of comments, but overall the code is easy to understand","tokens":575,"name":"191.jsnp"}
{"score":"70","reasoning":"The test method is straightforward and uses descriptive variable names which aid comprehension. However the repeated getAuditReader().find calls make the code verbose and could be refactored into a helper. The assertions are clear but the method length and lack of comments slightly reduce readability. Overall it is moderately easy to understand.","tokens":755,"name":"186.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical sections, but its length, repeated session handling and lack of comments make it harder to follow, and the use of raw map keys adds minor confusion. Overall readability is good but could be improved","tokens":910,"name":"192.jsnp"}
{"score":"70","reasoning":"The method is short and uses descriptive names but contains a long TODO comment, raw iterator usage and magic strings which reduce clarity overall readability is decent but could be improved","tokens":1000,"name":"31.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming, consistent indentation and logical flow. Helper calls are self descriptive and comments explain key steps. Minor drawbacks are reliance on external context and a few long lines, but overall the code is easy to follow.","tokens":999,"name":"170.jsnp"}
{"score":"65","reasoning":"The test method name is clear and the repeated assertNoLoss calls make the intent obvious. However the inline SQL strings are very long, contain many nested quotes and complex clauses, which reduces readability and makes the code hard to scan. Breaking the queries into named constants or separate methods would improve comprehension.","tokens":1210,"name":"101.jsnp"}
{"score":"55","reasoning":"The code has a clear loop structure and reasonable variable names, but readability is hampered by heavy console output, unexplained helper classes, magic numbers and bitwise operations without comments. The purpose of the byte array manipulation is not obvious, making it harder for readers unfamiliar with UUID internals. Overall readability is moderate.","tokens":1187,"name":"58.jsnp"}
{"score":"78","reasoning":"The test method is well organized with descriptive variable names and clear assertions. Annotations list many classes but remains readable. Iterator logic and conditional ordering add some complexity but the flow is easy to follow. Overall the code is fairly readable and understandable.","tokens":1132,"name":"181.jsnp"}
{"score":"78","reasoning":"The method is well named and uses clear, consistent naming for variables and calls. Indentation and spacing aid readability. However the duplicated conditional blocks for custom persister class name add redundancy and may confuse readers, and the method performs many setter calls which slightly reduces clarity. Overall it is fairly easy to follow","tokens":1002,"name":"146.jsnp"}
{"score":"85","reasoning":"The test method has a descriptive name and clear variable naming. Property settings are grouped logically and assertions are straightforward. Indentation and spacing are consistent, aiding readability. The long property strings and unexplained numeric literals slightly hinder quick comprehension.","tokens":1169,"name":"131.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and documented, making its purpose obvious. Variable names are descriptive and the flow follows a logical sequence of setup, configuration, and assertions. Use of helper methods and constants improves readability. Minor drawbacks include reliance on external classes not shown and a slightly verbose setup, but overall the code is easy to understand","tokens":805,"name":"57.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear naming and logical flow. Comments explain purpose of blocks. Use of early variable assignments and separate handling for optimistic locking improves clarity. Some nested conditionals and long line lengths slightly reduce readability but overall it is easy to follow","tokens":877,"name":"106.jsnp"}
{"score":"80","reasoning":"The method is short and clear with a null check followed by a try catch to close the reader. Variable names are simple and the flow is easy to follow. The empty catch block hides potential IO errors which slightly reduces robustness, but readability remains high.","tokens":645,"name":"150.jsnp"}
{"score":"78","reasoning":"The test is clearly structured with annotations, a session lifecycle, and a concise inner Work implementation. Variable names are meaningful and exception handling is straightforward. However the heavy casting and long method chains reduce readability slightly, preventing a higher score.","tokens":882,"name":"93.jsnp"}
{"score":"85","reasoning":"The method is clearly organized with early return for buffered events, followed by direct reading and optional buffering logic. Variable names are descriptive and the flow is easy to follow. Minor improvements could include extracting buffer handling into a helper, but overall readability is high.","tokens":838,"name":"151.jsnp"}
{"score":"85","reasoning":"The method has a clear purpose and descriptive names, making the logic easy to follow. It uses consistent formatting and separates concerns logically. Minor issues include a long ternary expression and some dense lines, but overall the code is well‑structured and understandable for developers familiar with JPA and Hibernate.","tokens":765,"name":"28.jsnp"}
{"score":"85","reasoning":"The constructor is well formatted with one call per line, clear method names and consistent indentation. The mapping of SQL types to dialect strings is explicit, making intent obvious. Minor drawbacks are lack of inline comments explaining choices, but overall the code is easy to read and understand.","tokens":858,"name":"20.jsnp"}
{"score":"78","reasoning":"The test method is short and uses clear naming for entities and revisions. Retrieval calls are straightforward and assertions are simple. However the use of magic numbers for revision ids and lack of comments reduce clarity. Overall readability is good but not exceptional","tokens":865,"name":"166.jsnp"}
{"score":"78","reasoning":"The test method is straightforward: it obtains the platform MBean server, queries all MBeans, searches for one containing PooledDataSource, then checks several attributes against expected values. Variable names are clear and the loop is simple. Minor drawbacks are magic numbers, a long line break for idleConnectionTestPeriod and a single inline comment, but overall the code is easy to follow.","tokens":1023,"name":"90.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming and indentation. It uses straightforward conditional checks and delegates to helper methods, making the logic easy to follow. Minor improvements could include reducing nesting by early returns, but overall readability is high.","tokens":544,"name":"193.jsnp"}
{"score":"85","reasoning":"The method follows a standard equals pattern with clear early returns and an instanceof check, uses a cast and compares fields with null‑safe ternary expressions. It is easy to follow but could be simplified using Objects.equals and consistent formatting, so readability is high but not perfect","tokens":559,"name":"60.jsnp"}
{"score":"55","reasoning":"The test method is long and contains many nested conditionals, casts and type checks which reduce clarity. Variable names are descriptive but the flow is hard to follow due to repeated if blocks and index management. Indentation is good but lack of comments and complex logic lower overall readability.","tokens":1116,"name":"140.jsnp"}
{"score":"80","reasoning":"The method is short and uses clear variable names. The arrays xs and ys list the rectangle edge midpoints in a logical order. The call to Geometry.ptClosestTo is self explanatory. The only minor issue is the hard coded length 5 instead of using xs.length, but overall the code is easy to read","tokens":771,"name":"153.jsnp"}
{"score":"78","reasoning":"The method is well named and uses clear variable names, consistent indentation and straightforward conditional logic. The nested ifs are easy to follow and the use of Model.getFacade() abstracts checks. Minor issues are long parameter list formatting and reliance on external classes, but overall readability is high.","tokens":735,"name":"47.jsnp"}
{"score":"65","reasoning":"The test method is moderately readable but suffers from excessive casting redundant parentheses and long anonymous class definitions that make the flow harder to follow. Naming is clear and assertions are straightforward yet the formatting and nesting reduce overall clarity","tokens":893,"name":"96.jsnp"}
{"score":"70","reasoning":"The method is fairly readable with descriptive variable names and clear structure. Indentation and spacing help follow the logic. However nested loops and multiple casts make it a bit dense, and the boolean flags are not explained, which reduces clarity. Minor comment is present but not essential","tokens":815,"name":"50.jsnp"}
{"score":"78","reasoning":"The method is concise and uses an anonymous inner class to run a test in a separate thread which is clear, variable names are descriptive and the finally block ensures cleanup, however the inline comment and lack of explicit thread naming reduce readability slightly","tokens":719,"name":"73.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive names and a simple conditional structure. Calls to helper methods are straightforward, and the logic is easy to follow. Minor verbosity in method arguments prevents a perfect score but overall readability is high","tokens":792,"name":"103.jsnp"}
{"score":"78","reasoning":"The test is short and uses clear variable names. Property keys are verbose but self explanatory. Duplicate password entry may cause confusion. Assertions are simple. Overall the flow is easy to follow, making it fairly readable","tokens":749,"name":"35.jsnp"}
{"score":"85","reasoning":"The method is well documented with clear Javadoc, follows the standard equals pattern, and uses straightforward conditional checks. Names are self explanatory and indentation is consistent. A minor redundancy exists in the final return, but overall readability and comprehension are high.","tokens":666,"name":"39.jsnp"}
{"score":"35","reasoning":"The method begins with clear null and identity checks but the final return statement is a single long line with many nested ternary operators and mixed \u0026\u0026 logic making it hard to follow The repeated quoting checks and complex parentheses further reduce readability","tokens":797,"name":"36.jsnp"}
{"score":"70","reasoning":"The test method is lengthy and nests three anonymous inner classes, uses raw List and Map types with casts, and long query strings, which reduce clarity. However, variable names are descriptive, the flow of creating criteria, HQL query and result checking is logical, giving it a moderate readability level.","tokens":1121,"name":"99.jsnp"}
{"score":"85","reasoning":"The code is well‑structured and follows standard Java equals implementation patterns. Clear early returns improve readability, and the Javadoc comment explains purpose and behavior. Variable names are descriptive. Minor redundancy in separate minute and hour checks could be combined, but overall it is easy to understand.","tokens":610,"name":"42.jsnp"}
{"score":"45","reasoning":"The method is long and mixes session handling, dialect checks, many HQL queries and assertions without explanatory comments. Nested joins, index usage and string literals make the flow hard to follow, and variable names provide little context. Consistent formatting helps slightly but overall readability is low, resulting in a moderate score.","tokens":1274,"name":"68.jsnp"}
{"score":"85","reasoning":"The method is well‑documented with a clear JavaDoc, uses descriptive variable names and straightforward control flow. Logging and exception handling are explicit. Minor readability hits come from chained map lookups and iterator usage, but overall the code is easy to follow for experienced Java developers","tokens":870,"name":"102.jsnp"}
{"score":"40","reasoning":"The method mixes logging, collection handling and UI updates without clear separation. It uses raw Vector and Enumeration types, lacks generics, and has inconsistent indentation. Variable names like tde, items, nItems, path are not descriptive. Repeated calls to Designer.theDesigner() and unclear fireTreeStructureChanged reduce clarity. Overall readability is poor","tokens":855,"name":"46.jsnp"}
{"score":"78","reasoning":"The test method is clearly named and uses standard JUnit annotations, making its purpose obvious. Variable names are descriptive and the assertion compares an expected SQL string with the generated one. The long concatenated expected string reduces readability slightly, but overall structure and formatting are good, leading to a high readability score","tokens":770,"name":"23.jsnp"}
{"score":"65","reasoning":"The method is well indented and uses clear logging, but the large commented out loop and unused variables make it harder to follow. The flow with barrier synchronization is understandable, yet dead code and missing context such as USE_TIME and opsPerMS reduce clarity, resulting in a moderate readability score","tokens":857,"name":"172.jsnp"}
{"score":"85","reasoning":"The method is short and clear. Annotations are placed on separate lines making intent obvious. Variable names are meaningful. Transaction handling is explicit. The only minor issue is the inline comment which could be removed. Overall readability is high.","tokens":684,"name":"168.jsnp"}
{"score":"30","reasoning":"The method mixes framework calls with low level JDBC in a single anonymous class, uses deep casting and long chained calls, has no comments, ignores exceptions and embeds raw SQL strings. The naming is minimal and the flow is hard to follow, reducing readability significantly.","tokens":868,"name":"100.jsnp"}
{"score":"78","reasoning":"The constructor is clear and self‑explanatory, each registerFunction call is on its own line with descriptive names and appropriate type arguments. The repetitive pattern aids scanning, but the long list without grouping or comments makes it slightly harder to locate specific functions. Overall readability is good but could be improved with logical grouping or documentation.","tokens":921,"name":"18.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear annotations, descriptive variable names and straightforward assertions. Comments explain the purpose. Minor issues are inconsistent indentation and raw string concatenation for SQL which slightly reduces clarity, but overall the code is easy to follow.","tokens":1027,"name":"136.jsnp"}
{"score":"68","reasoning":"The code uses clear naming and straightforward JUnit style, but nested anonymous classes and overridden methods increase cognitive load. Indentation is good and logic flows logically, yet lack of comments and compact lambda style may hinder quick understanding for less experienced readers, resulting in a moderate readability score","tokens":632,"name":"12.jsnp"}
{"score":"78","reasoning":"The method uses clear naming and consistent indentation, making the flow easy to follow. Nested conditionals are straightforward but could be simplified with early returns. The single inline comment is helpful but the code mixes several responsibilities, slightly reducing clarity. Overall readability is good but not exceptional.","tokens":861,"name":"198.jsnp"}
{"score":"55","reasoning":"The method is short and uses clear naming but the logic is incomplete and always returns null. The conditional block is simple and the call to reassociateIfUninitializedProxy is self explanatory for those familiar with Hibernate. However the lack of handling for the value and missing documentation reduces clarity. Overall readability is moderate.","tokens":748,"name":"65.jsnp"}
{"score":"70","reasoning":"The method is short and clearly named and the logic is straightforward, but it mixes tabs and spaces, uses raw Iterator without generics and concatenates strings for logging which reduces clarity. Adding generics, consistent formatting and more comments would improve readability.","tokens":908,"name":"7.jsnp"}
{"score":"55","reasoning":"The method is short but suffers from deep nested if‑else blocks, inconsistent indentation and repeated setSelected calls. Variable names are generic and the logic could be flattened with early returns or a switch, making it harder to follow quickly","tokens":733,"name":"157.jsnp"}
{"score":"68","reasoning":"The method is fairly straightforward with descriptive names for reader writer and parse state stack. Indentation is clear and the logic flow is easy to follow. However the use of raw Stack reduces type safety, a commented out cast adds confusion, and the lack of generics and minimal error handling lower readability. Overall moderate clarity.","tokens":897,"name":"116.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical grouping of assertions. It uses standard JUnit patterns and reflection clearly. However the long sequence of assertions without comments makes it dense and slightly harder to follow, reducing readability. Overall it is fairly easy to understand for a Java developer.","tokens":1166,"name":"135.jsnp"}
{"score":"85","reasoning":"The method is concise and uses a fluent StringBuilder chain that is easy to follow. Variable names are clear and the null check for region is explicitly documented. Indentation and line breaks aid readability. Minor issues are the inline comment style and lack of an else branch, but overall the code is straightforward","tokens":778,"name":"64.jsnp"}
{"score":"68","reasoning":"The method name and purpose are clear and the code is well indented. Validation call is straightforward. However the use of a raw Map reduces type safety and readability, and the long constructor call with many parameters is hard to scan. The TODO comment indicates incomplete handling of features. Overall the snippet is moderately readable but could be improved with generics and clearer parameter grouping.","tokens":554,"name":"55.jsnp"}
{"score":"85","reasoning":"The test method is clearly structured with descriptive variable names and consistent formatting. Each case follows the same pattern making it easy to follow. Repetition could be reduced with a helper method but does not hinder comprehension. Overall the code is readable and straightforward for someone familiar with JUnit and SQL rendering","tokens":824,"name":"26.jsnp"}
{"score":"78","reasoning":"The method is concise and follows common JUnit and Hibernate patterns. Annotations, variable names and the query are clear. The pagination parameters are hard‑coded which slightly reduces clarity, and there is a leftover commented print line. Overall the code is easy to read and understand.","tokens":786,"name":"92.jsnp"}
{"score":"78","reasoning":"The test method is clearly named and follows a logical flow: setup reader, verify presence of ElementCollection, then systematically assert absence of many unrelated annotations, and finally check specific properties of the ElementCollection annotation. The repetitive assert calls make it verbose but still understandable. Minor refactoring could improve brevity, but overall readability is good","tokens":852,"name":"176.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear variable names and logical flow. Preconditions are checked early, and a StringBuilder accumulates text efficiently. The switch cleanly separates handling of character data, entity references, and ignored events. Minor concerns are the loop condition that relies on end‑document and lack of inline comments, but overall the code is easy to follow.","tokens":1141,"name":"152.jsnp"}
{"score":"90","reasoning":"The method is well documented with Javadoc, uses descriptive names, clear control flow, and simple logic. Formatting and spacing aid readability. Minor improvement could be adding inline comments for complex steps, but overall easy to understand.","tokens":796,"name":"126.jsnp"}
{"score":"78","reasoning":"The method is straightforward, uses descriptive names and clear JPA transaction blocks. Repeated find and transaction code reduces readability, and comments are helpful but could be formatted better. Overall the snippet is easy to follow but could be more concise. Score 78","tokens":998,"name":"188.jsnp"}
{"score":"70","reasoning":"The test method is short and uses descriptive names which aids comprehension. The use of a try catch finally pattern is clear. However the long chained calls to obtain the prepared statement make the code harder to read and the lack of comments forces the reader to infer intent. Overall readability is moderate","tokens":732,"name":"145.jsnp"}
{"score":"70","reasoning":"The method is concise and uses a clear naming convention for test cases. Each parse call is on a separate line which aids readability, though the long query strings reduce clarity. The commented out examples are helpful for context but add visual clutter. Overall the structure is simple but the dense strings make quick comprehension harder","tokens":824,"name":"85.jsnp"}
{"score":"85","reasoning":"The method is concise and follows standard Java naming conventions. Variable and method names are descriptive, making the intent clear. The nested if structure is simple and easy to follow. Presence of commented out code slightly detracts from readability but does not obscure the core logic.","tokens":578,"name":"11.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear steps: setup entity, verify revisions, clear and modify map, query audit data and assert results. Variable names are descriptive but rely on external context. Use of raw List and casting reduces type safety. Long query chain is a bit dense but still understandable. Overall readability is good but not perfect.","tokens":1058,"name":"167.jsnp"}
{"score":"82","reasoning":"The method is clearly organized with descriptive names, consistent indentation and helpful logging. Variable declarations are concise and error messages are explicit. The nested conditionals are straightforward but add some cognitive load, and the reliance on external types makes full understanding dependent on surrounding code. Overall readability is good but not exceptional.","tokens":965,"name":"183.jsnp"}
{"score":"78","reasoning":"The test method is short and its name clearly describes the scenario being verified. It follows a simple sequence of helper calls that make the intent easy to follow. However the lack of inline documentation about the helper methods and the generic naming of some steps reduces clarity slightly, preventing a higher score.","tokens":692,"name":"187.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming and consistent indentation. Each conditional branch is self explanatory and the logic follows a logical precedence. Helper methods keep the code concise. Minor verbosity and multiple else if statements slightly reduce readability but overall it is easy to understand","tokens":1043,"name":"107.jsnp"}
{"score":"78","reasoning":"The method is short and clearly named, parameters are descriptive and the logic follows a simple sequence: set the property, optionally update the snapshot, and return a comparison result. Variable names like lazyPropertyNumbers and lazyPropertyTypes are meaningful within context, but reliance on external fields may require additional knowledge. Overall readability is good but not exceptional","tokens":800,"name":"104.jsnp"}
{"score":"80","reasoning":"The test method is well structured and uses descriptive names making the intent clear. Repetitive blocks and lack of comments slightly reduce readability, but assertions are straightforward and line length is reasonable. Overall the code is easy to follow for someone familiar with the testing framework","tokens":865,"name":"88.jsnp"}
{"score":"78","reasoning":"The method is fairly readable with clear variable names and straightforward logic. It checks parameter count, creates an instance, and injects fields using reflection. However, it uses generic Exception, long concatenated messages, and lacks comments, which slightly reduces clarity. Overall comprehension is good but could be improved with specific exception types and formatting.","tokens":732,"name":"13.jsnp"}
{"score":"85","reasoning":"The code is well formatted and uses descriptive names for the test method, variables and assertions making it easy to follow. The use of JUnit annotations and clear separation of steps (setup, execution, verification) enhances readability. Minor drawbacks are reliance on external helper methods whose implementations are not shown, which could slightly hinder full comprehension.","tokens":547,"name":"159.jsnp"}
{"score":"78","reasoning":"The test method is well named and uses clear variable names. The sequence of opening a session creating entities saving committing and then reloading and deleting is easy to follow. The extensive comments explain the purpose but add length. Overall readability is good but the long method name and nested class usage slightly reduce clarity","tokens":1071,"name":"175.jsnp"}
{"score":"78","reasoning":"The test method is well named and follows a clear structure: setup, annotation checks, extraction of AttributeOverrides and detailed verification of each Override. The repeated assert calls make it verbose but still understandable. Formatting and naming aid readability, though the long list of assertions could be grouped. Overall readability is good","tokens":1054,"name":"177.jsnp"}
{"score":"78","reasoning":"The method is concise and follows a clear pattern. Variable names stdName and acctName convey their purpose, and the repeated calls to getSawRegionModification and getSawRegionAccess for both listeners are easy to follow. Logging adds context. No complex logic or nesting, making it readable, though the intent of the listener methods could be documented for better clarity.","tokens":814,"name":"190.jsnp"}
{"score":"90","reasoning":"The method is well documented with a clear Javadoc comment, uses descriptive variable names and follows a simple pattern of reading paint objects. The repetitive calls are easy to follow and there are no complex constructs. The only minor drawback is the long list of similar statements which could be refactored, but overall readability is high","tokens":1081,"name":"3.jsnp"}
{"score":"78","reasoning":"The method is short and well structured with clear variable names. Consistent indentation and logical grouping of addNotationProvider calls make the flow easy to follow. The commented out line adds minor noise but does not obscure meaning. Overall the code is readable and its purpose is evident.","tokens":752,"name":"5.jsnp"}
{"score":"85","reasoning":"The constructor is short and uses clear descriptive method names that convey its purpose, follows standard Java conventions and contains no complex logic, making it easy to read. Minor drawbacks are the absence of inline comments and lack of context about the registered mappings, which prevents a perfect score.","tokens":645,"name":"19.jsnp"}
{"score":"70","reasoning":"The test method clearly demonstrates saving and retrieving a composite id using Hibernate sessions, and the intent is understandable. However indentation is inconsistent, comments are embedded in code, and there is no try‑finally for resource cleanup, which hampers readability. Variable names are descriptive but the flow could be more concise, resulting in moderate overall comprehension.","tokens":1005,"name":"72.jsnp"}
{"score":"78","reasoning":"The method is well‑structured and uses clear naming such as annotatedFieldsByParameter and usedIndices which aids comprehension. It follows a logical flow: super call, annotation check, index validation, and duplicate detection. However the nested loops and long inline error messages reduce readability, and extracting validation logic into helper methods would improve clarity.","tokens":739,"name":"14.jsnp"}
{"score":"78","reasoning":"The test method is straightforward and uses descriptive names for entities and variables which aids comprehension. However the repeated session boilerplate, raw collection types, and lack of generics add noise. The long method could be split into helper functions for setup and cleanup, improving readability. Overall the code is moderately readable but could be cleaner","tokens":771,"name":"82.jsnp"}
{"score":"78","reasoning":"The method is fairly clear with descriptive names and straightforward loops and conditionals. Comments explain the intent and the logic is easy to follow. However casting without null checks and long chained method calls reduce clarity, and some variable names could be more explicit. Overall readability is good but not exceptional","tokens":837,"name":"51.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc header and uses descriptive variable names such as minimum, maximum, positive and negative. The logic is straightforward: iterate categories, sum positive and negative values, then compute range. Minor issues include nested loops that could be extracted and a redundant comment line, but overall the code is easy to follow","tokens":788,"name":"41.jsnp"}
{"score":"78","reasoning":"The test method is well structured and uses descriptive variable names which aid readability. The sequence of Hibernate configuration calls is clear, and assertions are self‑explanatory. However the long chained calls reduce immediate clarity, there are no comments explaining the purpose, and the magic index 0 in getGetter could be confusing for readers unfamiliar with the API.","tokens":633,"name":"178.jsnp"}
{"score":"78","reasoning":"The test method is well structured with descriptive names and clear assertions, making its intent easy to follow. However the repeated iterator checks and long block of similar statements add verbosity and reduce conciseness. The use of generic collections is straightforward but the overall length makes it slightly harder to scan quickly","tokens":1061,"name":"180.jsnp"}
{"score":"85","reasoning":"The method is clearly structured with annotations, descriptive variable names and sequential transaction blocks. Inline comments label each revision, making intent obvious. Repetitive transaction boilerplate could be refactored, but overall the flow is easy to follow.","tokens":939,"name":"189.jsnp"}
{"score":"78","reasoning":"The method name and variable names are descriptive, making intent clear. Use of early returns simplifies flow. However formatting is inconsistent with missing spaces and long lines, and a suppressed warning annotation adds noise. Overall readability is good but could be cleaner, hence a moderate-high score.","tokens":700,"name":"111.jsnp"}
{"score":"65","reasoning":"The test method name is clear but the single assertion contains a long chained call with a cast that reduces readability. Breaking the call into intermediate variables would improve comprehension. The purpose is understandable for experienced developers, yet the dense expression makes it moderately hard to follow.","tokens":622,"name":"199.jsnp"}
{"score":"70","reasoning":"The method is short and well indented, making the flow easy to follow. Each array element is a call to a clearly named helper method, which aids comprehension. However the use of a raw Object array and several null entries reduces clarity, and a collection type or comments would improve readability. Overall readability is good but not optimal","tokens":764,"name":"156.jsnp"}
{"score":"70","reasoning":"The method name and variable names are descriptive which aids comprehension. The code is concise and follows a clear flow from obtaining a collection persister to delegating to getSingularSubAttributes. However the heavy use of casts and long chained calls can make it harder for a reader to follow without context, and lack of comments reduces clarity. Overall readability is moderate.","tokens":708,"name":"148.jsnp"}
{"score":"70","reasoning":"The test method is fairly long with nested anonymous classes and many casts which reduces clarity. Variable names are clear and the flow of creating criteria and checking results is logical, but excessive parentheses and inline comments make it harder to read for newcomers","tokens":979,"name":"97.jsnp"}
{"score":"78","reasoning":"The method is well documented and uses clear variable names. The use of a read lock and atomic variables is explained in comments. However the compact for loops with compareAndSet are dense and may be hard for newcomers. Overall readability is good but not excellent, resulting in a score of 78","tokens":854,"name":"62.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive final variables making the purpose obvious; the expected string is built with concatenation which is readable but the long literals make the line a bit dense; overall the structure and assertions are straightforward and easy to follow","tokens":841,"name":"24.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names, making it easy to follow. The constant PRIME is defined locally, which is fine for a small method. However the order of operations is unconventional, mixing addition before multiplication, and it does not follow the typical hashCode pattern recommended by Java. Minor style issues reduce the score slightly.","tokens":481,"name":"141.jsnp"}
{"score":"70","reasoning":"The method name and helper calls are descriptive and the inline comment explains the purpose which aids comprehension However the method is long contains many sequential calls and a nested loop mixing several concerns making it harder to follow Splitting into smaller methods would improve readability","tokens":1233,"name":"149.jsnp"}
{"score":"78","reasoning":"The constructor is well organized with clear method calls and descriptive names. Use of localization and helper methods improves readability. Minor issues are long lines and a typo in label keys. Overall the code is easy to follow and understand","tokens":888,"name":"158.jsnp"}
{"score":"55","reasoning":"The method is short but uses generated parser constructs such as a labeled do while loop, token set checks and exception types that are not explained. Variable names like _tokenSet_6 and LA(1) are cryptic, reducing readability. Indentation is clear but overall comprehension requires knowledge of the parser framework","tokens":732,"name":"115.jsnp"}
{"score":"80","reasoning":"The method is clear and concise, using a HashSet to collect string constants and returning an unmodifiable view. Variable naming is appropriate and the sequence of adds is easy to follow. However it could be simplified with Set.of in newer Java versions, and the explicit generic type on HashSet is redundant, slightly lowering the score.","tokens":581,"name":"16.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming and logical flow. Annotations are verbose but self explanatory, and the code uses straightforward object creation, persistence, and assertions. Minor issues are the dense annotation list and a console print, but overall readability is high","tokens":1000,"name":"138.jsnp"}
{"score":"65","reasoning":"The method is moderately readable but suffers from raw types, long lines, nested ternary operators and unclear variable names. The control flow is straightforward, yet the lack of generics, excessive inline logic and ambiguous suffix handling reduce clarity, making maintenance harder","tokens":939,"name":"34.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment, uses descriptive variable names, and follows a standard listener pattern. Indentation and spacing make the flow easy to follow. The lazy creation of the event is straightforward. The only minor drawback is the loop indexing using i-\u003d2 which may require familiarity with the listener array structure.","tokens":866,"name":"9.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and variable names are descriptive. The flow is simple with null checks and early returns. Minor readability issues are inconsistent indentation, a long string concatenation line, and generic type casting that add some visual noise, but overall the code is easy to follow.","tokens":812,"name":"125.jsnp"}
{"score":"70","reasoning":"The method is clearly documented and uses straightforward variable names, but the series of manual shift operations is verbose and harder to follow than a loop or ByteBuffer approach. The repeated pattern is evident, yet the code could be more concise, which slightly lowers readability","tokens":750,"name":"113.jsnp"}
{"score":"70","reasoning":"The method name clearly states its purpose and the loop logic is simple, but the repeated long getter calls make the line hard to read and maintain. Breaking the closures into local variables or using a collection would improve clarity. Overall the code is understandable but not optimally readable.","tokens":794,"name":"105.jsnp"}
{"score":"85","reasoning":"The method is short and self explanatory with a clear Javadoc comment. Variable names are meaningful and the logic uses straightforward if statements to detect line endings. Indentation is consistent and the return values are obvious. Minor improvements could combine the checks or use else if but overall readability is high","tokens":650,"name":"6.jsnp"}
{"score":"55","reasoning":"The method is straightforward but suffers from repetitive type checks, raw Vector usage, and vague variable names. The long series of if statements reduces clarity and could be refactored. While the logic is easy to follow, the code is not very concise or modern, lowering readability.","tokens":1029,"name":"119.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming, inline comments, and straightforward logic. The inner Verifier class encapsulates the tree search, making the test assertions easy to read. Indentation and spacing are consistent, and the use of constants improves clarity. Minor issues include using Stack as a queue which may confuse readers but does not hinder comprehension","tokens":923,"name":"87.jsnp"}
{"score":"78","reasoning":"The test method is well‑named and uses clear variable names, making its purpose easy to follow. Assertions are straightforward and the use of helper methods improves readability. However the long constructor call and lack of inline comments make it slightly harder to parse quickly, preventing a higher score.","tokens":758,"name":"142.jsnp"}
{"score":"65","reasoning":"The method uses many nested if statements and repeated type checks and casts, which makes the flow hard to follow. Indentation is clear but the duplicated blocks for each event type reduce readability. A more polymorphic design or a map of handlers would simplify the code and improve comprehension.","tokens":877,"name":"43.jsnp"}
{"score":"85","reasoning":"The method is well documented, uses clear variable names and follows a logical flow. The try‑catch block handles SQL errors cleanly and helper methods make intent clear. Conditional checks for limit handling and type discovery add some complexity but remain readable. Overall the code is easy to understand and maintain.","tokens":832,"name":"33.jsnp"}
{"score":"92","reasoning":"The constructor is concise and well structured, using clear method calls to map SQL types to database types. Indentation and naming are consistent, making the purpose obvious. The only minor drawback is the absence of inline comments explaining specific mappings, but overall readability and comprehension are high","tokens":796,"name":"25.jsnp"}
{"score":"65","reasoning":"The method is short and uses clear variable names but suffers from duplicated logic for table handling, inconsistent indentation and a redundant target set call. The flow is easy to follow but could be refactored for clarity, reducing repetition and improving naming. Overall readability is moderate.","tokens":772,"name":"10.jsnp"}
{"score":"85","reasoning":"The method is concise and uses descriptive names for variables and parameters. Generic type handling and JAXB usage are clear. Helper calls abstract details, improving readability. Minor issues include lack of resource closing and no comments, but overall the flow is easy to follow","tokens":711,"name":"194.jsnp"}
{"score":"68","reasoning":"The test method has a descriptive name and clear structure but contains unexplained helper calls and a silent catch block which reduces clarity. The use of thrown.expectMessage is straightforward yet missing comments and context for TIMEOUT and helper methods makes it moderately readable","tokens":883,"name":"160.jsnp"}
{"score":"78","reasoning":"The method is concise and uses descriptive names, making the flow easy to follow. The boolean flush expression is a bit dense but still understandable. Comments are minimal but helpful. Overall the structure is clear and logical, leading to good readability for experienced Java developers.","tokens":799,"name":"184.jsnp"}
{"score":"70","reasoning":"The method is concise and uses clear naming. The anonymous subclass with overridden methods is easy to follow but nesting adds some complexity. Indentation is good, but lack of comments and inline documentation makes intent less obvious. Overall readability is moderate, so a score of 70 reflects decent but not excellent clarity.","tokens":787,"name":"132.jsnp"}
{"score":"80","reasoning":"The method is well documented with Javadoc, uses clear variable names and consistent indentation. The flow is straightforward: retrieve element, return its value or null, and handle cache exceptions with specific handling for NonStopCacheException. Minor style issues such as an unnecessary else after a return and a generic catch could be refined, but overall readability is high","tokens":783,"name":"164.jsnp"}
{"score":"70","reasoning":"The code uses descriptive names and logical flow, but deep nesting with an anonymous inner class and multiple conditionals makes it harder to follow. Lack of comments and a long method body reduce clarity, though indentation is consistent and variable names are clear.","tokens":784,"name":"173.jsnp"}
{"score":"78","reasoning":"The method is clearly named and parameters are descriptive. Control flow is straightforward with early return on user cancellation. Variable names are meaningful and indentation is consistent. Use of try‑finally ensures resource cleanup, though modern try‑with‑resources would be clearer. Minor issues include a magic default scale value and a long line for the confirm dialog, but overall readability is good","tokens":615,"name":"49.jsnp"}
{"score":"35","reasoning":"The method mixes primitive and wrapper comparisons, uses a very long chained \u0026\u0026 expression, has inconsistent spacing and formatting, includes commented out code, and repeats null checks. Variable names are not descriptive and the logic is dense, making the code hard to follow and maintain.","tokens":1192,"name":"74.jsnp"}
{"score":"85","reasoning":"The method is concise and follows a common pattern for equals implementations. It uses early returns, clear type check, and field by field comparison, making the logic easy to follow. Variable names are descriptive and the Javadoc explains the contract. Minor improvements could include using Objects.equals or handling floating point precision, but overall readability is high.","tokens":729,"name":"114.jsnp"}
{"score":"70","reasoning":"The method is short and its intent is clear, but the nested cast and long method chain reduce readability. The empty catch block with a comment is acceptable but could be more explicit. Overall the code is understandable but could be cleaner, earning a moderate score","tokens":688,"name":"95.jsnp"}
{"score":"45","reasoning":"The method is long and repetitive, making it hard to follow. Each line repeats the same pattern with different boolean arrays, which could be extracted into a loop or helper. Naming is clear but the dense inline array literals reduce readability. Overall the code is functional but not easy to comprehend quickly.","tokens":788,"name":"59.jsnp"}
{"score":"78","reasoning":"The method is well documented with Javadoc, uses clear naming and logical structure. Generic bounds are explicit, and the try‑finally blocks handle execution and cleanup clearly. Minor drawbacks are nested try‑finally and a comment about double iteration that adds mental overhead, but overall the code is easy to follow","tokens":977,"name":"110.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear setup, save, query and cleanup phases. Variable names are descriptive and the use of Hibernate Session is straightforward. However the inline comments and TODO hint at incomplete behavior, and the purpose of several queries is not obvious, slightly reducing overall clarity.","tokens":1013,"name":"80.jsnp"}
{"score":"85","reasoning":"The method is well named and uses clear variable names. Comments explain the JPA spec rules. The two loops are straightforward and the logic is simple. Minor issues are inconsistent indentation and extra spaces, but they do not hinder understanding. Overall the code is easy to follow.","tokens":1068,"name":"27.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear variable names and logical sections making the flow easy to follow Assertions are straightforward and the use of a helper optimizer builder keeps the test concise Minor improvements could be added for documentation but overall readability is high","tokens":1048,"name":"56.jsnp"}
{"score":"68","reasoning":"The method has a helpful comment and clear variable names like iconX iconY and item. However it repeats almost identical loops, uses raw Vector and casts, and lacks a helper to avoid duplication. The old style collections and casting reduce readability, so the overall ease of comprehension is moderate","tokens":932,"name":"121.jsnp"}
{"score":"70","reasoning":"The method name clearly describes its purpose and variable names are meaningful. The logic is straightforward with early returns and simple conditionals. However the long name, nested ifs, and reliance on external context like metadata reduce clarity. Minor formatting issues also affect readability","tokens":857,"name":"147.jsnp"}
{"score":"78","reasoning":"The method is fairly clear: it obtains a constructor, handles missing constructor, creates an instance, sets name for no‑arg TestCase, and returns warnings on errors. Variable names are descriptive and exception handling is explicit. However the nested try‑catch blocks and use of raw Object arrays make the flow a bit dense and the warning helper is not shown. Overall readability is good but could be simplified.","tokens":932,"name":"2.jsnp"}
{"score":"85","reasoning":"The method follows the conventional equals pattern with clear checks for identity, super equality, class type and field comparison. Indentation and naming are straightforward, making it easy to read. Minor improvement could be using Objects.equals, but overall readability is high","tokens":673,"name":"169.jsnp"}
{"score":"85","reasoning":"The snippet is well formatted and uses clear naming. The comment explains the purpose, the @Test annotation and method signature are standard. The anonymous subclass overrides a single method in a concise way, making the intent obvious. No complex logic or obscure constructs are present, resulting in high readability.","tokens":592,"name":"53.jsnp"}
{"score":"78","reasoning":"The constructor is well structured with clear variable names and logical ordering of UI setup steps. Formatting is consistent and the code is easy to follow. Minor issues are a repeated setAutoResizeMode call and lack of inline comments for some settings, but overall readability is high.","tokens":835,"name":"118.jsnp"}
{"score":"70","reasoning":"The code is straightforward and uses clear variable names, making the intent easy to follow. However the repetitive creation and saving of objects could be simplified with loops or helper methods, and the ordering of saves is non‑intuitive. Lack of comments and minor formatting issues reduce overall readability.","tokens":768,"name":"76.jsnp"}
{"score":"70","reasoning":"The test method is clearly structured with setup execution and cleanup sections. Naming is descriptive and the try catch clearly shows the expected exception. However the long chained calls and anonymous inner class make the code verbose and harder to follow and could be simplified with a lambda. Overall readability is good but not excellent","tokens":845,"name":"94.jsnp"}
{"score":"78","reasoning":"The method has clear naming, straightforward loops over super classes, methods and fields, and uses helper functions for sorting and adding to maps. Indentation and structure are clean, making the flow easy to follow. Minor verbosity and reliance on external utilities prevent a perfect score","tokens":734,"name":"52.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and the parameter is well‑named. Each call to registerStrategyImplementor is formatted consistently, making the flow easy to follow. However the repeated pattern suggests an opportunity for a loop or helper to reduce duplication, which would improve maintainability. Overall the code is readable but could be more concise.","tokens":575,"name":"171.jsnp"}
{"score":"70","reasoning":"The method is short and uses descriptive names, each line calls parse with a string literal. The presence of many similar strings makes it a bit dense, but the structure is clear and comments explain intent. Overall it is fairly readable for a test case.","tokens":788,"name":"86.jsnp"}
{"score":"78","reasoning":"The test method is well named and follows a clear sequence of steps making the intent easy to follow. Variable names are descriptive and the use of session and filters is straightforward. Minor issues are the raw List type magic positional parameter index and lack of generics which slightly reduce clarity.","tokens":1213,"name":"91.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical steps: open session, begin transaction, create entity, save, flush, execute raw SQL via an anonymous AbstractWork, refresh and assert values, check lock mode, delete, commit and close. The inner class adds some nesting but remains straightforward. Dialect-specific quoting and conditional lock mode check add minor complexity but overall the code is easy to follow","tokens":938,"name":"69.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear indentation and descriptive names that aid comprehension. It uses builder pattern and conditional logic that is easy to follow. However the nested method calls are lengthy, making the line hard to parse, and the cast to OuterJoinLoadable could be clarified. Overall readability is good but could be improved with intermediate variables.","tokens":692,"name":"182.jsnp"}
{"score":"85","reasoning":"The snippet is short and self contained making it easy to follow the intent. Variable names are clear and the JUnit API usage is standard. Adding a listener and checking failures is straightforward. Minor issues are lack of comments and the method name is long but still descriptive. Overall readability is high","tokens":567,"name":"124.jsnp"}
{"score":"78","reasoning":"The test method is well named and includes a brief comment explaining the context. Each SyntaxChecker call is on its own line, making the HQL queries easy to scan. The repetitive pattern could be refactored into a loop or helper, but overall the code is straightforward and readable for someone familiar with JUnit and Hibernate.","tokens":1199,"name":"79.jsnp"}
{"score":"85","reasoning":"The method follows a common pattern for equals with early returns and clear null checks. Variable names are descriptive and the logic is straightforward. Using Objects.equals would be slightly cleaner but the current form is still readable. Overall the code is easy to understand for someone familiar with Java","tokens":521,"name":"70.jsnp"}
{"score":"78","reasoning":"The method has clear naming and straightforward logic with early returns, but the nested if and long condition line reduce readability. Inline comments aid understanding but the formatting could be cleaner. Overall the code is moderately easy to follow.","tokens":769,"name":"29.jsnp"}
{"score":"80","reasoning":"The test method name clearly states its purpose and the @Test annotation makes its role obvious. Indentation is consistent and the assertEquals call is straightforward. The nested calls are a bit deep which slightly hurts readability, but the use of descriptive helper methods keeps the intent clear. Overall the code is easy to follow","tokens":667,"name":"165.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear annotations and descriptive variable names. Comments explain the purpose of each check. Session handling and entity creation are straightforward. Minor complexity arises from Hibernate specifics but overall the flow is easy to follow","tokens":1152,"name":"78.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive variables making its purpose obvious. The flow of setting up a timeout invoking evaluate and checking the exception is straightforward. The loop that inspects stack trace elements is simple and well named. Minor verbosity and nested assertions slightly reduce brevity but do not hinder comprehension.","tokens":1060,"name":"161.jsnp"}
{"score":"78","reasoning":"The test method is clearly structured with setup execution verification and cleanup. Indentation is consistent and variable names are meaningful. Use of raw Iterator and a long assert message slightly reduces clarity but overall flow is easy to follow","tokens":933,"name":"137.jsnp"}
{"score":"78","reasoning":"The constructor is concise and uses clear variable names that convey purpose. It handles null checks with ternary operators and creates appropriate collections, which is efficient. However the long lines and nested generic types reduce readability, and the repeated pattern could be extracted to a helper method for clarity. Overall the code is understandable but could be cleaner","tokens":692,"name":"196.jsnp"}
{"score":"78","reasoning":"The constructor is clear and well documented with a Javadoc comment. It delegates to a more detailed constructor using constants and boolean flags, which makes the intent obvious. Inline comments after the booleans help understand each flag. The long parameter list could be harder to read, but overall the code is straightforward and easy to follow","tokens":705,"name":"4.jsnp"}
{"score":"85","reasoning":"The test method is well named and follows a clear structure with setup, action, verification and cleanup. Variable names are descriptive and the flow is easy to follow. Some domain specific terms may require background knowledge but overall the code is readable and maintainable","tokens":881,"name":"75.jsnp"}
{"score":"45","reasoning":"The method is long and repetitive, performing many null assignments, collection removals and Hibernate merge/delete calls. Variable names are short and generic, and there are no comments to explain the intent, making the flow hard to follow. Consistent naming and straightforward API usage help a little, but overall readability is moderate at best.","tokens":956,"name":"200.jsnp"}
{"score":"75","reasoning":"The code is concise and uses an anonymous thread to run a test but the inline comment about limitation is confusing and the naming could be clearer overall readability is moderate","tokens":597,"name":"1.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical flow. Use of JPA Criteria API is straightforward, but the generic syntax and nested subquery make it slightly dense for newcomers. Overall readability is good for experienced developers, leading to a solid score","tokens":762,"name":"163.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear setup, actions, and assertions. Annotations and variable names are descriptive. However long inline SQL strings, a conditional dialect block, and a comment reduce readability. Formatting is decent but could be improved with helper methods. Overall readability is good but not excellent","tokens":945,"name":"71.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names and a straightforward switch to map SQL state codes to constraint names. The extraction logic is encapsulated in a helper method, making the main flow easy to follow. However the use of raw numeric SQL state codes without named constants and minimal comments reduces readability.","tokens":790,"name":"22.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and consistent use of constants, making the intent easy to follow. The sequence of hint settings and assertions is logical. However the cast to internal Hibernate classes adds some complexity and the repeated assertions increase length, slightly reducing readability","tokens":1085,"name":"162.jsnp"}
{"score":"78","reasoning":"The code is clear and self explanatory. Variable names are descriptive and the sequence of creating listeners then registering them follows a logical order. Formatting is consistent though a few lines could be broken for readability. No complex logic is present. Overall readability is good","tokens":840,"name":"139.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical sequence of setting properties, creating the factory, building regions, and asserting configuration values. Variable names are descriptive and the use of try‑finally ensures cleanup. The only drawback is the repetitive property setup and lack of helper methods but overall the code is easy to follow","tokens":1017,"name":"130.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical flow, making the purpose easy to follow. The extensive comments explain the JPA mapping rules, aiding comprehension. However the method is lengthy, contains nested calls and dot notation that can be hard to parse quickly, slightly reducing readability.","tokens":1021,"name":"134.jsnp"}
{"score":"55","reasoning":"The method contains deep nested conditionals and unclear variable names which make the flow hard to follow. Repeated null checks and mixed responsibilities reduce clarity. The loop at the end is simple but overall readability suffers from complexity and lack of documentation. A score around mid range reflects these issues.","tokens":1130,"name":"155.jsnp"}
{"score":"80","reasoning":"The method follows a clear three step process with descriptive names and logical flow. Logging, context clearing, and iteration over collection entries are easy to follow. Inline comments aid understanding but the nested if else adds some complexity. Overall the code is readable and maintainable, deserving a high score","tokens":963,"name":"66.jsnp"}
{"score":"70","reasoning":"The method is short and its purpose is clear from the name. It uses descriptive facade calls to collect related elements, but it lacks generic type declarations, returns null instead of an empty set, and has no comments. Indentation is consistent but the use of raw Set reduces type safety. Overall readability is moderate.","tokens":768,"name":"123.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive names and simple conditional logic. It handles null and mode checks explicitly and throws a meaningful exception for unknown modes. The TODO comment hints at future changes but does not hinder understanding. Overall the code is easy to follow and maintain","tokens":666,"name":"32.jsnp"}
{"score":"65","reasoning":"The test method is long and repetitive, assigning many query results to the same raw List variable without generics or comments. Variable names are clear but the lack of spacing, inline string literals and repeated code reduce readability. Each query is on its own line which helps, but overall the method could be refactored for clarity.","tokens":1417,"name":"83.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear JUnit assertions and descriptive API calls, making the intent easy to follow. Variable names are meaningful and the flow (check inactive, begin transaction, check active, open session) is logical. Lack of comments and the final unused call reduce clarity slightly. Overall readability is good","tokens":727,"name":"128.jsnp"}
{"score":"65","reasoning":"The method is documented with a clear Javadoc, but the implementation suffers from raw types, inconsistent indentation, and unclear variable names. Use of raw Enumeration and Class arrays reduces type safety. The algorithm is simple but the formatting and lack of generics lower overall readability.","tokens":942,"name":"44.jsnp"}
{"score":"92","reasoning":"The method is concise and self explanatory with descriptive names for parameters and local variable clear indentation and spacing and a straightforward single line return that follows a builder pattern making it easy to understand","tokens":685,"name":"143.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment, uses descriptive variable names and follows a consistent pattern when writing each field using helper methods. The code is short, linear and easy to follow, making it highly readable","tokens":652,"name":"38.jsnp"}
{"score":"70","reasoning":"The method is fairly clear with descriptive names but suffers from deep nesting and repeated normalizer calls which hurt readability. The logic is split between applying a naming strategy and a simple case, making it understandable but somewhat verbose. Refactoring could improve clarity and reduce duplication.","tokens":752,"name":"30.jsnp"}
{"score":"85","reasoning":"The method is straightforward and uses descriptive names like walker and details, making its purpose clear. The repeated System.out.println calls are easy to follow, though they could be consolidated for brevity. The use of StringHelper.join is appropriate for joining collections. Overall the code is well‑spaced and readable, earning a high score.","tokens":580,"name":"144.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive variable names and follows a logical flow with early returns for synthetic properties and null metadata. Logging statements aid tracing. Generic types and casts add some complexity but are typical for JPA metamodel code. Overall readability is high, though the casting and metadata handling require domain knowledge.","tokens":901,"name":"84.jsnp"}
{"score":"78","reasoning":"The method follows a clear structure with descriptive variable names and a straightforward switch that matches hexadecimal characters. Token creation logic is standard for parsers. However the code is verbose, contains extra braces and repetitive case groups, which slightly hampers readability","tokens":851,"name":"117.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear session handling and descriptive variable names. The flow of creating, persisting, querying and cleaning up is easy to follow. Minor issues are the raw List type, an empty IN clause that may be confusing and lack of comments, which slightly reduce readability.","tokens":742,"name":"77.jsnp"}
{"score":"68","reasoning":"The method is short and uses clear naming for the main steps, but variable names like f and fr are terse, string concatenation in a loop is inefficient, and the control flow with the inSection flag is a bit hard to follow. Lack of comments and modern try‑with‑resources reduces clarity. Overall readability is moderate.","tokens":817,"name":"48.jsnp"}
{"score":"68","reasoning":"The method is moderately readable but suffers from deep nesting and multiple conditional branches that make the flow hard to follow. Variable names are clear but the long if-else chain and inline error handling reduce clarity. Overall comprehension is acceptable but could be improved with refactoring","tokens":806,"name":"15.jsnp"}
{"score":"78","reasoning":"The test method is fairly readable with descriptive names and logical grouping of assertions. Use of fluent session creation and explicit transaction handling is clear. However the heavy casting, repeated calls and lack of comments make the flow harder to follow for newcomers, reducing overall ease of comprehension","tokens":931,"name":"127.jsnp"}
{"score":"88","reasoning":"The method is clearly documented with Javadoc, uses descriptive names and simple control flow, early returns improve readability, and null handling is explicit. Indentation and spacing are consistent making the logic easy to follow. Minor verbosity in nested loops prevents a perfect score","tokens":791,"name":"40.jsnp"}
{"score":"68","reasoning":"The code is fairly straightforward with clear method and variable names, but readability suffers from a few issues. The nested call type.sqlTypes(mapping)[getTypeIndex()] is dense and could be broken out. The error messages contain grammatical errors and the method name getSqlTypeCode is overloaded, causing potential confusion. Lack of comments and handling of generic Exception also reduce clarity.","tokens":613,"name":"37.jsnp"}
{"score":"70","reasoning":"The method is fairly clear with descriptive names and logical steps but suffers from deep nesting, long lines, raw List usage and magic strings which hurt readability. Refactoring into smaller helpers would improve comprehension","tokens":996,"name":"109.jsnp"}
{"score":"65","reasoning":"The method is short and clearly documented, but uses a raw Vector and repetitive addElement calls. Lack of generics, magic constants and no loop make it verbose. Lazy initialization is simple but could be clearer with a static initializer. Overall readability is moderate.","tokens":753,"name":"45.jsnp"}
{"score":"78","reasoning":"The test method name is descriptive and the steps follow a logical order. Variable names are clear and the use of Hibernate session APIs is straightforward. Minor issues include inline comments that could be better formatted and a long method body without helper extraction, but overall the code is easy to follow","tokens":849,"name":"179.jsnp"}
{"score":"45","reasoning":"The method uses raw types and a legacy Vector which makes the code noisy. Variable names are short and the logic is straightforward but the lack of generics, unnecessary comments and verbose facade calls reduce clarity. Overall readability is moderate but could be improved significantly","tokens":756,"name":"120.jsnp"}
{"score":"78","reasoning":"The method is clearly named and uses descriptive variable names, making its purpose easy to grasp. The flow of opening a session, beginning a transaction, persisting entities, and handling the expected exception is logical. Nested try‑catch‑finally blocks are correctly used but add some visual complexity. Overall the code is readable with minor room for simplification.","tokens":856,"name":"129.jsnp"}
{"score":"78","reasoning":"The method uses clear variable names and logical structure, but deep nesting, repeated resolve calls and long lines reduce readability. Use of isInstance instead of instanceof adds verbosity. Overall the code is understandable but could be refactored for clarity","tokens":934,"name":"197.jsnp"}
{"score":"65","reasoning":"The test follows a clear sequence of steps but excessive separator comments and redundant casts make it harder to read; variable names are descriptive and assertions are straightforward, giving a moderate readability level","tokens":997,"name":"17.jsnp"}
{"score":"70","reasoning":"The method is fairly clear but has inconsistent indentation and repeated calls that reduce readability, plus commented out code that adds noise. Overall moderate readability gives a score around 70","tokens":852,"name":"122.jsnp"}
{"score":"70","reasoning":"The test method is straightforward, using assertEquals to compare expected revision lists with actual results from getAuditReader(). The repeated pattern is clear, but the long multiline calls and lack of comments make it slightly harder to follow, and variable names are not self explanatory, reducing readability","tokens":850,"name":"185.jsnp"}
{"score":"45","reasoning":"The method is indented clearly but suffers from several readability issues: raw Collection casts, use of \u003d\u003d for string comparison, magic string literals, unclear variable names, nested ifs and a TODO comment that signals uncertainty. The anonymous Runnable adds visual noise. Overall the logic is understandable but the style reduces clarity.","tokens":1046,"name":"154.jsnp"}
{"score":"78","reasoning":"The method is clear about handling different collection property names using descriptive constants, which aids understanding. However the long chain of else if statements repeats similar patterns, could be refactored with a switch or map, and inline exception throws add clutter. Overall the code is readable but not optimally organized.","tokens":1122,"name":"108.jsnp"}
{"score":"78","reasoning":"The method name clearly indicates its purpose and variable names are descriptive. The sequential instanceof checks make the logic easy to follow, and the recursion for nested tests is clear. However the long else‑if chain and repeated casting add verbosity, and a polymorphic design could simplify it. Overall readability is good but could be improved.","tokens":811,"name":"54.jsnp"}
{"score":"70","reasoning":"The method is straightforward: it puts a self binding, evaluates an expression, iterates over results and builds a string with a separator while handling model elements and expressions specially. Readability suffers from raw List and Iterator types, repeated Model.getFacade() calls and nested if statements. Using generics, helper methods and clearer naming would improve clarity.","tokens":944,"name":"8.jsnp"}
{"score":"85","reasoning":"The method builds a descriptive string using a fluent StringBuilder chain. Each field is appended on its own line, making the structure clear. Variable names are self explanatory and the use of getExecutionAvgTime is consistent. Minor improvements could include formatting or a static template, but overall readability is high","tokens":776,"name":"63.jsnp"}
{"score":"78","reasoning":"The method name and variable names are clear. It copies annotation values, checks if schema or catalog are already defined, and adds missing defaults. The flow is linear and easy to follow. Minor verbosity with boolean flags and list copying adds some noise but does not hinder comprehension","tokens":1020,"name":"195.jsnp"}
