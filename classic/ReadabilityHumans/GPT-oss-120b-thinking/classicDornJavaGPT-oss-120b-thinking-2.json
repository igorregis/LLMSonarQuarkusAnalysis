{"score":"40","reasoning":"The snippet only contains import statements which are clearly formatted and use fully qualified names, making them easy to understand. However, there is no actual implementation or logic to evaluate readability of code structure, naming, or comments, limiting the assessment to a basic level.","tokens":469,"name":"208.jsnp"}
{"score":"70","reasoning":"The snippet is short and uses clear naming conventions such as workflowContext and kaleoInstanceToken which aid comprehension. Standard Java idioms like containsKey and GetterUtil.getLong are familiar to most developers. However the lack of surrounding context, comments, and explicit type declarations for variables slightly reduces readability. Overall it is moderately easy to understand but could be clearer with more documentation.","tokens":488,"name":"133.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear method names, Javadoc comments and straightforward constructor logic. Variable names are descriptive and getters/setters are simple. Minor issues include missing field declarations and inconsistent indentation, but overall the snippet is easy to read and understand.","tokens":850,"name":"221.jsnp"}
{"score":"30","reasoning":"The snippet is poorly formatted and incomplete, making it hard to understand its purpose. An empty catch block hides errors, and the use of Thread.sleep with a magic number reduces clarity. Variable names are not descriptive, and the selenium click uses a raw XPath string without explanation. Overall readability and maintainability are low.","tokens":487,"name":"174.jsnp"}
{"score":"85","reasoning":"The code is cleanly formatted with clear method names and consistent indentation. Getter methods are simple and self‑explanatory. The hashCode and equals overrides include helpful Javadoc references and follow standard patterns, enhancing readability. Minor improvements could include more comprehensive equality checks, but overall the snippet is easy to understand.","tokens":666,"name":"150.jsnp"}
{"score":"85","reasoning":"The snippet is concise and uses clear naming for the constructor and method. The getIcon method is straightforward, calling a well‑named static helper. The commented out line in the constructor suggests incomplete implementation but does not hinder understanding. Overall readability is good, though the unused parameter and commented code slightly reduce clarity.","tokens":518,"name":"181.jsnp"}
{"score":"78","reasoning":"The code uses clear variable names and straightforward control flow, making it fairly readable. Early returns simplify logic, but the empty catch block hides errors and could be confusing. The conditional selection of layout set is explicit. Overall the snippet is understandable but could be cleaner with better exception handling and reduced duplication.","tokens":730,"name":"101.jsnp"}
{"score":"88","reasoning":"The snippet is concise and well‑structured with clear imports, a descriptive class name, and a straightforward test method. Naming follows conventions, and the code is easy to follow despite being incomplete. Minor missing context prevents a perfect score, but overall readability is high.","tokens":528,"name":"191.jsnp"}
{"score":"85","reasoning":"The code is cleanly formatted with consistent naming and simple logic. Each method is short and self explanatory. Exception handling is explicit. Lack of documentation and surrounding class context reduces clarity slightly but overall readability is high","tokens":671,"name":"153.jsnp"}
{"score":"65","reasoning":"The snippet is short and consistently indented, but it relies on an undefined BETTER_THAN operator and uses terse variable names. Magic constants 0.2f and 0.4f are unexplained and there are no comments, which reduces clarity. Overall the logic is understandable with effort but readability is only moderate.","tokens":767,"name":"112.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear method names and consistent indentation. Variable names are descriptive and the flow is straightforward, making it easy to follow. Minor issues include reliance on external constants and a lack of comments, but overall readability is good","tokens":763,"name":"186.jsnp"}
{"score":"78","reasoning":"The code follows Java conventions with clear class and method names, consistent indentation and useful comments. Constants are defined at the top, and imports are organized. However, the long import list and nested static method reduce immediate clarity, and lack of inline documentation for complex logic may hinder quick understanding. Overall readability is good but not exceptional.","tokens":823,"name":"151.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear null checks, descriptive method names and consistent indentation. Exception handling is straightforward. Lack of comments and a few long lines slightly reduce clarity, but overall the logic is easy to follow.","tokens":753,"name":"131.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear class and method names, proper indentation and use of descriptive variables. The Selenium actions are straightforward. However the manual wait loop with empty catch and magic timeout value reduces clarity and could be replaced by explicit wait utilities, slightly lowering readability","tokens":718,"name":"212.jsnp"}
{"score":"70","reasoning":"The code follows typical Java style with clear variable names and consistent indentation. Use of try catch and logging aids understanding. However reliance on external utilities and long method chains without comments makes intent less obvious, and the nested ifs add some complexity. Overall readability is decent but not exceptional","tokens":968,"name":"103.jsnp"}
{"score":"65","reasoning":"The code follows a typical Java style but uses raw collections without generics, making types unclear. Variable names are descriptive but the method is long and mixes UI creation with logic. Inline comments help but the nested listener adds complexity. Overall readability is moderate, not hard but could be improved","tokens":1101,"name":"106.jsnp"}
{"score":"55","reasoning":"The snippet is straightforward but readability is limited. Empty catch blocks hide errors, magic numbers like 90 and 1000 are unexplained, and there are no comments describing intent. Indentation is clear and variable names are descriptive, yet the overall structure could be cleaner with better error handling and named constants.","tokens":780,"name":"146.jsnp"}
{"score":"70","reasoning":"The code is consistently formatted and uses clear method names, making it easy to follow the control flow. However the repeated try‑catch pattern is verbose and could be refactored to reduce duplication, which would improve readability. The logging and exception handling are straightforward, but the lack of abstraction lowers the overall score.","tokens":563,"name":"140.jsnp"}
{"score":"55","reasoning":"The snippet is short but lacks comments and uses a magic string for a selector. The empty catch block hides potential errors and the break statement inside the try is not clearly explained. These factors reduce readability and make comprehension harder despite the simple structure","tokens":633,"name":"192.jsnp"}
{"score":"78","reasoning":"The snippet is a clear Java Swing component subclass with standard overrides for paintComponent, remove and addImpl. Variable names are simple and logic is straightforward. Minor issues are the unconventional underscore prefix and lack of comments, but overall the flow is easy to follow and indentation is consistent","tokens":754,"name":"170.jsnp"}
{"score":"85","reasoning":"The code follows standard Java conventions with clear JavaDoc comments, consistent naming, and proper indentation. Each getter and setter is simple and self‑explanatory, making it easy to understand. The repetition is expected for accessor methods, though it adds verbosity. Overall readability is high but could be improved with less boilerplate, such as using Lombok.","tokens":675,"name":"136.jsnp"}
{"score":"85","reasoning":"The snippet is short and clear, using standard Java naming conventions and Javadoc comments that explain each method. The @AutoEscape annotation is obvious in context. The only drawback is a stray comment delimiter at the start, which could cause confusion. Overall the code is easy to read and understand, earning a high readability score.","tokens":469,"name":"168.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions, method names are descriptive and the flow is straightforward. Repeated null and enabled checks with logging make the logic clear but cause redundancy that could be extracted. Lack of comments and minor duplication reduce readability slightly. Overall the snippet is easy to understand, earning a score of 78","tokens":866,"name":"116.jsnp"}
{"score":"80","reasoning":"The code is concise and uses clear naming conventions making it easy to follow. The class extends a base test suite and the suite method creates a TestSuite and adds two test suites, which is straightforward. However the snippet lacks imports and full context, which slightly reduces overall readability.","tokens":510,"name":"176.jsnp"}
{"score":"85","reasoning":"The code follows standard Java conventions with clear class and method names, consistent indentation, and logical grouping of permission checks and service calls. Imports are explicit and the use of exceptions is straightforward. Minor drawbacks are limited inline comments and lack of detailed Javadoc for methods, which slightly reduces immediate understandability.","tokens":767,"name":"175.jsnp"}
{"score":"70","reasoning":"The class is short and its purpose is clear. Method names are descriptive and the flow is easy to follow. However the use of a non generic Map, minimal documentation and leftover commented out logging reduce clarity. Overall readability is decent but not excellent.","tokens":1151,"name":"166.jsnp"}
{"score":"65","reasoning":"The snippet is fairly straightforward Selenium test code but suffers from repetitive calls and lack of comments. Variable names are clear and the flow is linear, yet the long chained method calls and the busy‑wait loop reduce readability. Overall it is understandable but could be cleaner","tokens":685,"name":"167.jsnp"}
{"score":"65","reasoning":"The code follows Java naming conventions and indentation, but uses an unusual label‑switch loop for flow control, making the logic harder to follow. Lack of comments and the verbose wait loop add noise. Variable names are clear, but overall structure reduces readability, leading to a moderate score.","tokens":746,"name":"102.jsnp"}
{"score":"55","reasoning":"The code mixes Selenium actions with control flow that is hard to follow. Indentation is inconsistent and the use of RuntimeVariables.replace for static strings adds noise. Variable names like label and boolean flags are vague, and the snippet lacks surrounding context such as method or class definitions. These factors reduce readability, resulting in a moderate score.","tokens":862,"name":"193.jsnp"}
{"score":"85","reasoning":"The code follows standard Java conventions, uses clear naming, and groups related constants in an inner interface for i18n. Imports are explicit and the constructor is straightforward. Minor drawbacks are the unconventional inner interface name and lack of comments for the class purpose, but overall it is easy to understand","tokens":862,"name":"172.jsnp"}
{"score":"30","reasoning":"The snippet is poorly formatted and incomplete making it hard to understand. A stray method call appears before a Javadoc comment that does not match the call. The method signature is split across lines without a body or interface context. Lack of surrounding code, inconsistent spacing and missing braces reduce readability significantly","tokens":486,"name":"126.jsnp"}
{"score":"65","reasoning":"The code follows a linear Selenium test flow but uses long XPath strings, repeated wait calls and magic numbers which reduce clarity. Lack of comments and descriptive variable names makes it harder to follow, though the sequence of actions is evident. Overall readability is moderate.","tokens":1073,"name":"198.jsnp"}
{"score":"78","reasoning":"The snippet is a set of JUnit test methods that are well named and follow a consistent style. Indentation and spacing make the flow easy to follow, and the use of helper methods keeps the code concise. Some lines are long and the surrounding class context is missing, which slightly reduces clarity","tokens":922,"name":"204.jsnp"}
{"score":"70","reasoning":"The code is fairly readable with descriptive variable names and clear API usage, but the long method call with many parameters reduces clarity and could benefit from line breaks or a builder pattern. Overall comprehension is moderate for developers familiar with the framework","tokens":669,"name":"135.jsnp"}
{"score":"85","reasoning":"The code is concise and self‑explanatory. Constructor clearly assigns parameters and calls super with a descriptive name. Method execute captures old value then updates it, using meaningful variable names. No complex logic, but lack of comments and minimal error handling keep it from a perfect score.","tokens":554,"name":"104.jsnp"}
{"score":"55","reasoning":"The code follows a repetitive Selenium pattern but mixes control flow with label jumps and continue statements making the logic hard to follow. Variable names are clear but the long XPath strings and repeated load calls reduce readability. Overall comprehension requires careful tracing, so the readability is moderate","tokens":1048,"name":"152.jsnp"}
{"score":"78","reasoning":"The code is clear and follows a simple pattern of copying properties via getters and setters, making its purpose easy to grasp. The compareTo method is straightforward, comparing names. However the repetitive setter calls could be condensed, and lack of comments reduces context, preventing a higher score.","tokens":753,"name":"183.jsnp"}
{"score":"70","reasoning":"The code follows a clear linear flow of Selenium actions with consistent indentation, making the sequence of clicks and waits easy to follow. Variable names are descriptive enough, though the use of a generic label variable and repeated load calls add some noise. Overall readability is good but not exceptional, earning a solid mid range score","tokens":855,"name":"157.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions, uses descriptive class and method names, and clear Selenium actions. Indentation and spacing aid readability. However the snippet is incomplete, lacks closing braces, and error handling is minimal, which slightly reduces comprehension","tokens":728,"name":"209.jsnp"}
{"score":"85","reasoning":"The code is concise and follows standard Java conventions with clear class and method names, proper indentation, and a brief author comment. The purpose of the suite method is evident, and the added tests are named descriptively. Minor issues include the incomplete snippet and missing closing braces, but overall readability is high","tokens":493,"name":"207.jsnp"}
{"score":"68","reasoning":"The test follows a clear sequence: open page, wait for link, click, verify element absence, and repeat. Variable names are descriptive and the Selenium API usage is standard. However readability suffers from duplicated wait loops, magic timeout values, and Thread.sleep calls. Lack of comments and excessive boilerplate reduce clarity, limiting ease of comprehension.","tokens":1008,"name":"145.jsnp"}
{"score":"78","reasoning":"The code follows standard Java bean conventions with clear naming and Javadoc comments which aid comprehension. Fully qualified type names are verbose but explicit. Repetitive getter and setter patterns are easy to follow. Missing declaration of archiveFiles in the snippet creates slight ambiguity, lowering the score modestly.","tokens":1036,"name":"188.jsnp"}
{"score":"78","reasoning":"The snippet is well‑indented and uses descriptive method names that make its purpose clear. The test methods follow standard JUnit patterns, checking normal and error cases. However, missing context for classUnderTest and the surrounding method reduce self‑containment, and the exception handling comments could be clearer. Overall readability is good but not perfect.","tokens":644,"name":"178.jsnp"}
{"score":"55","reasoning":"The code uses clear variable names but suffers from inconsistent formatting, redundant if‑else blocks and a stray brace that makes the flow hard to follow. Repeated calls to addStringArrays could be combined, and the continue block is confusing. Overall readability is moderate, not great.","tokens":815,"name":"187.jsnp"}
{"score":"85","reasoning":"The class is short and uses clear naming for constants, follows standard Java conventions and includes author tags. The code is easy to read but provides minimal context or documentation beyond the names, which limits deeper understanding","tokens":578,"name":"189.jsnp"}
{"score":"78","reasoning":"The snippet uses consistent indentation and Javadoc blocks which aid comprehension. Parameter names are descriptive and overloads are clear. However there are duplicate method signatures, mixed naming conventions and an inline comment inside a signature that slightly hampers readability. Overall readability is good but not excellent.","tokens":932,"name":"201.jsnp"}
{"score":"78","reasoning":"The code is fairly clear variable names are descriptive and the logic follows a simple visibility check then a loop with timeout However the use of magic numbers and empty catch block reduce readability Overall readability is good but not excellent","tokens":738,"name":"217.jsnp"}
{"score":"80","reasoning":"The code is well structured with clear imports, a descriptive test method, and meaningful variable names. The flow of setting up a recurrence and checking before, during, and after cases is easy to follow. Minor issues are missing context for constants and lack of comments, but overall readability is high","tokens":854,"name":"159.jsnp"}
{"score":"70","reasoning":"The code uses clear naming and logical structure but contains long nested blocks, empty catch blocks and some redundant checks that reduce readability. Adding comments, simplifying conditionals and handling exceptions explicitly would improve comprehension","tokens":875,"name":"180.jsnp"}
{"score":"70","reasoning":"The snippet is short and well indented with clear variable names. The synchronized block and conditional logic are easy to follow. However the surrounding context is missing and the purpose of the cache key is not explained, which slightly reduces overall clarity","tokens":632,"name":"156.jsnp"}
{"score":"85","reasoning":"The snippet includes a comprehensive header comment that explains the purpose, author, and licensing, which greatly aids comprehension, and it contains only two clear import statements. Although there is no functional code to evaluate, the documentation is well organized and the imports are straightforward, resulting in high readability","tokens":911,"name":"190.jsnp"}
{"score":"65","reasoning":"The snippet is a Java Selenium test that uses clear method names and assertions but suffers from poor formatting and magic numbers. The infinite for loop with a manual timeout, empty catch block and long XPath strings reduce readability. Overall it is moderately understandable but could be cleaner.","tokens":823,"name":"215.jsnp"}
{"score":"70","reasoning":"The snippet is fairly readable with clear variable names and standard try‑catch‑finally structure. Indentation is consistent and the logic flow is easy to follow. However the conditional handling of orderByComparator and the extra Collections.sort call can be confusing, and the cast syntax is verbose. Overall comprehension is moderate but not exceptional.","tokens":778,"name":"202.jsnp"}
{"score":"85","reasoning":"The code consists of a clear sequence of setter calls that map values from existing objects and parameters to a new layoutRevision. Naming is consistent and the conditional block for icon handling is simple. The layout is well spaced and easy to follow, though the length could be reduced with a builder or helper. Overall readability is high","tokens":883,"name":"148.jsnp"}
{"score":"80","reasoning":"The snippet defines a clear Java test suite class with a descriptive name, uses standard JUnit TestSuite pattern, and adds well named test classes. Naming and structure are easy to follow. However the snippet omits imports, closing braces and package declaration, which slightly hampers completeness but does not affect core readability","tokens":728,"name":"199.jsnp"}
{"score":"70","reasoning":"The snippet is a typical Selenium test written in Java. Variable names are clear and assertions are straightforward. Indentation is consistent but long chained calls and magic numbers like 30000 and 90 reduce clarity. The empty catch block and use of RuntimeVariables replace add minor noise, but overall the flow is easy to follow.","tokens":1185,"name":"107.jsnp"}
{"score":"70","reasoning":"The snippet shows three simple Java method signatures, which are easy to understand in terms of purpose. However the unconventional line breaks between return type and method name disrupt the visual flow and make it slightly harder to read. The use of semicolons is correct for an interface, but overall formatting could be improved for clarity, leading to a moderate readability score.","tokens":502,"name":"158.jsnp"}
{"score":"70","reasoning":"The code uses descriptive method names and brief comments which help understanding. However formatting is inconsistent with extra line breaks and irregular indentation, making the flow harder to follow. Regex patterns are long and not explained, and error handling is minimal. Overall readability is moderate","tokens":968,"name":"177.jsnp"}
{"score":"55","reasoning":"The snippet uses clear Selenium calls but readability suffers from missing comments, magic numbers, and an infinite loop with manual timeout. Variable names are adequate but error handling is empty and indentation is uneven. Overall it is moderately understandable but could be cleaner","tokens":784,"name":"220.jsnp"}
{"score":"80","reasoning":"The snippet is well‑structured with a clear license header, package declaration and concise Javadoc. Naming follows Java conventions and the purpose is explained. However the interface is empty, offering no functional content to assess, which limits depth of comprehension. Overall readability is good but limited by lack of implementation.","tokens":658,"name":"160.jsnp"}
{"score":"70","reasoning":"The code is short and uses clear Selenium calls with proper indentation, making the actions easy to follow. Variable names are descriptive and the boolean check is straightforward. However the use of a label for control flow is unconventional in Java and the Unicode arrow in the string adds minor confusion, lowering overall readability.","tokens":727,"name":"149.jsnp"}
{"score":"40","reasoning":"The snippet is short but confusing. The try block checks visibility and uses break, implying it is inside a loop that is not shown. The empty catch hides errors, and the sleep after the block adds unclear timing logic. Variable names are clear but lack comments, making overall comprehension difficult","tokens":544,"name":"105.jsnp"}
{"score":"88","reasoning":"The code is straightforward and easy to understand. Method names clearly describe their purpose and parameters are well‑named. Consistent indentation and spacing improve readability. Using fully qualified class names adds verbosity but does not hinder comprehension. No complex logic is present, making the snippet highly maintainable.","tokens":512,"name":"214.jsnp"}
{"score":"70","reasoning":"The code follows standard Java conventions with clear method names and consistent indentation. Exception handling is explicit but uses multiple instanceof checks which can be verbose. Variable names are descriptive and the flow is straightforward, making it fairly easy to understand for a Java developer","tokens":849,"name":"111.jsnp"}
{"score":"85","reasoning":"The code is well structured with clear JavaDoc comments for each method, making intent obvious. Method names and parameters follow standard conventions, aiding comprehension. Minor issues include a typo in a comment, inconsistent indentation, and occasional spacing irregularities, but these do not significantly hinder readability. Overall the interface is easy to understand.","tokens":806,"name":"184.jsnp"}
{"score":"45","reasoning":"The snippet shows a series of listener management methods but suffers from inconsistent formatting, missing class context, and many empty bodies or placeholder calls, making it harder to read despite simple intent","tokens":680,"name":"138.jsnp"}
{"score":"70","reasoning":"The snippet is short and uses clear naming for methods and variables. Static delegation and observer update pattern are recognizable. However the code lacks comments, context, and full class structure, making it harder to understand its purpose. Formatting is acceptable but minimal, and the partial nature reduces overall readability.","tokens":445,"name":"132.jsnp"}
{"score":"85","reasoning":"The code is short and uses clear variable names but string concatenation in a loop is inefficient and the logic could be expressed more directly Indentation is inconsistent and comments are present but not formatted as proper Javadoc Overall readability is decent for experienced developers but could be improved","tokens":783,"name":"115.jsnp"}
{"score":"55","reasoning":"The code uses clear control structures but relies on infinite loops with manual timeout checks, magic numbers and long XPath strings that reduce readability. Empty catch blocks hide errors and there are no comments explaining intent. Variable names are generic and the repeated pattern could be abstracted, making comprehension moderate","tokens":746,"name":"113.jsnp"}
{"score":"78","reasoning":"The snippet presents three Java method signatures with clear naming and simple formatting. Javadoc explains the first two methods, though the phrase \u0027class p k\u0027 is oddly spaced and there is no comment for isNew, which slightly reduces clarity. Overall the code is straightforward and easy to comprehend despite minor documentation quirks.","tokens":562,"name":"141.jsnp"}
{"score":"78","reasoning":"The code is well formatted with clear naming, generic types and straightforward logic. The use of descriptive variables and method names aids comprehension. However the snippet ends abruptly, missing the closing of the second method and class, which hampers full understanding. Overall readability is good but not perfect.","tokens":811,"name":"119.jsnp"}
{"score":"55","reasoning":"The code mixes several nested if‑else blocks with inconsistent indentation and unclear spacing. Use of magic character \u0027 \u0027 for no quote and combined conditions without parentheses makes the logic hard to follow. Variable names are short but meaningful. Overall readability is moderate but could be improved with clearer structure and comments.","tokens":690,"name":"164.jsnp"}
{"score":"85","reasoning":"The code is concise and self explanatory. The constructor clearly copies an existing packet by delegating to the superclass. The method name indicates its purpose and returns a constant that matches the ICMP header size. Naming follows Java conventions and there are no complex constructs, making it easy to read.","tokens":444,"name":"213.jsnp"}
{"score":"70","reasoning":"The code follows standard Java naming and structure, uses clear method names and indentation, making it easy to follow. However the loop uses a magic timeout value, lacks comments, and the snippet is incomplete, which slightly reduces clarity. Overall readability is good but not exceptional.","tokens":827,"name":"203.jsnp"}
{"score":"78","reasoning":"The code is clear and follows a simple pattern of null checking before assigning timestamps, making the intent easy to follow. Variable names are descriptive and the flow is linear. Minor repetition could be reduced with helper methods or ternary operators, but overall readability is good","tokens":718,"name":"142.jsnp"}
{"score":"45","reasoning":"The snippet is short but lacks context and proper formatting. The abstract method signature is clear, but the surrounding braces and indentation are inconsistent. The toString implementation uses an undefined variable \u0027string\u0027 and creates a new String unnecessarily, which reduces clarity. Absence of comments or documentation further hampers understanding, leading to a moderate readability score.","tokens":465,"name":"169.jsnp"}
{"score":"70","reasoning":"The snippet shows a clear Java test class extending a base case and uses Selenium to open a page and load scripts. Variable names are simple and the timeout loop is understandable. However the stray comment marker at the start and the incomplete code reduce clarity, and lack of comments makes intent less explicit, limiting readability.","tokens":525,"name":"114.jsnp"}
{"score":"30","reasoning":"The snippet shows fragmented Java method declarations with misplaced parentheses and line breaks, making it hard to follow. The Javadoc comment is present but the surrounding code lacks proper formatting and context, reducing clarity. Overall readability is low due to syntax errors and inconsistent style.","tokens":471,"name":"118.jsnp"}
{"score":"88","reasoning":"The code follows standard Java conventions with clear class and method names consistent indentation and simple logic Each method is short and self explanatory and the use of descriptive variable names aids comprehension Minor drawbacks are the hard coded method name string and limited documentation of parameters but overall readability is high","tokens":1002,"name":"125.jsnp"}
{"score":"55","reasoning":"The code follows a typical Selenium test pattern but uses long inline XPath strings, repeated wait loops with magic numbers and empty catch blocks which hurt clarity. Lack of comments and hard coded file paths also reduce readability. Overall it is moderately understandable but could be cleaner","tokens":986,"name":"173.jsnp"}
{"score":"90","reasoning":"The code is a straightforward Java setter with a clear Javadoc comment. Naming is descriptive, formatting follows standard conventions, and the method body is simple assignment. No complex logic or hidden behavior makes it easy to understand, resulting in a high readability score","tokens":488,"name":"161.jsnp"}
{"score":"88","reasoning":"The code is concise and well formatted with clear naming and a simple inheritance structure. The import statement and author comment provide context. The constructor is straightforward, calling the superclass constructor. Overall readability is high, though the snippet is very short and lacks additional documentation or comments that could improve understanding further","tokens":450,"name":"182.jsnp"}
{"score":"70","reasoning":"The code follows a consistent pattern and uses descriptive method names which aids comprehension. However the repetitive exception handling blocks add verbosity and reduce readability. The use of generated proxy and method handler adds some complexity for readers unfamiliar with the framework. Overall the snippet is moderately clear but could be simplified","tokens":782,"name":"165.jsnp"}
{"score":"45","reasoning":"The snippet follows a consistent indentation but relies heavily on long XPath strings and repeated Selenium calls which obscure intent. Variable names are absent, there are no comments, and the wait loops use magic numbers with empty catch blocks. These factors reduce readability and make the code harder to understand","tokens":994,"name":"194.jsnp"}
{"score":"85","reasoning":"The interface is well‑structured with clear, self‑descriptive method names and consistent formatting. Package and import statements are present, and a brief class comment explains purpose. No complex logic is involved, making it easy to understand. Minor improvements could include JavaDoc for each method, but overall readability is high.","tokens":761,"name":"200.jsnp"}
{"score":"45","reasoning":"The snippet mixes Selenium actions with control flow that uses a label variable and continue statements. Empty catch block hides errors and Thread.sleep makes timing fragile. XPath strings are hard coded and variable names are generic. Lack of comments further reduces clarity making readability moderate to low","tokens":813,"name":"121.jsnp"}
{"score":"78","reasoning":"The class is short and straightforward. Field names use a leading underscore which is unconventional but still clear. Methods are simple and self explanatory. Javadoc comments help understand purpose of getTitle and getHint. Lack of documentation for constructor and applyChanges is minor. Overall readability is good resulting in a score of 78","tokens":882,"name":"147.jsnp"}
{"score":"45","reasoning":"The fragment is short but hard to follow because it omits surrounding loop structure, uses an empty catch block that hides errors, and relies on a magic sleep value. Variable names are unclear and indentation is inconsistent, reducing overall readability and comprehension.","tokens":561,"name":"124.jsnp"}
{"score":"55","reasoning":"The code follows a simple pattern but lacks comments and uses repetitive wait loops with magic numbers. Empty catch blocks hide errors and Thread.sleep makes timing fragile. Variable names are clear but the structure is verbose and could be refactored for better readability","tokens":912,"name":"210.jsnp"}
{"score":"92","reasoning":"The code is highly readable with a clear, consistent pattern of adding test suites. Each line follows the same method call, making it easy to scan and understand. The class names are descriptive, indicating the purpose of each test. Minor improvements could include grouping related tests or adding comments, but overall the snippet is straightforward and well‑structured","tokens":554,"name":"155.jsnp"}
{"score":"85","reasoning":"The code is clear and well formatted with descriptive variable names and consistent indentation. The validation logic is straightforward and easy to follow. Minor issues include duplicated code that could be extracted into a helper method and lack of comments, but overall readability is high","tokens":666,"name":"206.jsnp"}
{"score":"80","reasoning":"The snippet contains a clear license header, a descriptive package name, and well‑named imports that follow standard Java conventions. The code is easy to scan and understand, though it lacks any functional implementation to assess deeper readability. Overall it is clean and straightforward, earning a solid readability rating.","tokens":693,"name":"134.jsnp"}
{"score":"85","reasoning":"The snippet follows standard Java naming conventions and includes clear Javadoc for each method. The layout is consistent with proper indentation and spacing, making it easy to read. The only drawback is the lack of surrounding class or interface declaration, which slightly reduces context, but overall the code is straightforward and self‑explanatory","tokens":598,"name":"130.jsnp"}
{"score":"70","reasoning":"The code uses clear class and method names and follows a common Selenium wait loop making it understandable however indentation is uneven and the snippet ends abruptly without closing braces which hurts readability","tokens":825,"name":"219.jsnp"}
{"score":"68","reasoning":"The code follows a simple procedural flow but readability suffers from repeated manual wait loops, lack of comments, and hardcoded strings. Variable names are clear but the nested trycatch without handling adds noise. Using explicit Selenium waits would improve clarity and reduce boilerplate.","tokens":1099,"name":"110.jsnp"}
{"score":"55","reasoning":"The snippet is short but lacks surrounding context, making the purpose of the break unclear. An empty catch block hides potential errors, and the stray closing brace suggests a syntax issue. Indentation is acceptable, but overall readability suffers due to missing loop structure and inadequate error handling.","tokens":637,"name":"218.jsnp"}
{"score":"70","reasoning":"The code follows standard Java conventions with clear naming and indentation, making it fairly easy to read. However the logger and string manager reference DeleteAliasAction instead of AliasAction, which can confuse readers, and there are minimal comments. Overall readability is good but not perfect.","tokens":863,"name":"137.jsnp"}
{"score":"30","reasoning":"The snippet shows several closing braces without context making it hard to follow the structure. The method name and parameter are clear but there is no documentation or comments. Indentation is inconsistent and the surrounding code is missing, reducing overall readability and comprehension.","tokens":428,"name":"117.jsnp"}
{"score":"78","reasoning":"The snippet is short and uses clear variable names and standard Swing layout calls which makes it easy to follow. The i18n comment hints at localization. Minor readability issues include inconsistent indentation and lack of surrounding context, but overall comprehension is high.","tokens":668,"name":"196.jsnp"}
{"score":"45","reasoning":"The code mixes control flow with a label variable and a switch, making the execution path hard to follow. Repeated selenium calls and magic numbers reduce clarity. Lack of comments and an empty catch block further hurt readability. Overall comprehension is moderate but could be improved with refactoring","tokens":952,"name":"205.jsnp"}
{"score":"45","reasoning":"The snippet shows inconsistent indentation and mismatched braces that make the control flow hard to follow. The empty catch block provides no context for error handling, and the purpose of the break is unclear without surrounding loop code. Lack of comments and minimal spacing further reduce readability, resulting in a moderate score.","tokens":499,"name":"143.jsnp"}
{"score":"75","reasoning":"The snippet is short and uses clear naming and standard Java conventions making it easy to read, but it lacks comments, documentation and any functional context which limits comprehension, so it receives a moderate to good readability score","tokens":515,"name":"128.jsnp"}
{"score":"65","reasoning":"The code follows a consistent pattern but uses very long fully qualified names, nested try catch blocks and reflection which adds noise. Variable names are clear and indentation is proper, however the repeated boilerplate reduces readability, making it moderately hard to follow for newcomers","tokens":915,"name":"162.jsnp"}
{"score":"70","reasoning":"The code is straightforward with repeated updatePortletPermissions calls that are easy to follow, but the repetition suggests a lack of abstraction which hurts maintainability. Indentation is clear and variable names are descriptive, yet the snippet could benefit from a loop or data-driven approach to reduce boilerplate and improve readability","tokens":817,"name":"127.jsnp"}
{"score":"80","reasoning":"The class is straightforward, with clear method names and simple delegation logic. Naming is consistent and the null check in setAuthToken is easy to follow. Missing field declarations and imports slightly reduce clarity, but overall the code is readable and easy to understand","tokens":730,"name":"139.jsnp"}
{"score":"70","reasoning":"The class is small and its purpose is clear, the getters and setters are straightforward and the hasError method is easy to follow. The naming follows a common convention and the license header is present. The only drawback is that the private fields are not shown in the snippet which slightly reduces readability","tokens":884,"name":"163.jsnp"}
{"score":"45","reasoning":"The snippet is short and uses clear naming and standard imports which aid readability, but it is incomplete and lacks context or method definitions, making comprehension difficult. The presence of annotations and interface extension hints at purpose but without implementation details the overall ease of understanding is limited.","tokens":486,"name":"179.jsnp"}
{"score":"70","reasoning":"The snippet is clear about method purposes and signatures but suffers from excessive fully qualified names and repeated annotations which hurt readability. Lack of comments or grouping makes it harder to scan. Consistent formatting helps, yet the verbosity and duplication lower overall comprehension ease.","tokens":939,"name":"144.jsnp"}
{"score":"78","reasoning":"The snippet is concise and uses clear naming conventions. The conditional check and return are straightforward, and the exception provides useful feedback. The getter method follows standard Java style. However, lack of surrounding context and minimal comments slightly reduce overall clarity, preventing a higher score.","tokens":481,"name":"109.jsnp"}
{"score":"70","reasoning":"The code is short and follows a simple flow, making the purpose clear. Variable names are descriptive and the sequence of creating a frame, panel and displaying it is easy to follow. Minor issues such as missing imports, inconsistent indentation and an unfinished class brace reduce readability slightly, preventing a higher score","tokens":790,"name":"123.jsnp"}
{"score":"30","reasoning":"The snippet is very short and lacks context, variable declarations and proper formatting. The identifier _2_announcementsTypetestEmailCheckbox is unclear, the magic number 6 and use of continue without loop context reduce readability. No comments are present. Overall it is hard to understand, resulting in a low score","tokens":592,"name":"129.jsnp"}
{"score":"85","reasoning":"The code follows standard JUnit naming conventions and uses clear method names. Variable names are descriptive and the sequence of calls is logical. Formatting is consistent with indentation and spacing. Minor issues include lack of comments and missing closing braces for the last method, but overall readability is high.","tokens":833,"name":"120.jsnp"}
{"score":"70","reasoning":"The code follows a logical structure and uses descriptive method names but contains a typo in a method name raw collection usage and some unconventional naming that slightly reduces clarity overall readability is moderate","tokens":997,"name":"211.jsnp"}
{"score":"70","reasoning":"The snippet consists of three Java method signatures with clear parameter types and return types. Formatting with line breaks aids readability, but lack of comments or documentation reduces context. The repeated throws Exception adds noise. Overall the code is moderately easy to understand but could be clearer with naming conventions and comments.","tokens":495,"name":"195.jsnp"}
{"score":"90","reasoning":"The code is well organized with clear class and method names, concise Javadoc comments, and straightforward logic. Variable names are descriptive and the flow is easy to follow. The only minor drawback is the use of a raw Enumeration type without generics, but this does not significantly hinder comprehension","tokens":829,"name":"122.jsnp"}
{"score":"70","reasoning":"The code follows standard Java getter pattern and uses clear method names making intent easy to follow However formatting is inconsistent the toString builds a long concatenated string with a magic limit there is a typo in class name and lack of comments reduces clarity Overall readability is moderate","tokens":813,"name":"108.jsnp"}
{"score":"85","reasoning":"The method is clearly structured with early null check, logical flow to obtain locale and value, and helpful debug logging. Variable names are descriptive and indentation is consistent. The unsupported methods are explicit, indicating they are not implemented. No complex constructs are used, making the code easy to read and understand.","tokens":759,"name":"154.jsnp"}
{"score":"85","reasoning":"The code is straightforward and uses clear variable names. The StringBundler block builds a readable toString representation in a consistent pattern. Null checks for name and primKey improve safety. The method toEntityModel maps fields directly to a new object, making the logic easy to follow. Minor verbosity prevents a perfect score.","tokens":899,"name":"197.jsnp"}
{"score":"78","reasoning":"The code is short and clear variable name puncher reflects its purpose null check is explicit and the final call is easy to follow minor issues are unnecessary parentheses and lack of comments but overall readability is good","tokens":704,"name":"185.jsnp"}
{"score":"78","reasoning":"The interface is short and well named with clear Javadoc comments. Method signatures are straightforward, but the raw Map return type lacks generics which hurts type safety and readability. No complex logic is present, making it easy to understand overall.","tokens":890,"name":"216.jsnp"}
{"score":"80","reasoning":"The code is concise and uses clear naming; the enhanced for loop and method calls are self‑explanatory, making it easy to follow the conversion from model objects to SOAP objects. Minor drawbacks are lack of comments and surrounding context, but overall readability is high.","tokens":470,"name":"171.jsnp"}
