{"score":"70","reasoning":"The test method is straightforward and uses descriptive variable names, making the intent clear. However the repeated getAuditReader().find calls and multiple assert blocks make it verbose and harder to scan. Refactoring into helper methods or loops would improve readability, so the code is moderately readable but not optimal","tokens":751,"name":"186.jsnp"}
{"score":"70","reasoning":"The method is straightforward and uses clear variable names, making the main flow easy to follow. However it contains repeated blocks for removing the person from the old address, which could be extracted to reduce duplication. Error handling is simple but the empty else branch for empty input is ambiguous. Overall readability is decent but could be improved with refactoring.","tokens":664,"name":"61.jsnp"}
{"score":"85","reasoning":"The code is concise and well‑structured, using clear method calls to register SQL functions. Naming is descriptive and consistent, aiding comprehension. Minor drawbacks include lack of inline comments explaining each function’s purpose and reliance on external context for the dialect class, which slightly reduces readability for newcomers.","tokens":619,"name":"21.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and documented, making its purpose obvious. Variable names are descriptive and the flow is logical with separate sections for different dialects. Use of assertions is straightforward. Minor issues include reliance on external classes not shown, but overall the code is easy to read and understand","tokens":785,"name":"57.jsnp"}
{"score":"85","reasoning":"The method is concise and follows a clear pattern of configuring a Hibernate Configuration object. Each property is set on a separate line, making it easy to read. The use of descriptive constant names improves understandability. Minor improvements could include brief comments or grouping related settings, but overall readability is high","tokens":602,"name":"191.jsnp"}
{"score":"65","reasoning":"The test method is fairly long with many nested if statements and long dialect checks that reduce readability, but naming is clear and assertions are straightforward; comments help but the dense conditionals and mixed formatting make it harder to follow, resulting in a moderate score","tokens":977,"name":"89.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical sections, but its length, repeated session handling and lack of comments make it harder to follow, and the use of raw map keys adds minor confusion. Overall readability is good but could be improved","tokens":910,"name":"192.jsnp"}
{"score":"70","reasoning":"The code is moderately readable but the nested anonymous Integrator with duplicated integrate methods adds visual clutter. Naming is clear and the private helper isolates listener registration, which helps comprehension. However the repeated overloads and deep indentation reduce clarity, preventing a higher score.","tokens":744,"name":"174.jsnp"}
{"score":"78","reasoning":"The test method is well structured with descriptive variable names and clear assertions. The use of iterators to verify ordering adds some complexity but is explained by a preceding comment. The annotation block is long but readable. Overall the code is easy to follow for someone familiar with the domain, yielding a high readability score","tokens":993,"name":"181.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and logical flow. Final variables and descriptive method calls improve readability. Inline comments explain purpose of blocks. External method implementations are hidden, adding some mental load, but overall the code is easy to follow and maintain.","tokens":902,"name":"170.jsnp"}
{"score":"70","reasoning":"The test method is clearly structured with a query executor and a result checker, and the assertions describe the expected behavior. However the heavy use of casts, nested parentheses and long lines make it harder to follow, and the anonymous inner classes add verbosity. Overall readability is moderate","tokens":938,"name":"98.jsnp"}
{"score":"78","reasoning":"The test method is short and uses a descriptive name that explains its purpose. The code follows a common pattern of opening a session, beginning a transaction, persisting an entity, flushing, rolling back and closing. Variable names are clear. Lack of comments and minimal error handling slightly reduce readability.","tokens":643,"name":"133.jsnp"}
{"score":"70","reasoning":"The method is short and uses descriptive names for variables and parameters. It performs clear null and empty checks and logs the filter application. However a long TODO comment, raw Iterator usage without generics, and magic string literals hurt readability. Overall comprehension is decent but could be improved","tokens":948,"name":"31.jsnp"}
{"score":"85","reasoning":"The test method is short and uses clear naming and standard JUnit structure which aids comprehension. However the long inline HQL query is hard to read and the catch block provides no detail, slightly lowering readability. Overall the code is fairly readable","tokens":701,"name":"81.jsnp"}
{"score":"78","reasoning":"The method name and parameters are descriptive and the branching clearly separates single and composite key handling. Helper methods keep the core logic concise, though their implementations are not shown, which may require extra lookup. Indentation and spacing are clean, making the flow easy to follow. Overall the code is readable with moderate complexity.","tokens":789,"name":"112.jsnp"}
{"score":"92","reasoning":"The method is short and self explanatory with clear Javadoc, descriptive names and a single constructor call. Formatting is clean and there is no complex logic, making it easy to read. Minor lack of validation does not affect readability","tokens":725,"name":"67.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear naming and consistent indentation making the flow easy to follow. It sets binding properties directly from the source, builds a meta attribute context and then calls a generic attribute binder. The duplicated conditional for custom persister class name adds slight confusion but does not obscure the overall logic","tokens":1036,"name":"146.jsnp"}
{"score":"55","reasoning":"The code follows a simple structure with a main method and a loop, but readability suffers from dense one‑liner statements, heavy use of System.arraycopy and bitwise operations that are not explained. Variable names are decent, yet the purpose of BytesHelper and Helper methods is unclear without context. Excessive printing and magic numbers reduce clarity, making comprehension moderate.","tokens":1179,"name":"58.jsnp"}
{"score":"65","reasoning":"The test method name is clear and the repeated assertNoLoss calls make the intent obvious. However the inline SQL strings are very long, contain many nested quotes and complex clauses, which reduces readability and makes the code hard to scan. Breaking the queries into named constants or separate methods would improve comprehension.","tokens":1208,"name":"101.jsnp"}
{"score":"78","reasoning":"The method name and parameters are descriptive, and the logic follows a clear pattern of checking the source, property name, and event type. Variable names are meaningful and the use of Model.getFacade() abstracts details. However the nested if statements and long line breaks reduce readability slightly, and the reliance on external classes without context adds some cognitive load.","tokens":608,"name":"47.jsnp"}
{"score":"78","reasoning":"The method has a clear purpose and uses descriptive variable names which aid comprehension. It follows a logical flow with early annotation checks and conditional handling. However the ternary operators and nested method calls add some cognitive load, and line length could be reduced for better readability. Overall it is moderately easy to understand.","tokens":775,"name":"28.jsnp"}
{"score":"85","reasoning":"The test method has a descriptive name and clear variable naming. Property settings are grouped logically and assertions verify expected configuration. Indentation and spacing are consistent making the flow easy to follow. The long property strings and unexplained numeric literals slightly reduce readability.","tokens":1188,"name":"131.jsnp"}
{"score":"78","reasoning":"The test is clearly structured with annotations, a session lifecycle, and a concise inner Work implementation. Variable names are meaningful and exception handling is straightforward. However the heavy casting and long method chains reduce readability slightly, preventing a higher score.","tokens":882,"name":"93.jsnp"}
{"score":"35","reasoning":"The method combines null and identity checks with a single return line that contains several nested ternary operators and mixed logical operators. The long expression is difficult to read, brackets are confusing and indentation is lacking. Breaking the logic into separate statements or helper methods would greatly improve clarity","tokens":664,"name":"36.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear variable names and straightforward control flow. It handles buffered reading and fallback to the parent reader cleanly, and the optional buffering logic is easy to follow. Minor improvements could be added for null safety comments, but overall readability is high.","tokens":880,"name":"151.jsnp"}
{"score":"78","reasoning":"The constructor is straightforward, each register call is on its own line and uses descriptive method names. Consistent indentation and naming aid readability. The use of placeholder syntax ($l,$p,$s) is not explained, which may confuse readers. Overall the code is easy to follow but could use comments for the placeholders","tokens":863,"name":"20.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and helpful comments that explain the optimistic locking handling and SQL generation. The flow is logical, but nested conditionals and several intermediate variables add some complexity, preventing a higher score","tokens":919,"name":"106.jsnp"}
{"score":"78","reasoning":"The method is concise and clearly creates a thread that runs the test and guarantees cleanup in a finally block. The use of an anonymous inner class and overridden run method is standard Java practice and easy to follow for experienced developers, though the extra verbosity may be a minor obstacle for beginners. Overall the code is readable and its purpose is evident","tokens":693,"name":"73.jsnp"}
{"score":"70","reasoning":"The test is concise and follows a clear sequence of fetching entities and revisions then checking expected sets. However the variable names (ed1_id, ing2_id) are not self‑explanatory and the use of raw assert statements instead of descriptive JUnit assertions reduces readability. Overall the code is moderately easy to understand.","tokens":878,"name":"166.jsnp"}
{"score":"70","reasoning":"The method is moderately readable with clear naming and straightforward logic, but nested loops and deep casting reduce clarity. Use of instanceof and multiple assignments adds cognitive load. Comments are minimal and a commented out line is present. Overall comprehension is decent but could be improved with refactoring.","tokens":795,"name":"50.jsnp"}
{"score":"80","reasoning":"The method is concise and follows a common pattern for equals implementations. Early returns improve clarity and the use of instanceof guards against wrong types. The ternary checks for null handling are correct but slightly verbose; using Objects.equals would be clearer. Overall readability is good but could be simplified.","tokens":496,"name":"60.jsnp"}
{"score":"80","reasoning":"The method is short and clear with a null check followed by a try to close the reader. Variable names are simple and the flow is easy to follow. The empty catch block for IOException may hide errors and slightly reduces readability, but overall the code is understandable.","tokens":668,"name":"150.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive names and a simple conditional structure. Calls to helper methods are straightforward, and the logic is easy to follow. Minor verbosity in method arguments prevents a perfect score but overall readability is high","tokens":792,"name":"103.jsnp"}
{"score":"65","reasoning":"The test method is moderately readable but suffers from excessive casting redundant parentheses and long anonymous class definitions that make the flow harder to follow. Naming is clear and assertions are straightforward yet the formatting and nesting reduce overall clarity","tokens":893,"name":"96.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming and indentation. It uses straightforward conditional checks and delegates to helper methods, making the logic easy to follow. Minor improvements could include reducing nesting by early returns, but overall readability is high.","tokens":544,"name":"193.jsnp"}
{"score":"45","reasoning":"The test method is long and contains many casts, nested conditionals and repeated listener checks which make the flow hard to follow. Variable names are descriptive but the mixture of collection handling, entity loading and listener verification adds complexity. Overall readability is moderate to low resulting in a mid range score","tokens":1229,"name":"140.jsnp"}
{"score":"80","reasoning":"The method is short and uses clear variable names. The arrays xs and ys list the rectangle edge midpoints in a logical order. The call to Geometry.ptClosestTo is self explanatory. The only minor issue is the hard coded length 5 instead of using xs.length, but overall the code is easy to read","tokens":771,"name":"153.jsnp"}
{"score":"70","reasoning":"The method is lengthy and nests three anonymous classes, uses raw List and Map types and many casts which reduce clarity, but the variable names and the step by step construction of criteria and HQL query are clear, so overall readability is moderate","tokens":1128,"name":"99.jsnp"}
{"score":"85","reasoning":"The method includes a clear Javadoc, follows the conventional equals pattern, and uses simple if statements with descriptive checks. Naming and indentation are consistent, making it easy to follow. The final return could be simplified since super.equals already guarantees equality, but the overall readability is high.","tokens":759,"name":"39.jsnp"}
{"score":"85","reasoning":"The test method name clearly describes its purpose and the annotations are standard. Variable names are meaningful and the query strings are formatted for readability despite being long. The assertion compares expected and actual SQL, making intent obvious. Minor issues are the heavy string concatenation and lack of line breaks in the expected SQL, which slightly reduces clarity.","tokens":659,"name":"23.jsnp"}
{"score":"85","reasoning":"The method is well‑documented with a clear JavaDoc, uses descriptive variable names and straightforward control flow. Logging and exception handling are explicit. Minor readability hits come from chained map lookups and iterator usage, but overall the code is easy to follow for experienced Java developers","tokens":870,"name":"102.jsnp"}
{"score":"70","reasoning":"The method is well indented and uses clear control flow with try‑finally and barrier synchronization. Logging statements are descriptive and variable names are meaningful. However the large commented‑out block and undefined helper methods (title, opsPerMS) reduce clarity, and the mix of trace and info logs can be confusing, lowering the overall readability","tokens":886,"name":"172.jsnp"}
{"score":"78","reasoning":"The test is short and uses clear variable names. The sequence of property puts is easy to follow but the duplicate password entry and the magic string keys reduce clarity. The assertions are simple and convey expected outcome. Overall readability is good but could be improved with comments or constants.","tokens":808,"name":"35.jsnp"}
{"score":"85","reasoning":"The code is well‑structured and follows standard Java equals implementation patterns. Clear early returns improve readability, and the Javadoc comment explains purpose and behavior. Variable names are descriptive. Minor redundancy in separate minute and hour checks could be combined, but overall it is easy to understand.","tokens":610,"name":"42.jsnp"}
{"score":"40","reasoning":"The method mixes logging, collection handling and UI updates without clear separation. It uses raw Vector and Enumeration instead of generics, has inconsistent indentation, unclear variable names like path and tde, and repeated calls to Designer.theDesigner(). The logic is hard to follow and lacks comments, reducing readability","tokens":879,"name":"46.jsnp"}
{"score":"78","reasoning":"The constructor is clear and self‑explanatory, each registerFunction call is on its own line with descriptive names and appropriate type arguments. The repetitive pattern aids scanning, though the long list could benefit from grouping or comments for related functions. Overall the code is readable and easy to follow for a Java developer","tokens":917,"name":"18.jsnp"}
{"score":"78","reasoning":"The test method is clearly structured with descriptive variable names and a straightforward loop that searches for a specific MBean. Assertions are grouped logically and the code uses standard JUnit and JMX APIs, making intent easy to follow. Minor drawbacks are magic numbers and a split method call that slightly reduce clarity, but overall readability is high.","tokens":1299,"name":"90.jsnp"}
{"score":"45","reasoning":"The method is long and mixes session handling, dialect checks, many HQL queries and assertions without explanatory comments. Nested joins, index usage and string literals make the flow hard to follow, and variable names provide little context. Consistent formatting helps slightly but overall readability is low, resulting in a moderate score.","tokens":1274,"name":"68.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear naming and standard JUnit annotations. Transaction boundaries are explicit and the entity creation is straightforward. However the code lacks error handling, the comment is unnecessary, and the variable country is not declared locally which may confuse readers. Overall readability is good but not perfect.","tokens":731,"name":"168.jsnp"}
{"score":"30","reasoning":"The method mixes framework calls with low level JDBC in a single anonymous class, uses deep casting and long chained calls, has no comments, ignores exceptions and embeds raw SQL strings. The naming is minimal and the flow is hard to follow, reducing readability significantly.","tokens":868,"name":"100.jsnp"}
{"score":"70","reasoning":"The method is short and clearly named and the logic is straightforward, but it mixes tabs and spaces, uses raw Iterator without generics and concatenates strings for logging which reduces clarity. Adding generics, consistent formatting and more comments would improve readability.","tokens":908,"name":"7.jsnp"}
{"score":"68","reasoning":"The method is fairly straightforward with descriptive names for reader writer and parse state stack. Indentation is clear and the logic flow is easy to follow. However the use of raw Stack reduces type safety, a commented out cast adds confusion, and the lack of generics and minimal error handling lower readability. Overall moderate clarity.","tokens":897,"name":"116.jsnp"}
{"score":"78","reasoning":"The method uses clear naming and consistent indentation, making the flow easy to follow. Nested conditionals are straightforward but could be simplified with early returns. The single inline comment is helpful but the code mixes several responsibilities, slightly reducing clarity. Overall readability is good but not exceptional.","tokens":861,"name":"198.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear annotations, descriptive variable names and straightforward assertions. Comments explain the purpose. Minor issues are inconsistent indentation and raw string concatenation for SQL which slightly reduces clarity, but overall the code is easy to follow.","tokens":1027,"name":"136.jsnp"}
{"score":"68","reasoning":"The code uses clear naming and straightforward structure but includes nested anonymous classes and method overrides which increase cognitive load. Indentation is consistent and variable names are descriptive, yet lack of comments and the use of inline overrides make it moderately difficult for beginners to follow quickly","tokens":628,"name":"12.jsnp"}
{"score":"85","reasoning":"The method is concise and uses a fluent StringBuilder chain that is easy to follow. Variable names are clear and the null check for region is explicitly documented. Indentation and line breaks aid readability. Minor issues are the inline comment style and lack of an else branch, but overall the code is straightforward","tokens":778,"name":"64.jsnp"}
{"score":"55","reasoning":"The method is short but its purpose is unclear because it always returns null and does not use the entityType parameter. The null check and proxy reassociation are straightforward, but the presence of unused parameters and lack of error handling reduce readability. Overall the code is moderately readable but confusing, resulting in a score of 55","tokens":867,"name":"65.jsnp"}
{"score":"55","reasoning":"The method is short but suffers from deep nested if‑else blocks, inconsistent indentation and repeated setSelected calls. Variable names are generic and the logic could be flattened with early returns or a switch, making it harder to follow quickly","tokens":733,"name":"157.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear variable names and logical grouping of assertions. It uses standard JUnit patterns and reflection clearly. However the dense series of assertions without comments makes it slightly hard to follow at a glance, reducing readability modestly.","tokens":1155,"name":"135.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical sequence of steps. It obtains a reader, checks for the presence of a specific annotation, verifies the absence of many others, and validates annotation properties. The code is well formatted and self‑explanatory, though the long list of assertions adds some verbosity but does not hinder comprehension","tokens":758,"name":"176.jsnp"}
{"score":"85","reasoning":"The test method is clearly structured with descriptive variable names and consistent formatting. Each case follows the same pattern making it easy to follow. However the repeated code could be extracted into a helper to reduce duplication, which would improve maintainability. Overall the snippet is highly readable and understandable.","tokens":822,"name":"26.jsnp"}
{"score":"78","reasoning":"The method is well‑structured with clear naming, consistent indentation and helpful logging. Use of final variables improves readability and the error messages are descriptive. Nested conditionals are a bit deep, and early returns could simplify flow, but overall the code is easy to follow for someone familiar with the domain.","tokens":720,"name":"183.jsnp"}
{"score":"85","reasoning":"The method is clearly structured with early validation, descriptive variable names, and a straightforward switch handling each XML event type. Use of StringBuilder and final variables improves clarity. Minor issues include a loop that relies on end‑document detection which may be less obvious, but overall the code is easy to follow.","tokens":1112,"name":"152.jsnp"}
{"score":"78","reasoning":"The test method is well-structured with clear setup, execution, and cleanup phases. Annotations and descriptive method name convey purpose, and the inline comments explain the complex bidirectional mapping scenario. However the very long method name and extensive comment blocks add visual clutter, slightly reducing readability","tokens":957,"name":"175.jsnp"}
{"score":"70","reasoning":"The method is concise and uses a clear naming convention for test cases. Each parse call is on a separate line which aids readability, though the long query strings reduce clarity. The commented out examples are helpful for context but add visual clutter. Overall the structure is simple but the dense strings make quick comprehension harder","tokens":824,"name":"85.jsnp"}
{"score":"75","reasoning":"The method is concise and uses clear variable names, making the main logic easy to follow. Formatting and indentation are good. However the presence of commented out code adds visual noise, and the nested if could be flattened for clarity. Lack of documentation and no explicit null check for the event object slightly reduce readability.","tokens":605,"name":"11.jsnp"}
{"score":"78","reasoning":"The method is straightforward, uses descriptive names and clear JPA transaction blocks. Repeated find and transaction code reduces readability, and comments are helpful but could be formatted better. Overall the snippet is easy to follow but could be more concise. Score 78","tokens":998,"name":"188.jsnp"}
{"score":"78","reasoning":"The method is concise and follows common JUnit and Hibernate patterns. Annotations, variable names and the query are clear. The pagination parameters are hard‑coded which slightly reduces clarity, and there is a leftover commented print line. Overall the code is easy to read and understand.","tokens":786,"name":"92.jsnp"}
{"score":"70","reasoning":"The test method is short and uses descriptive names which aids comprehension. The use of a try catch finally pattern is clear. However the long chained calls to obtain the prepared statement make the code harder to read and the lack of comments forces the reader to infer intent. Overall readability is moderate","tokens":732,"name":"145.jsnp"}
{"score":"70","reasoning":"The method name is descriptive and the flow is simple with a validation call followed by object construction However the use of a raw Map type many constructor arguments without named parameters and a TODO comment reduce clarity Overall readability is moderate","tokens":747,"name":"55.jsnp"}
{"score":"90","reasoning":"The method is well documented with Javadoc, uses descriptive names, clear control flow, and simple logic. Formatting and spacing aid readability. Minor improvement could be adding inline comments for complex steps, but overall easy to understand.","tokens":796,"name":"126.jsnp"}
{"score":"78","reasoning":"The method is short and well structured with clear variable names. Consistent indentation and logical grouping of addNotationProvider calls make the flow easy to follow. The commented out line adds minor noise but does not obscure meaning. Overall the code is readable and its purpose is evident.","tokens":752,"name":"5.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming and consistent indentation. Each conditional branch is self explanatory and the flow is easy to follow. The use of helper methods keeps the logic concise. Overall readability is high though the many else if statements add some length","tokens":1056,"name":"107.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear steps: setup entity, verify revisions, clear and modify map, query audit data and assert results. Variable names are descriptive but rely on external context. Use of raw List and casting reduces type safety. Long query chain is a bit dense but still understandable. Overall readability is good but not perfect.","tokens":1058,"name":"167.jsnp"}
{"score":"78","reasoning":"The test method is short and its name clearly describes the scenario being verified. It follows a simple sequence of helper calls that make the intent easy to follow. However the lack of inline documentation about the helper methods and the generic naming of some steps reduces clarity slightly, preventing a higher score.","tokens":692,"name":"187.jsnp"}
{"score":"78","reasoning":"The test method is well named and follows a clear structure: setup, annotation checks, extraction of AttributeOverrides and detailed verification of each Override. The repeated assert calls make it verbose but still understandable. Formatting and naming aid readability, though the long list of assertions could be grouped. Overall readability is good","tokens":1054,"name":"177.jsnp"}
{"score":"78","reasoning":"The test method is well named and uses clear assertions that show expected return and parameter types. The repeated pattern is easy to follow, but the lack of comments and the long chained calls make it slightly harder to scan. Overall the code is readable for someone familiar with the API.","tokens":895,"name":"88.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc header, the signature is simple and the body follows a consistent pattern. Each field is restored using the same utility call, making the intent obvious. The repetitive lines are easy to scan but add length. Overall the code is readable and easy to understand.","tokens":968,"name":"3.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names for class names, making its purpose easy to follow. The explicit calls to the listeners clearly show what actions are performed, but the repetition could be reduced with a loop. Overall the code is readable and self explanatory, earning a solid score","tokens":757,"name":"190.jsnp"}
{"score":"78","reasoning":"The method is fairly readable with clear variable names and straightforward logic. It checks parameter count, creates an instance, and injects fields using reflection. However, it uses generic Exception, long concatenated messages, and lacks comments, which slightly reduces clarity. Overall comprehension is good but could be improved with specific exception types and formatting.","tokens":732,"name":"13.jsnp"}
{"score":"78","reasoning":"The method is short and clearly named, parameters are descriptive and the logic follows a simple sequence: set the property, optionally update the snapshot, and return a comparison result. Variable names like lazyPropertyNumbers and lazyPropertyTypes are meaningful within context, but reliance on external fields may require additional knowledge. Overall readability is good but not exceptional","tokens":799,"name":"104.jsnp"}
{"score":"85","reasoning":"The code is well formatted and uses descriptive names for the test method, variables and assertions making it easy to follow. The use of JUnit annotations and clear separation of steps (setup, execution, verification) enhances readability. Minor drawbacks are reliance on external helper methods whose implementations are not shown, which could slightly hinder full comprehension.","tokens":547,"name":"159.jsnp"}
{"score":"78","reasoning":"The test method is straightforward and uses descriptive names for entities and variables which aids comprehension. However the use of raw collections, repeated session boilerplate, and lack of helper methods makes the code verbose. Adding generics, extracting session handling, and commenting intent would improve readability further","tokens":762,"name":"82.jsnp"}
{"score":"78","reasoning":"The method is well‑structured and uses descriptive variable names which aid comprehension. It follows a logical flow: call super, check annotation, collect indices, validate range, track usage, and report errors. However the nested if‑else blocks and long error messages make it slightly harder to read, and extracting validation logic could improve clarity.","tokens":730,"name":"14.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc header and uses descriptive variable names such as minimum, maximum, positive and negative. The logic is straightforward: iterate categories, sum positive and negative values, then compute range. Minor issues include nested loops that could be extracted and a redundant comment line, but overall the code is easy to follow","tokens":788,"name":"41.jsnp"}
{"score":"70","reasoning":"The test method is fairly clear in its intent, using descriptive variable names and standard Hibernate session handling. However indentation is inconsistent, comments are embedded in code, and error handling is missing, which reduces readability. The flow is linear but could be cleaner with helper methods","tokens":983,"name":"72.jsnp"}
{"score":"78","reasoning":"The method is straightforward and well indented making the flow easy to follow. The naming of each getter is descriptive which aids comprehension. However the use of a raw Object array with many null placeholders reduces clarity and could be replaced by a more expressive collection. The overall readability is good but not optimal","tokens":560,"name":"156.jsnp"}
{"score":"85","reasoning":"The test method is well structured with descriptive names and clear assertions. Variable names are meaningful and the flow follows a logical sequence from configuration to verification. Minor issues include slightly long lines and a mix of indentation styles, but overall the code is easy to read and understand","tokens":607,"name":"178.jsnp"}
{"score":"78","reasoning":"The test method is well structured and uses descriptive names making the intent clear. Assertions are straightforward and follow a logical order. However the method is long, contains repetitive iterator checks and many similar assertions which reduce brevity and increase visual clutter. Overall readability is good but could be improved with helper methods","tokens":1064,"name":"180.jsnp"}
{"score":"85","reasoning":"The constructor is short and calls well named registration methods making its purpose clear It follows standard Java style and uses descriptive names which aids readability The lack of inline comments or documentation about the registration details limits understanding slightly but overall the code is easy to follow","tokens":663,"name":"19.jsnp"}
{"score":"70","reasoning":"The method has a clear JavaDoc and descriptive variable names which aid understanding. However the nested if‑else structure, casting from the hash map and repeated Configuration.makeKey calls add complexity. The logic is correct but could be refactored for better clarity, resulting in a moderate readability rating.","tokens":856,"name":"51.jsnp"}
{"score":"85","reasoning":"The method is clearly structured with annotations, descriptive variable names and sequential transaction blocks. Inline comments label each revision, making intent obvious. Repetitive transaction boilerplate could be refactored, but overall the flow is easy to follow.","tokens":939,"name":"189.jsnp"}
{"score":"70","reasoning":"The test method is fairly long with nested anonymous classes and many casts which reduces clarity. Variable names are clear and the flow of creating criteria and checking results is logical, but excessive parentheses and inline comments make it harder to read for newcomers","tokens":944,"name":"97.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and the variable names are meaningful. Explicit casts improve clarity but the long argument list to getSingularSubAttributes reduces readability slightly. Overall the code is well structured and easy to follow, earning a score of 78","tokens":735,"name":"148.jsnp"}
{"score":"70","reasoning":"The method is fairly clear with descriptive names and comments, but the empty for loops using compareAndSet are terse and may confuse readers, and the lock usage is explained only briefly. Overall readability is moderate leading to a score of 70","tokens":820,"name":"62.jsnp"}
{"score":"78","reasoning":"The method uses clear naming and early returns which aid readability. The logic is straightforward but involves several external calls and type casts that require knowledge of the surrounding framework, slightly reducing clarity. Indentation and formatting are good, but the mixture of strategy checks and instrumentation adds moderate complexity.","tokens":813,"name":"111.jsnp"}
{"score":"78","reasoning":"The code is well structured with clear method calls and descriptive variable names. The constructor builds the UI by adding localized fields, separators and actions. Minor issues are long lines and a typo in label keys but they do not hinder understanding. Overall readability is high","tokens":806,"name":"158.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive variable names for limit offset and input strings. The formatting with line breaks aids readability and the assertion is straightforward. Long concatenated SQL strings slightly hurt clarity but overall the code is easy to follow","tokens":796,"name":"24.jsnp"}
{"score":"70","reasoning":"The test method name is clear and the assertion is straightforward, but the long chained call with a cast and a fully qualified class name makes the code hard to read. Adding intermediate variables or helper methods would improve clarity. Overall readability is moderate.","tokens":782,"name":"199.jsnp"}
{"score":"70","reasoning":"The method name and helper calls are descriptive and the inline comment explains the purpose which aids readability However the method is long contains many sequential calls and a nested loop mixing several concerns making it harder to follow Splitting into smaller methods would improve clarity","tokens":1229,"name":"149.jsnp"}
{"score":"70","reasoning":"The method is short and performs a single loop, but the long parameter list and repeated array indexing reduce readability. Names are descriptive, yet using local variables or a structure would clarify intent. Overall readability is moderate.","tokens":656,"name":"105.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names and a standard prime multiplier. The flow is easy to follow with null checks before calling hashCode. However the order of operations (adding before multiplying) is unconventional and could be confusing. Minor formatting issues reduce readability slightly.","tokens":462,"name":"141.jsnp"}
{"score":"65","reasoning":"The method is clear in purpose and follows a simple flow but uses raw Vector and unchecked casts which reduce type safety. The repeated if statements for each model type make the code verbose and harder to maintain. Lack of comments and opportunity for refactoring into a map or polymorphic dispatch lower readability. Overall comprehension is moderate","tokens":861,"name":"119.jsnp"}
{"score":"80","reasoning":"The method is clear and concise, using a HashSet to collect string constants and returning an unmodifiable view. Variable naming is appropriate and the sequence of adds is easy to follow. However it could be simplified with Set.of in newer Java versions, and the explicit generic type on HashSet is redundant, slightly lowering the score.","tokens":581,"name":"16.jsnp"}
{"score":"85","reasoning":"The method is short and self explanatory with a clear doc comment. Variable names are meaningful and the logic uses straightforward if statements to detect line endings. Indentation is consistent and the return values are obvious. Minor improvements could be using else if or a switch but overall readability is high","tokens":681,"name":"6.jsnp"}
{"score":"70","reasoning":"The method is clearly documented and uses straightforward variable names, but the series of manual shift operations is verbose and harder to follow than a loop or ByteBuffer approach. The repeated pattern is evident, yet the code could be more concise, which slightly lowers readability","tokens":750,"name":"113.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming and logical flow. Annotations are verbose but self explanatory, and the code uses straightforward object creation, persistence, and assertions. Minor issues are the dense annotation list and a console print, but overall readability is high","tokens":983,"name":"138.jsnp"}
{"score":"65","reasoning":"The method is moderately readable but suffers from raw types, long lines, nested ternary operators and unclear variable names. The control flow is straightforward, yet the lack of generics, excessive inline logic and ambiguous suffix handling reduce clarity, making maintenance harder","tokens":939,"name":"34.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment, uses descriptive variable names and standard Java listener pattern. Indentation and spacing make the flow easy to follow. The lazy creation of the event is straightforward. Minor complexity comes from the reverse loop over the listener array, but it is a common idiom, so overall readability is high.","tokens":846,"name":"9.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and variable names are descriptive. The flow is simple with null checks and early returns. Minor readability issues are inconsistent indentation, a long string concatenation line, and generic array casting syntax that could be clearer. Overall the code is easy to follow.","tokens":811,"name":"125.jsnp"}
{"score":"55","reasoning":"The method is short but uses generated parser constructs like _tokenSet_6, LA(1) and a labeled loop which are not self‑explanatory. The name caseSList gives little context and extra braces add noise. Indentation is clear and the loop logic is simple, so readability is moderate but not high.","tokens":808,"name":"115.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming, inline comments, and straightforward logic. The inner Verifier class encapsulates the tree search, making the test assertions easy to read. Indentation and spacing are consistent, and the use of constants improves clarity. Minor issue is using Stack as a queue which may slightly confuse readers but does not hinder overall comprehension","tokens":932,"name":"87.jsnp"}
{"score":"78","reasoning":"The method is well named and documented, uses clear variable names and straightforward control flow. The try catch distinguishes specific cache exceptions and rethrows others, which aids understanding. Minor issues are extra else blocks and nested returns that could be simplified, but overall the code is easy to follow","tokens":789,"name":"164.jsnp"}
{"score":"55","reasoning":"The method contains many nested if statements and repeated casting logic which makes it hard to follow. The use of instanceof checks and range comparisons for event types adds verbosity. While indentation is clear, the overall structure could be simplified with polymorphism or a dispatch table. Readability is moderate but could be improved","tokens":872,"name":"43.jsnp"}
{"score":"70","reasoning":"The test method has a descriptive name and clear structure but contains unexplained helper calls and a silent catch block which reduces clarity. The use of thrown.expectMessage is straightforward, yet missing comments and context for TIMEOUT and helper methods makes it moderately readable.","tokens":896,"name":"160.jsnp"}
{"score":"90","reasoning":"The constructor is concise and well structured, using clear method calls to map SQL types to database types. Indentation and naming are consistent, making the purpose obvious. The only minor drawback is lack of inline comments explaining specific mappings, but overall readability is high","tokens":770,"name":"25.jsnp"}
{"score":"65","reasoning":"The method is short and uses clear variable names but repeats similar blocks for two tables, lacks comments, and has inconsistent indentation. Magic numbers and duplicate setTarget calls reduce clarity. The flow is straightforward but could be refactored for better readability","tokens":741,"name":"10.jsnp"}
{"score":"70","reasoning":"The method name and variable names are descriptive and the flow is logical, but the nested anonymous class, multiple boolean flags and try catch blocks add complexity, making it harder to follow at a glance. The use of assert and conditional lock release is clear, yet overall readability could be improved with a simpler structure","tokens":814,"name":"173.jsnp"}
{"score":"68","reasoning":"The method is fairly clear with descriptive names and consistent indentation, but the nested anonymous classes and overridden methods add complexity. Lack of comments and the inline conditional return make it harder for newcomers to follow. Overall readability is moderate, earning a score in the high sixties.","tokens":801,"name":"132.jsnp"}
{"score":"85","reasoning":"The method is concise and uses descriptive names for variables and parameters. Generic type handling and JAXB usage are clear. Formatting and spacing aid readability. Minor issues include lack of resource closing and no error handling comments, but overall the code is easy to follow","tokens":685,"name":"194.jsnp"}
{"score":"78","reasoning":"The method is well documented and uses clear naming for parameters and steps. Indentation and spacing aid readability. The logic is straightforward: obtain ResultSet, optionally wrap it, handle limit conditions, optionally discover types, and return. Error handling is concise. Slight complexity arises from chained calls and conditional limit handling but overall the code is easy to follow","tokens":873,"name":"33.jsnp"}
{"score":"78","reasoning":"The test method is well named and uses clear variable names. The sequence of building a load plan, asserting its structure, and printing the tree is logical and easy to follow. Long constructor arguments and lack of comments slightly reduce readability, but overall the code is concise and self explanatory","tokens":884,"name":"142.jsnp"}
{"score":"35","reasoning":"The method mixes primitive and object comparisons, uses a long chained \u0026\u0026 expression, includes commented out code, and has inconsistent spacing and redundant null checks. The lack of helper methods and poor formatting make the logic hard to follow, resulting in low readability and comprehension.","tokens":1173,"name":"74.jsnp"}
{"score":"80","reasoning":"The method is well structured with clear naming and logical flow. It handles file existence, user confirmation, stream setup, and cleanup in a try‑finally block. Indentation is consistent and the use of constants improves readability. Minor issues include a mixed tab/space indent and a long line in the dialog call, but overall it is easy to understand","tokens":595,"name":"49.jsnp"}
{"score":"78","reasoning":"The method is concise and uses descriptive names making the flow easy to follow. Helper calls clarify intent and the final closeIfRequired call is clear. The combined boolean for flush is a bit dense which slightly reduces readability, but overall the code is well organized and understandable.","tokens":839,"name":"184.jsnp"}
{"score":"78","reasoning":"The test method has a clear purpose and descriptive name, uses logical sections and asserts expected results. Variable names are meaningful and the flow is easy to follow. However the repeated query execution and filter enabling make the code verbose, and inline comments could be clearer. Minor refactoring would improve readability.","tokens":971,"name":"91.jsnp"}
{"score":"85","reasoning":"The method is concise and follows a common pattern for equals: identity check, type check, field‑by‑field comparison with early returns. Variable names are clear and the Javadoc explains the contract. No complex logic or nesting makes it easy to read, though using a utility or handling floating‑point tolerance could improve it","tokens":723,"name":"114.jsnp"}
{"score":"70","reasoning":"The method is fairly clear with descriptive names and straightforward control flow, but heavy use of reflection and multiple nested try‑catch blocks adds complexity. The whimsical header comment does not aid understanding. Lack of inline comments for the reflection logic reduces readability for less experienced readers, resulting in a moderate score.","tokens":796,"name":"2.jsnp"}
{"score":"78","reasoning":"The method has clear Javadoc, descriptive names and logical flow. Generic bounds are explicit and try‑finally blocks ensure proper handling. Nested try‑finally and comment about double iteration add slight complexity, but overall the code is easy to understand","tokens":935,"name":"110.jsnp"}
{"score":"55","reasoning":"The method is a straightforward series of doTest calls with different boolean arrays, but the repetition makes it hard to read and maintain. Using a loop or helper would improve clarity. Naming is clear but the long line length and lack of comments reduce readability.","tokens":882,"name":"59.jsnp"}
{"score":"65","reasoning":"The method is short and its intent is clear release a prepared statement if it exists. The null check and try catch are simple but the cast to SessionImplementor and chained calls make it less readable for those unfamiliar with the API. Ignoring all Throwables without comment reduces clarity and overall readability is moderate","tokens":701,"name":"95.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear loops, descriptive variable names and helpful comments that explain the JPA spec rationale. The logic is straightforward: check the Access annotation, determine the AccessType and move the property to the appropriate map or log a debug message. Minor formatting inconsistencies slightly reduce readability","tokens":1027,"name":"27.jsnp"}
{"score":"85","reasoning":"The test is well structured with clear variable names and loops, comments explain the purpose, and assertions are straightforward making it easy to follow. Minor issues include casting and hard coded numbers that could be extracted but overall readability is high","tokens":1077,"name":"56.jsnp"}
{"score":"70","reasoning":"The method is well commented and uses descriptive variable names which aid understanding However the code repeats the same loop logic twice instead of extracting a helper and uses raw Vector with casts which reduces clarity and modern style The overall readability is decent but could be improved resulting in a moderate score","tokens":996,"name":"121.jsnp"}
{"score":"85","reasoning":"The method follows the conventional equals pattern with clear null checks and field comparison. Indentation and naming are straightforward, making it easy to follow. Use of super.equals and class check adds safety. Minor improvement could be using Objects.equals for brevity, but readability is high.","tokens":677,"name":"169.jsnp"}
{"score":"70","reasoning":"The method name is descriptive and the logic is straightforward with clear null checks and simple assignments. However indentation is inconsistent, comments are sparse and a TODO indicates incomplete handling, and the use of reflection style checks reduces clarity. Overall readability is moderate","tokens":840,"name":"147.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical steps: open session, create entities, set properties, save, commit, query, delete and close. Suppressed warnings and a TODO note are minimal. However the inline comments and long query strings reduce clarity, and lack of explanation for each query makes it slightly harder for newcomers. Overall readability is good but not perfect","tokens":1089,"name":"80.jsnp"}
{"score":"78","reasoning":"The constructor is well structured with clear variable names and logical ordering of UI setup steps. Formatting is consistent and the code is easy to follow. Minor issues are repeated setAutoResizeMode call and lack of inline comments, but overall readability is good.","tokens":787,"name":"118.jsnp"}
{"score":"78","reasoning":"The test method is clearly organized with setup execution and cleanup sections. Variable names are descriptive and the try catch block handles the expected exception. The long chained calls to obtain the statement preparer reduce readability and the anonymous inner class adds verbosity but overall the code is fairly easy to follow","tokens":846,"name":"94.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical flow. Annotations and session handling are straightforward. The inner AbstractWork class adds some nesting but is simple. Minor readability issues include a long line for SQL construction and dialect specific checks, but overall it is easy to follow","tokens":858,"name":"69.jsnp"}
{"score":"85","reasoning":"The method name clearly indicates its purpose and the parameters are descriptive. Variable names are concise and meaningful, and the nested loops are straightforward. Helper methods like getSuperClasses, MethodSorter.getDeclaredMethods, getSortedDeclaredFields, and addToAnnotationLists make the logic easy to follow. A brief comment clarifies field ordering. Overall readability is high with only minor formatting improvements possible.","tokens":775,"name":"52.jsnp"}
{"score":"85","reasoning":"The method name clearly describes its purpose and the parameter is well‑named. Each call to registerStrategyImplementor is formatted consistently, making the flow easy to follow. However the repeated pattern could be abstracted into a helper or loop to reduce duplication, which would improve maintainability. Overall the code is readable but not optimal for brevity.","tokens":577,"name":"171.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear annotations and descriptive variable names. Comments explain the purpose of each query. The flow of opening a session, persisting entities, checking counts, and cleanup is easy to follow. Minor issues are long comment lines and repeated string literals but overall readability is good","tokens":1155,"name":"78.jsnp"}
{"score":"70","reasoning":"The method is short and uses descriptive names, each line calls parse with a string literal. The presence of many similar strings makes it a bit dense, but the structure is clear and comments explain intent. Overall it is fairly readable for a test case.","tokens":805,"name":"86.jsnp"}
{"score":"85","reasoning":"The code is well formatted with clear naming and a concise comment that explains its purpose. The test method uses a straightforward anonymous subclass to override a single method, making the intent easy to follow. The only slight complexity is the use of an abstract test base, but overall the snippet is highly readable","tokens":733,"name":"53.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear naming and consistent indentation making it fairly readable. The use of builder pattern and descriptive method calls aids comprehension. However the nested method calls and lack of intermediate variables add some cognitive load, and a brief comment could improve clarity. Overall the code is understandable but not optimal for quick reading.","tokens":651,"name":"182.jsnp"}
{"score":"80","reasoning":"The method is straightforward, uses clear variable names and follows a logical sequence of creating, saving and linking entities. Minor issues are the non sequential save order and lack of comments, but overall the code is easy to read and understand","tokens":886,"name":"76.jsnp"}
{"score":"78","reasoning":"The test method has a clear name and introductory comments that explain the purpose, making the intent easy to grasp. Each SyntaxChecker call is on a separate line, which aids readability, though the many similar statements are repetitive and could be refactored. Overall the code is well structured and understandable, earning a solid score","tokens":1161,"name":"79.jsnp"}
{"score":"85","reasoning":"The snippet is short and well structured with clear naming of variables and methods The use of JUnitCore and a RunListener is idiomatic and easy to follow The anonymous inner class is simple but could be replaced with a lambda for brevity Overall the logic is straightforward and the assertions are clear making the code highly readable","tokens":604,"name":"124.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive variables, making its purpose obvious. The flow of try catch and the assertions are straightforward. Minor issues are the nested boolean flags and the loop that checks method names, which adds some noise but does not hinder understanding. Overall readability is high","tokens":900,"name":"161.jsnp"}
{"score":"80","reasoning":"The test method is clearly named and uses standard JUnit assertEquals. Indentation is consistent and the chain of calls is readable though a bit deep; extracting intermediate variables would improve clarity. Overall the snippet is easy to understand for developers familiar with the codebase, earning a score of 80","tokens":668,"name":"165.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical flow, making the purpose easy to follow. Indentation is consistent and comments explain the assertion. However use of raw Iterator, long inline messages and mixed logging reduce clarity, and exception handling could be simpler. Overall readability is good but not excellent.","tokens":910,"name":"137.jsnp"}
{"score":"78","reasoning":"The method follows a common pattern with early returns and null safe checks but the variable name is long and the ternary null checks are a bit dense; using Objects.equals would be clearer. Overall the logic is straightforward and easy to follow, giving a solid readability rating","tokens":670,"name":"70.jsnp"}
{"score":"78","reasoning":"The constructor is clearly documented and uses descriptive constant names which aid understanding. The formatting with each argument on its own line improves readability. However the long parameter list makes it harder to grasp the purpose of each value and the inline comments are not part of the code, which slightly reduces clarity.","tokens":700,"name":"4.jsnp"}
{"score":"78","reasoning":"The method name and parameter names are clear and the logic follows a straightforward sequence of checks. The early returns make the flow easy to follow but the nested if with multiple conditions and inline comments adds some visual clutter. Overall the code is well structured and understandable earning a solid readability rating","tokens":929,"name":"29.jsnp"}
{"score":"55","reasoning":"The method is long and repetitive, with many null assignments and collection removals that make the intent hard to follow. Variable names are single letters, reducing clarity. Session handling is straightforward, but the overall structure could be refactored for better readability","tokens":856,"name":"200.jsnp"}
{"score":"78","reasoning":"The constructor clearly creates listener instances and registers them with the event registry using descriptive variable names. The sequence of operations is logical and easy to follow. However the casting and method chaining are a bit dense, and lack of comments or spacing makes it slightly harder for newcomers. Overall readability is good but could be improved.","tokens":768,"name":"139.jsnp"}
{"score":"55","reasoning":"The method has deep nested if statements, unclear variable names, mixed responsibilities and raw collections which hurt readability. Comments and TODOs add noise but do not clarify logic. The flow is hard to follow, though the overall intent is visible, leading to a moderate score.","tokens":982,"name":"155.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming, logical sequence of setup, action, and verification. Variable names are descriptive and the flow is easy to follow. Minor issues are reliance on external helper methods and some domain specific details, but overall the code is readable and understandable","tokens":924,"name":"75.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical sequence of setting properties, creating the factory, building regions, and asserting configuration values. Variable names are descriptive and the use of try‑finally ensures cleanup. The only drawback is the repetitive property setup and lack of helper methods, but overall the code is easy to follow","tokens":1026,"name":"130.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and logical steps. Use of JPA Criteria API is straightforward but the fluent API makes lines long and generic casts add noise. A single comment helps but overall a developer familiar with JPA can follow easily","tokens":764,"name":"163.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and consistent use of constants, making the intent easy to follow. The sequence of hint settings and assertions is logical. However the cast to internal Hibernate classes adds some complexity and the repeated assertions increase length, slightly reducing readability","tokens":1085,"name":"162.jsnp"}
{"score":"70","reasoning":"The constructor uses nested ternary operators and long generic type declarations which make the lines dense and harder to scan. While the logic is straightforward—initializing lists from a collector or using empty immutable lists—the formatting and lack of line breaks reduce readability. A clearer if-else structure would improve comprehension.","tokens":777,"name":"196.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names and a straightforward switch to map SQL state codes to constraint names. The extraction logic is encapsulated in a helper method, making the main flow easy to follow. However the use of raw numeric SQL state codes without named constants and minimal comments reduces readability, preventing a higher score.","tokens":807,"name":"22.jsnp"}
{"score":"65","reasoning":"The test method is long and repetitive, assigning many query results to the same raw List variable without generics or comments. Query strings are clear but the lack of structure, inline literals and repeated code hurt readability. Naming is reasonable but overall the method could be broken into smaller parts for easier comprehension.","tokens":1335,"name":"83.jsnp"}
{"score":"70","reasoning":"The test follows a clear sequence of opening a session, cleaning data, inserting entities, committing, and then querying. Annotations explain the test purpose and dialect skip list. The conditional for TimesTen is explicit. Long inline SQL strings and mixed HQL/SQL reduce readability, and lack of comments makes intent less obvious. Overall readability is decent but could be improved.","tokens":1218,"name":"71.jsnp"}
{"score":"70","reasoning":"The method is moderately readable but suffers from deep nesting and repeated normalisation calls. Variable names are clear and intent is evident, yet the logic could be simplified by extracting helper methods. Consistent formatting helps, but the multiple if‑else blocks reduce overall ease of comprehension","tokens":644,"name":"30.jsnp"}
{"score":"70","reasoning":"The method is short and its purpose is clear, but it lacks generic type declarations, comments and uses a raw Set which reduces type safety. The long chain of addAll calls is readable but could be formatted or extracted for clarity. Returning null instead of an empty set is a minor design issue. Overall readability is moderate.","tokens":765,"name":"123.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment and uses descriptive variable names. The code follows a consistent pattern for serializing fields, making it easy to follow. Minor improvements could include grouping related writes or adding inline comments, but overall the snippet is readable and straightforward","tokens":586,"name":"38.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear logging and descriptive variable names. Comments explain the purpose of each block. The flow of clearing caches, iterating entries, and handling removal or recreation is logical. Minor complexity arises from the IdentityMap usage but overall the code is easy to follow.","tokens":992,"name":"66.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical flow. Annotations and setup are obvious. Extensive explanatory comments aid understanding of the JPA mapping rule. The long assert line could be broken for clarity, but overall the code is easy to follow. No complex constructs are used.","tokens":1138,"name":"134.jsnp"}
{"score":"78","reasoning":"The method is concise and uses clear names. Creating an anonymous Thread and overriding run adds a level of nesting but is straightforward. The try-finally ensures cleanup. A comment explains a limitation. It could be simplified with a lambda or executor, but overall the flow is easy to understand","tokens":796,"name":"1.jsnp"}
{"score":"85","reasoning":"The method is well documented with clear Javadoc, uses descriptive names and straightforward if‑else logic, making it easy to follow. The null check for mode is explicit and the exception provides useful context. A TODO comment hints at future changes but does not hinder current understanding. Overall readability is high with minor room for improvement.","tokens":707,"name":"32.jsnp"}
{"score":"55","reasoning":"The method has a clear Javadoc header and a straightforward purpose, but the implementation suffers from poor formatting, raw types, inconsistent indentation and a redundant call to getInterfaces inside the loop. Variable names are vague and generic collections are used without generics, making the code harder to follow","tokens":956,"name":"44.jsnp"}
{"score":"78","reasoning":"The method is well‑structured with clear naming and straightforward switch logic for hex digits. Use of matchRange makes intent obvious. However the extra token boilerplate, redundant variables and nested blocks add noise, slightly reducing readability for newcomers.","tokens":762,"name":"117.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear session handling and descriptive variable names. The use of annotations clarifies purpose. However raw List type, lack of comments, and the unusual empty IN clause reduce clarity. Overall readability is good but not perfect.","tokens":704,"name":"77.jsnp"}
{"score":"92","reasoning":"The method is short and self explanatory with clear naming for the method parameters and local variable. Indentation and line breaks aid readability. It simply creates a strategy object and delegates to a builder, making the flow easy to follow. No complex logic is present","tokens":687,"name":"143.jsnp"}
{"score":"78","reasoning":"The test method is concise and uses clear naming, making the sequence easy to follow. Assertions show expected transaction state before and after begin. Session creation uses a fluent API which is readable but slightly dense without comments. Overall the code is well structured and understandable, resulting in a high readability rating.","tokens":745,"name":"128.jsnp"}
{"score":"70","reasoning":"The method is fairly straightforward with descriptive variable names and a clear try catch structure, but the loop logic is slightly confusing, the while condition relies on a pre initialized line variable, and external dependencies like getSectId LINE_SEPARATOR and mAry are not explained, reducing overall clarity","tokens":782,"name":"48.jsnp"}
{"score":"65","reasoning":"The method is straightforward and uses lazy initialization, which is clear. However readability suffers from the use of raw Vector without generics, repetitive addElement calls, and magic constants. A loop or collection initializer would be cleaner. Overall the code is understandable but could be more concise and modern","tokens":643,"name":"45.jsnp"}
{"score":"65","reasoning":"The method mixes option parsing, error handling and array copying in one block with deep nesting and several inline checks. Variable names are clear but missing context and long if‑else chains reduce readability. Extracting filter handling and early returns would simplify it, so readability is moderate","tokens":828,"name":"15.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear assertions and descriptive names, making the intent easy to follow. Use of fluent session creation and explicit transaction checks aids readability. However the heavy casting, long chained calls and repeated boilerplate reduce clarity slightly, preventing a higher score.","tokens":919,"name":"127.jsnp"}
{"score":"78","reasoning":"The method is short and self contained, variable names are descriptive and the printed output is clearly labeled. The use of StringHelper.join makes collection printing readable. Formatting with extra blank lines aids visual separation but the long concatenated line is slightly dense. Overall the code is easy to understand","tokens":734,"name":"144.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive variable names and logical early returns. Logging statements aid tracing. Generic types are declared clearly, and the flow from synthetic check to attribute metadata handling is straightforward. Minor complexity arises from casting and nested generic calls but overall readability is high","tokens":975,"name":"84.jsnp"}
{"score":"88","reasoning":"The method is clearly documented with Javadoc, uses descriptive names and simple control flow, early returns improve readability, and null handling is explicit. Indentation and spacing are consistent making the logic easy to follow. Minor verbosity in nested loops prevents a perfect score","tokens":791,"name":"40.jsnp"}
{"score":"68","reasoning":"The code is fairly straightforward with clear method and variable names, but readability suffers from a few issues. The nested call type.sqlTypes(mapping)[getTypeIndex()] is dense and could be broken out. The error messages contain grammatical errors and the method name getSqlTypeCode is overloaded, causing potential confusion. Lack of comments and handling of generic Exception also reduce clarity.","tokens":613,"name":"37.jsnp"}
{"score":"45","reasoning":"The method uses raw types and outdated collections which makes the intent unclear. Variable names are short and the logic is nested with several facade calls, reducing readability. A comment notes wasteful use of Vector but does not improve understanding. Overall the code is moderately hard to follow.","tokens":738,"name":"120.jsnp"}
{"score":"70","reasoning":"The method has clear intent and descriptive names but suffers from deep nesting, long lines and a raw List cast which hurt readability. Repeated builder calls and magic strings add complexity. Overall it is understandable for experienced Java developers but could be refactored for clarity","tokens":958,"name":"109.jsnp"}
{"score":"45","reasoning":"The method is moderately long and uses clear variable names but mixes raw types and casts, contains a TODO comment and uses \u003d\u003d for string comparison which is error prone. The nested if statements and anonymous Runnable add complexity, and lack of generics reduces clarity. Overall readability is limited, resulting in a low to moderate score.","tokens":892,"name":"154.jsnp"}
{"score":"78","reasoning":"The test method name is descriptive and the steps follow a logical order. Variable names are clear and the use of Hibernate session APIs is straightforward. Minor issues include inline comments that could be better formatted and a long method body without helper extraction, but overall the code is easy to follow","tokens":849,"name":"179.jsnp"}
{"score":"78","reasoning":"The method is well-structured with clear naming and logical flow. Nested try-catch blocks handle transaction and expected exception cleanly. Indentation is consistent and comments are minimal but informative. Minor issues are the deep nesting and lack of inline comments for each step which slightly reduces readability","tokens":901,"name":"129.jsnp"}
{"score":"78","reasoning":"The method is short and follows a logical flow, variable names are clear and the purpose of each block is evident. Indentation is mostly consistent but there are stray comment lines and mixed spacing that slightly hinder readability. The nested conditionals are simple and the overall structure is easy to follow","tokens":839,"name":"122.jsnp"}
{"score":"70","reasoning":"The test method is straightforward, using assertEquals to compare expected revision lists with actual results from getAuditReader(). The repeated pattern is clear, but the long multiline calls and lack of comments make it slightly harder to follow, and variable names are not self explanatory, reducing readability","tokens":829,"name":"185.jsnp"}
{"score":"78","reasoning":"The method uses clear variable names and logical structure, but deep nesting, repeated resolve calls and long lines reduce readability. Use of isInstance instead of instanceof adds verbosity. Overall the code is understandable but could be refactored for clarity","tokens":934,"name":"197.jsnp"}
{"score":"70","reasoning":"The method uses clear names and consistent error handling, making each case understandable. However the long chain of else‑if statements is verbose and repetitive, reducing overall clarity. Refactoring into a lookup or separate methods would improve readability, so it is moderately readable","tokens":1112,"name":"108.jsnp"}
{"score":"70","reasoning":"The method follows a clear step by step flow and uses descriptive names, but it relies on raw List and Iterator types, lacks generics and comments, and contains several nested conditionals with magic strings. These factors make the code moderately readable but not highly clear.","tokens":944,"name":"8.jsnp"}
{"score":"85","reasoning":"The method builds a descriptive string using a StringBuilder with fluent chaining. Each field is appended on its own line, making the structure clear. Variable names are self explanatory and the format is consistent. Minor improvements could include using String.format or reducing line length, but overall readability is high.","tokens":747,"name":"63.jsnp"}
{"score":"78","reasoning":"The method name is clear and variables are well chosen. The sequential instanceof checks make the logic easy to follow, and the recursion for nested suites is straightforward. However the long else‑if chain and repeated casting add verbosity, and a polymorphic design could simplify it. Overall readability is good but could be cleaner.","tokens":802,"name":"54.jsnp"}
{"score":"65","reasoning":"The test follows a clear sequence of steps but excessive separator comments and redundant casts make it harder to read; variable names are descriptive and assertions are straightforward, resulting in moderate readability.","tokens":1090,"name":"17.jsnp"}
{"score":"80","reasoning":"The method name is clear and variable names are descriptive. It copies existing values, checks for existing schema and catalog, and adds missing defaults in a straightforward way. The logic is easy to follow though a few extra boolean flags and list copying add minor noise. Overall readability is good","tokens":992,"name":"195.jsnp"}
