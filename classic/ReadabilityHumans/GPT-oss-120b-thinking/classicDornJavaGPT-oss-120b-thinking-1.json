{"score":"78","reasoning":"The snippet is concise and uses clear naming conventions such as workflowContext and kaleoInstanceToken which aid comprehension. The use of standard library methods like containsKey and GetterUtil.getLong is straightforward. However, the cast to String and reliance on external constants may require familiarity with the surrounding framework, slightly reducing readability for newcomers.","tokens":458,"name":"133.jsnp"}
{"score":"30","reasoning":"The snippet is short and lacks context, making it hard to understand its purpose. Empty catch block hides errors, and there are no comments explaining the logic. Variable names are unclear and the use of RuntimeVariables.replace is unexplained. The code mixes exception handling, sleep, and a Selenium click without clear flow, reducing readability and maintainability.","tokens":456,"name":"174.jsnp"}
{"score":"40","reasoning":"The snippet only contains import statements which are clearly formatted and use fully qualified class names, making them easy to understand. However, there is no actual implementation or logic to assess, limiting the ability to judge overall readability and comprehension. The lack of context reduces the score.","tokens":491,"name":"208.jsnp"}
{"score":"85","reasoning":"The code is clear and follows standard Java conventions with descriptive method names and consistent formatting. Each method performs a single straightforward task making it easy to understand. The lack of comments and class context slightly reduces clarity, but overall the snippet is readable and maintainable","tokens":628,"name":"153.jsnp"}
{"score":"80","reasoning":"The code is short and well structured with clear class and method names, proper imports and indentation, making it easy to read. However it is incomplete and lacks comments or error handling, which slightly reduces clarity","tokens":530,"name":"191.jsnp"}
{"score":"78","reasoning":"The code is well formatted with clear null checks and descriptive method names. Exception handling is straightforward and the flow is easy to follow. Variable names are meaningful and the use of helper methods keeps complexity low. The multi‑line call to PortalUtil.updatePortletMode is slightly long but still readable. Overall the snippet is easy to understand.","tokens":730,"name":"131.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear Javadoc comments, descriptive method and variable names, and consistent indentation. Constructors and accessor methods are straightforward. However the snippet omits the class declaration and field definitions, and the default constructor calls super with nulls which may be confusing. Overall readability is good but not perfect.","tokens":886,"name":"221.jsnp"}
{"score":"78","reasoning":"The code uses clear variable names and consistent indentation which aids readability. Early returns simplify the flow but catching a generic Exception reduces clarity. The conditional handling of private versus public layout sets is straightforward. Overall the snippet is easy to follow but could benefit from more specific exception handling and comments","tokens":797,"name":"101.jsnp"}
{"score":"65","reasoning":"The snippet is short and well indented, but uses an undefined BETTER_THAN operator, cryptic variable names and magic constants, and lacks comments explaining the bias update logic. The flow is clear but readability suffers from these ambiguities, limiting quick comprehension.","tokens":796,"name":"112.jsnp"}
{"score":"55","reasoning":"The code uses Selenium calls but lacks comments and has empty catch blocks which hide errors. Magic numbers like 90 and 1000 are not explained and the loop structure is verbose. Variable names are clear but overall readability suffers due to poor error handling and missing documentation","tokens":714,"name":"146.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear variable names and logical flow. Resource loading and error handling are straightforward. However long method chains, nested ifs and reliance on external utilities make it slightly harder to follow, preventing a higher score.","tokens":948,"name":"103.jsnp"}
{"score":"70","reasoning":"The method is moderately readable with descriptive variable names and logical grouping of parameters. However it uses raw collections, many magic strings, and a nested anonymous listener which adds complexity. Lack of generics and extensive inline list handling reduces clarity, but the overall flow is understandable","tokens":1087,"name":"106.jsnp"}
{"score":"70","reasoning":"The code is consistently formatted and uses clear method names, making it easy to follow the control flow. However the repeated try‑catch pattern adds unnecessary verbosity and could be refactored into a helper, which would improve maintainability. Overall readability is good but redundancy limits the score.","tokens":559,"name":"140.jsnp"}
{"score":"45","reasoning":"The snippet is short but unclear because the surrounding loop is missing and the empty catch hides errors. The use of a magic xpath string and a break without context reduces readability. Overall it is moderately hard to understand.","tokens":646,"name":"192.jsnp"}
{"score":"70","reasoning":"The class is short and follows a clear structure with constructors and simple methods. Use of raw Map without generics reduces type safety and readability. Variable names are descriptive. Comments are sparse but method purpose is evident. Overall the code is easy to follow but could be improved with generics and more documentation","tokens":969,"name":"166.jsnp"}
{"score":"78","reasoning":"The code follows standard Java naming conventions and uses clear method calls, making the flow easy to follow. Variable names are descriptive and the logic is straightforward. However the snippet is incomplete, lacks comments and some lines are slightly dense, which reduces overall readability","tokens":861,"name":"186.jsnp"}
{"score":"85","reasoning":"The code follows standard Java conventions with clear JavaDoc comments, consistent naming, and proper indentation. Each getter and setter is simple and self‑explanatory, making it easy to understand. The repetition is expected for accessor methods, though it adds verbosity. Overall readability is high but could be improved with less boilerplate, such as using Lombok.","tokens":675,"name":"136.jsnp"}
{"score":"85","reasoning":"The snippet is concise and uses clear method names with Javadoc comments and an annotation, making the purpose of each method obvious. The stray comment terminator at the start is a minor formatting issue but does not hinder comprehension. Overall the code is well‑structured and easy to read, meriting a high readability score.","tokens":592,"name":"168.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions, method names are descriptive and the flow is straightforward. Repeated null and enabled checks with logging make the logic clear but cause redundancy that could be extracted. Lack of comments and minor duplication reduce readability slightly. Overall the snippet is easy to understand, earning a score of 78","tokens":866,"name":"116.jsnp"}
{"score":"80","reasoning":"The code is concise and uses clear naming conventions making it easy to follow. The class extends a base test suite and the suite method creates a TestSuite and adds two test suites, which is straightforward. However the snippet lacks imports and full context, which slightly reduces overall readability.","tokens":510,"name":"176.jsnp"}
{"score":"78","reasoning":"The snippet is fairly readable due to descriptive variable names and logical grouping of operations. Using ParamUtil and serviceContext makes intent clear. However the long argument list in updateFileEntry reduces clarity, and lack of comments forces the reader to infer purpose. Overall the code is understandable but could be cleaner with fewer parameters or builder pattern.","tokens":610,"name":"135.jsnp"}
{"score":"65","reasoning":"The code follows Java naming conventions and indentation, but uses an unusual label‑switch loop for flow control, making the logic harder to follow. Lack of comments and the verbose wait loop add noise. Variable names are clear, but overall structure reduces readability, leading to a moderate score.","tokens":746,"name":"102.jsnp"}
{"score":"65","reasoning":"The snippet is fairly straightforward Selenium test code but suffers from repetitive calls and lack of comments. Variable names are clear and the flow is linear, yet the long chained method calls and the busy‑wait loop reduce readability. Overall it is understandable but could be cleaner","tokens":685,"name":"167.jsnp"}
{"score":"78","reasoning":"The snippet is well‑structured Java test code with clear method names and consistent indentation. Variable names are descriptive and the use of assertions is straightforward. Some lines are long and the context of helper methods is missing, which slightly hampers understanding, but overall it is easy to follow","tokens":938,"name":"204.jsnp"}
{"score":"78","reasoning":"The code is clear and follows standard Java naming conventions, making it easy to follow. Repetitive setter calls are straightforward but could be condensed for brevity. The compareTo method is simple and well‑structured. Overall readability is good, though minor improvements like using a copy constructor or builder could raise clarity.","tokens":646,"name":"183.jsnp"}
{"score":"65","reasoning":"The code follows a linear Selenium test flow but uses long XPath strings, repeated wait calls and magic numbers which reduce clarity. Lack of comments and descriptive variable names makes it harder to follow, though the sequence of actions is evident. Overall readability is moderate.","tokens":1075,"name":"198.jsnp"}
{"score":"55","reasoning":"The code follows a repetitive Selenium pattern but mixes control flow with label jumps and continue statements making the logic hard to follow. Variable names are clear but the long XPath strings and repeated load calls reduce readability. Overall comprehension requires careful tracing, so the readability is moderate","tokens":1048,"name":"152.jsnp"}
{"score":"70","reasoning":"The code follows a clear linear flow of Selenium actions with consistent indentation, making the sequence of clicks and waits easy to follow. Variable names are descriptive enough, though the use of a generic label variable and repeated load calls add some noise. Overall readability is good but not exceptional, earning a solid mid range score","tokens":850,"name":"157.jsnp"}
{"score":"70","reasoning":"The code uses clear Selenium method names and consistent indentation which aids readability, but it includes a busy wait loop with a magic timeout value, an empty catch block, and label based flow control that obscure logic. Variable names are adequate but could be more descriptive. Overall the snippet is understandable but not optimal, leading to a moderate score.","tokens":908,"name":"107.jsnp"}
{"score":"78","reasoning":"The code is clear and follows typical Java Swing patterns. Method names and logic are self explanatory, and null checks protect against errors. Use of underscore prefix for fields is slightly unconventional but does not hinder understanding. Lack of comments and minimal formatting quirks keep the snippet readable for experienced developers","tokens":652,"name":"170.jsnp"}
{"score":"85","reasoning":"The code follows standard Java conventions with clear method names and consistent indentation. Getters are straightforward and the hashCode and equals implementations are simple and correctly use super methods and field checks. Minor issues are lack of comments for getters and no explicit handling of null in equals, but overall readability is high","tokens":796,"name":"150.jsnp"}
{"score":"85","reasoning":"The snippet is concise and self‑explanatory. Constructor clearly sets up the command with descriptive parameters and calls the superclass. Variable names are meaningful, and the execute method follows a simple read‑modify pattern. Minor improvements could include null checks or brief comments, but overall readability is high.","tokens":565,"name":"104.jsnp"}
{"score":"85","reasoning":"The snippet consists of a well‑structured Javadoc comment that clearly describes the purpose, author, and licensing, making it easy to understand the context. The two import statements are straightforward and follow standard Java conventions. Overall readability is high despite the minimal code, but the lack of functional code limits depth of assessment.","tokens":722,"name":"190.jsnp"}
{"score":"30","reasoning":"The snippet is poorly formatted and incomplete making it hard to understand. A stray method call appears before a Javadoc comment that does not match the call. The method signature is split across lines without a body or interface context. Lack of surrounding code, inconsistent spacing and missing braces reduce readability significantly","tokens":486,"name":"126.jsnp"}
{"score":"78","reasoning":"The code is short and uses clear naming. The constructor does nothing and contains a commented out assignment which may confuse readers. The getIcon method is straightforward, calling a static helper with constant strings. Overall readability is good but the dead code reduces clarity slightly.","tokens":670,"name":"181.jsnp"}
{"score":"78","reasoning":"The code follows standard Java bean conventions with clear naming and Javadoc comments which aid comprehension. Fully qualified type names are verbose but explicit. Repetitive getter and setter patterns are easy to follow. Missing declaration of archiveFiles in the snippet creates slight ambiguity, lowering the score modestly","tokens":884,"name":"188.jsnp"}
{"score":"70","reasoning":"The code follows standard Java conventions with clear naming, consistent indentation and reasonable comments. The use of static constants and a monitor is straightforward. However the long import list, missing documentation for parameters and incomplete method body reduce overall clarity, keeping the score moderate.","tokens":916,"name":"151.jsnp"}
{"score":"70","reasoning":"The code follows standard Java naming and indentation, uses descriptive class and method names, and Selenium actions are clear. However the loop uses a magic timeout value, empty catch block provides no insight, and the snippet ends without closing braces making it incomplete. These factors reduce overall readability and comprehension.","tokens":806,"name":"212.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions, uses descriptive class and method names, and clear Selenium actions. Indentation and spacing aid readability. However the snippet is incomplete, lacks closing braces, and error handling is minimal, which slightly reduces comprehension.","tokens":710,"name":"209.jsnp"}
{"score":"85","reasoning":"The code is concise and follows standard Java conventions with clear class and method names. Indentation and spacing make the structure easy to follow. The purpose of adding test suites is evident. Minor issues include an incomplete snippet lacking closing braces, but the presented portion is readable and understandable.","tokens":479,"name":"207.jsnp"}
{"score":"55","reasoning":"The snippet shows Java method signatures with Javadoc but suffers from inconsistent indentation, redundant whitespace, duplicate method names, and inline comments that break flow. Lack of descriptive comments and missing context make it harder to understand quickly, reducing readability","tokens":844,"name":"201.jsnp"}
{"score":"80","reasoning":"The snippet is concise and uses clear naming for constants, making intent obvious. Author tags provide some context. However, lack of class-level documentation and minimal formatting reduce overall readability. The code is easy to understand but could benefit from comments or grouping for better clarity.","tokens":461,"name":"189.jsnp"}
{"score":"65","reasoning":"The code uses clear variable names and straightforward logic but suffers from inconsistent formatting, redundant if blocks and repeated constant checks. The flow is easy to follow but could be simplified by consolidating the boolean assignments and array merges. Overall readability is moderate","tokens":833,"name":"187.jsnp"}
{"score":"85","reasoning":"The code is concise and follows standard Java naming conventions making it easy to read The class name clearly indicates its purpose The suite method is straightforward creating a TestSuite and adding test classes The author comment adds minimal context but there is no detailed documentation for each test which slightly reduces clarity Overall the snippet is highly readable","tokens":562,"name":"199.jsnp"}
{"score":"78","reasoning":"The snippet is well‑indented and uses descriptive method names that make its purpose clear. The test methods follow standard JUnit patterns, checking normal and error cases. However, missing context for classUnderTest and the surrounding method reduce self‑containment, and the exception handling comments could be clearer. Overall readability is good but not perfect.","tokens":644,"name":"178.jsnp"}
{"score":"84","reasoning":"The code follows standard Java conventions, clear method names, consistent indentation, and uses descriptive variable names. Permission checks are explicit, making logic easy to follow. Minor issues are missing import statements for some classes and limited comments, but overall readability is high.","tokens":938,"name":"175.jsnp"}
{"score":"65","reasoning":"The code follows a logical flow with clear method names and variable naming, making the purpose understandable. However, nested conditionals and multiple try‑catch blocks, including empty catches, reduce clarity. The use of magic constants and lack of comments make it harder for new readers. Overall readability is moderate but could be improved with better error handling and documentation.","tokens":805,"name":"180.jsnp"}
{"score":"65","reasoning":"The test follows a clear sequence of opening a page, waiting for a link, clicking it, and checking element presence. Variable names are descriptive and the structure is linear. However the repeated polling loops, hard coded timeouts, and Thread sleep calls reduce clarity and make maintenance harder. Overall readability is moderate.","tokens":1195,"name":"145.jsnp"}
{"score":"70","reasoning":"The snippet follows typical Java persistence patterns with clear variable names and structured try-catch-finally blocks. Indentation is consistent and the logic is straightforward. However the use of raw casts, the conditional handling of orderByComparator, and the extra sort call reduce clarity. Minor naming and formatting issues keep it from higher readability","tokens":872,"name":"202.jsnp"}
{"score":"65","reasoning":"The code is moderately readable but suffers from several issues. Variable names are clear but the use of a label and continue makes flow harder to follow. Magic numbers like 90 and 1000 are unexplained, and the empty catch block hides errors. Overall the logic is understandable but could be cleaner.","tokens":776,"name":"217.jsnp"}
{"score":"55","reasoning":"The snippet uses a typical Selenium flow but relies on a busy‑wait loop with a hard‑coded timeout, long XPath strings and an empty catch block which reduces clarity. Variable names are clear but there are no comments and the structure is dense, making it moderately hard to read and understand.","tokens":814,"name":"215.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions, uses clear naming, and groups internationalized strings in a dedicated inner interface. Imports are explicit and the constructor simply forwards parameters. Minor drawbacks are the unconventional inner interface for i18n and lack of comments on behavior, but overall readability is good.","tokens":967,"name":"172.jsnp"}
{"score":"70","reasoning":"The snippet is short and well indented with clear variable names. The synchronized block and conditional logic are easy to follow. However the surrounding context is missing and the purpose of the cache key is not explained, which slightly reduces overall clarity","tokens":632,"name":"156.jsnp"}
{"score":"78","reasoning":"The code follows standard Java conventions with clear method names and consistent indentation making the flow easy to follow. Variable names are descriptive and exception handling is straightforward. Some nested conditionals and long method chains slightly reduce clarity but overall readability is good","tokens":792,"name":"111.jsnp"}
{"score":"70","reasoning":"The snippet is short and uses clear method names, but it mixes UI actions with control flow, uses a magic timeout string, a Unicode literal, and an unexplained label variable, which reduces clarity. Variable naming is adequate but the purpose of the label is not evident, making it moderately readable.","tokens":658,"name":"149.jsnp"}
{"score":"70","reasoning":"The snippet shows three simple Java method signatures, which are easy to understand in terms of purpose. However the unconventional line breaks between return type and method name disrupt the visual flow and make it slightly harder to read. The use of semicolons is correct for an interface, but overall formatting could be improved for clarity, leading to a moderate readability score","tokens":501,"name":"158.jsnp"}
{"score":"55","reasoning":"The snippet uses clear Selenium calls but readability suffers from missing comments, magic numbers, and an infinite loop with manual timeout. Variable names are adequate but error handling is empty and indentation is uneven. Overall it is moderately understandable but could be cleaner","tokens":784,"name":"220.jsnp"}
{"score":"85","reasoning":"The code consists of a clear sequence of setter calls that map values from existing objects and parameters to a new layoutRevision. Naming is consistent and the conditional block for icon handling is simple. The layout is well spaced and easy to follow, though the length could be reduced with a builder or helper. Overall readability is high","tokens":898,"name":"148.jsnp"}
{"score":"70","reasoning":"The code is moderately readable. Method names describe their purpose and comments give context. Indentation is inconsistent and long regular expression strings are hard to follow. Error handling is minimal and some logic is spread across methods, which slightly hampers comprehension.","tokens":1070,"name":"177.jsnp"}
{"score":"45","reasoning":"The snippet mixes Selenium actions with control flow that uses a label and continue which is hard to follow. Variable names are generic and there are no comments explaining the purpose of each step. Magic strings and hard coded timeouts reduce clarity. Indentation is modest but long lines and repeated calls hurt readability leading to a low score.","tokens":1059,"name":"193.jsnp"}
{"score":"80","reasoning":"The snippet is well‑structured with a clear license header, package declaration and concise Javadoc. Naming follows Java conventions and the purpose is explained. However the interface is empty, offering no functional content to assess, which limits depth of comprehension. Overall readability is good but limited by lack of implementation.","tokens":658,"name":"160.jsnp"}
{"score":"40","reasoning":"The snippet is short but confusing. The try block checks visibility and uses break, implying it is inside a loop that is not shown. The empty catch hides errors, and the sleep after the block adds unclear timing logic. Variable names are clear but lack comments, making overall comprehension difficult","tokens":544,"name":"105.jsnp"}
{"score":"55","reasoning":"The snippet shows a series of listener management methods but suffers from poor formatting, inconsistent indentation, and missing class context which hampers quick understanding. Empty method bodies and repeated notSupported calls are clear, yet the irregular line breaks and spacing reduce readability, leading to a moderate score","tokens":618,"name":"138.jsnp"}
{"score":"78","reasoning":"The code is well structured with clear naming and logical flow. Imports and class purpose are evident, and the test method follows a readable pattern of setup, execution, and assertions. Minor drawbacks are reliance on external helper methods not shown, which slightly hampers standalone comprehension. Overall readability is good.","tokens":983,"name":"159.jsnp"}
{"score":"88","reasoning":"The code is straightforward and easy to understand. Method names clearly describe their purpose and parameters are well‑named. Consistent indentation and spacing improve readability. Using fully qualified class names adds verbosity but does not hinder comprehension. No complex logic is present, making the snippet highly maintainable.","tokens":512,"name":"214.jsnp"}
{"score":"85","reasoning":"The code is well structured with clear JavaDoc comments for each method, making intent obvious. Method names and parameters follow standard conventions, aiding comprehension. Minor issues include a typo in a comment, inconsistent indentation, and occasional spacing irregularities, but these do not significantly hinder readability. Overall the interface is easy to understand.","tokens":806,"name":"184.jsnp"}
{"score":"78","reasoning":"The snippet shows clear Java method signatures with Javadoc for two methods, making intent obvious. However spacing errors in the comments (class p k) and lack of documentation for isNew reduce clarity. Formatting is simple and consistent, but minor issues prevent a higher score.","tokens":468,"name":"141.jsnp"}
{"score":"70","reasoning":"The snippet is short and uses clear naming for methods and variables, making it easy to follow the delegation pattern and observer update. However, lack of surrounding context, missing class definition and braces reduce overall clarity, and the code fragment ends abruptly, limiting comprehension.","tokens":456,"name":"132.jsnp"}
{"score":"78","reasoning":"The code is well-structured with clear method names and generic types that convey intent. Variable names are descriptive and the logic is straightforward, iterating over plugins and checking settings. However the snippet is incomplete (second method lacks body and closing brace) and relies on external services, which slightly reduces readability","tokens":834,"name":"119.jsnp"}
{"score":"55","reasoning":"The code follows standard Java naming conventions and uses clear method names, making the intent understandable. However the snippet is incomplete, missing closing braces and context, which hampers full comprehension. The loop for timeout is straightforward but could be clearer with a helper method. Overall readability is moderate but limited by truncation","tokens":483,"name":"114.jsnp"}
{"score":"30","reasoning":"The snippet shows fragmented Java method declarations with misplaced parentheses and line breaks, making it hard to follow. The Javadoc comment is present but the surrounding code lacks proper formatting and context, reducing clarity. Overall readability is low due to syntax errors and inconsistent style.","tokens":471,"name":"118.jsnp"}
{"score":"85","reasoning":"The code is short and uses clear variable names but string concatenation in a loop is inefficient and the logic could be expressed more directly Indentation is inconsistent and comments are present but not formatted as proper Javadoc Overall readability is decent for experienced developers but could be improved","tokens":783,"name":"115.jsnp"}
{"score":"85","reasoning":"The code is concise and self explanatory. The constructor clearly copies an existing packet by delegating to the superclass. The method name indicates its purpose and returns a constant that matches the ICMP header size. Naming follows Java conventions and there are no complex constructs, making it easy to read","tokens":443,"name":"213.jsnp"}
{"score":"78","reasoning":"The code is clear and follows a simple pattern of null checking before assigning timestamps, making the intent easy to follow. Variable names are descriptive and the flow is linear. Minor repetition could be reduced with helper methods or ternary operators, but overall readability is good","tokens":718,"name":"142.jsnp"}
{"score":"70","reasoning":"The code follows typical Java naming and structure and uses clear method names. However the long polling loop is verbose, lacks comments, and the snippet is incomplete which reduces clarity. Overall readability is decent but could be improved","tokens":898,"name":"203.jsnp"}
{"score":"45","reasoning":"The snippet is short but lacks context and proper formatting. The abstract method signature is clear, but the surrounding braces and indentation are inconsistent. The toString implementation uses an undefined variable \u0027string\u0027 and creates a new String unnecessarily, which reduces clarity. Absence of comments or documentation further hampers understanding, leading to a moderate readability score.","tokens":465,"name":"169.jsnp"}
{"score":"68","reasoning":"The code follows a clear procedural flow using Selenium commands, but readability suffers from repeated timeout loops, empty catch blocks and lack of comments. Variable names are generic and long lines reduce clarity. Refactoring the waiting logic into a helper method and adding brief comments would improve comprehension significantly","tokens":784,"name":"110.jsnp"}
{"score":"55","reasoning":"The code mixes several nested if‑else blocks with inconsistent indentation and unclear spacing. Use of magic character \u0027 \u0027 for no quote and combined conditions without parentheses makes the logic hard to follow. Variable names are short but meaningful. Overall readability is moderate but could be improved with clearer structure and comments.","tokens":690,"name":"164.jsnp"}
{"score":"78","reasoning":"The class is short and straightforward. Field names use a leading underscore which is unconventional but still clear. Methods are simple and self explanatory. Javadoc comments help understand purpose of getTitle and getHint. Lack of documentation for constructor and applyChanges is minor. Overall readability is good","tokens":826,"name":"147.jsnp"}
{"score":"45","reasoning":"The snippet follows a consistent indentation but relies heavily on long XPath strings and repeated Selenium calls which obscure intent. Variable names are absent, there are no comments, and the wait loops use magic numbers with empty catch blocks. These factors reduce readability and make the code harder to understand","tokens":994,"name":"194.jsnp"}
{"score":"88","reasoning":"The code follows standard Java conventions with clear class and method names consistent indentation and simple logic Each method is short and self explanatory and the use of descriptive variable names aids comprehension Minor drawbacks are the hard coded method name string and limited documentation of parameters but overall readability is high","tokens":1002,"name":"125.jsnp"}
{"score":"90","reasoning":"The code is a simple Java setter with a clear Javadoc comment. Naming is descriptive, formatting follows standard conventions, and the method body is trivial. No complex logic or hidden behavior makes it easy to understand. Minor improvements could include parameter validation but overall readability is high","tokens":492,"name":"161.jsnp"}
{"score":"55","reasoning":"The code follows a simple pattern but lacks comments and uses repetitive wait loops with magic numbers. Empty catch blocks hide errors and Thread.sleep makes timing fragile. Variable names are clear but the structure is verbose and could be refactored for better readability","tokens":912,"name":"210.jsnp"}
{"score":"88","reasoning":"The code is concise and well formatted with clear naming and a simple inheritance structure. The import statement and author comment provide context. The constructor is straightforward, calling the superclass constructor. Overall readability is high, though the snippet is very short and lacks additional documentation or comments that could improve understanding further","tokens":450,"name":"182.jsnp"}
{"score":"55","reasoning":"The code follows a typical Selenium test pattern but suffers from poor readability due to long inline XPath strings, hardcoded file paths, and repeated busy wait loops with magic numbers. Lack of comments and descriptive variable names makes the flow harder to follow, though the overall structure is straightforward","tokens":1124,"name":"173.jsnp"}
{"score":"55","reasoning":"The code follows a simple loop and Selenium actions but readability is limited. It uses magic numbers for timeout, an empty catch block, long hard‑coded XPath strings and repeated logic without comments or descriptive variable names. The flow is clear but the lack of documentation and concise expressions makes comprehension harder.","tokens":877,"name":"113.jsnp"}
{"score":"85","reasoning":"The code is well‑structured with clear package and import statements, a concise Javadoc comment, and consistently named methods that describe their purpose. Formatting follows standard Java conventions, making it easy to read. Minor improvements could include grouping related getters/setters or adding more detailed documentation, but overall it is highly readable.","tokens":759,"name":"200.jsnp"}
{"score":"68","reasoning":"The code follows a consistent pattern and uses clear naming for methods and variables which aids comprehension. However the repetitive try catch blocks, long generated method names and lack of comments make it verbose and harder to read. The error handling is boilerplate and adds noise, reducing overall readability.","tokens":795,"name":"165.jsnp"}
{"score":"45","reasoning":"The snippet mixes Selenium actions with control flow that uses a label variable and continue statements. Empty catch block hides errors and Thread.sleep makes timing fragile. XPath strings are hard coded and variable names are generic. Lack of comments further reduces clarity making readability moderate to low","tokens":813,"name":"121.jsnp"}
{"score":"92","reasoning":"The code is highly readable with a clear, consistent pattern of adding test suites. Each line follows the same method call, making it easy to scan and understand. The class names are descriptive, indicating the purpose of each test. Minor improvements could include grouping related tests or adding comments, but overall the snippet is straightforward and well‑structured","tokens":554,"name":"155.jsnp"}
{"score":"85","reasoning":"The code is clear and well formatted with descriptive variable names and consistent indentation. The validation logic is straightforward and easy to follow. Minor issues include duplicated code that could be extracted into a helper method and lack of comments, but overall readability is high","tokens":666,"name":"206.jsnp"}
{"score":"85","reasoning":"The snippet follows standard Java naming conventions and includes clear Javadoc for each method. The layout is consistent with proper indentation and spacing, making it easy to read. The only drawback is the lack of surrounding class or interface declaration, which slightly reduces context, but overall the code is straightforward and self‑explanatory","tokens":598,"name":"130.jsnp"}
{"score":"55","reasoning":"The snippet is short but lacks context and proper error handling. The empty catch block hides exceptions, making debugging hard. Indentation is inconsistent and the break is inside an if without a loop shown, reducing clarity. Overall readability is moderate","tokens":585,"name":"124.jsnp"}
{"score":"80","reasoning":"The snippet contains a clear license header, a descriptive package name, and well‑named imports that follow standard Java conventions. The code is easy to scan and understand, though it lacks any functional implementation to assess deeper readability. Overall it is clean and straightforward, earning a solid readability rating.","tokens":693,"name":"134.jsnp"}
{"score":"70","reasoning":"The code follows standard Java conventions and is well indented making the flow easy to follow. Variable names are clear and the Selenium actions are straightforward. The waiting loop with try catch and sleep adds some complexity but is still understandable. Overall readability is good but not exceptional","tokens":795,"name":"219.jsnp"}
{"score":"30","reasoning":"The snippet shows several closing braces without context making it hard to follow the structure. The method name and parameter are clear but there is no documentation or comments. Indentation is inconsistent and the surrounding code is missing, reducing overall readability and comprehension.","tokens":428,"name":"117.jsnp"}
{"score":"45","reasoning":"The snippet shows inconsistent indentation and mismatched braces that make the control flow hard to follow. The empty catch block provides no context for error handling, and the purpose of the break is unclear without surrounding loop code. Lack of comments and minimal spacing further reduce readability, resulting in a moderate score.","tokens":499,"name":"143.jsnp"}
{"score":"75","reasoning":"The snippet is short and uses clear naming and standard Java conventions making it easy to read, but it lacks comments, documentation and any functional context which limits comprehension, so it receives a moderate to good readability score","tokens":515,"name":"128.jsnp"}
{"score":"70","reasoning":"The code is straightforward with repeated updatePortletPermissions calls that are easy to follow, but the repetition suggests a lack of abstraction which hurts maintainability. Indentation is clear and variable names are descriptive, yet the snippet could benefit from a loop or data-driven approach to reduce boilerplate and improve readability","tokens":817,"name":"127.jsnp"}
{"score":"70","reasoning":"The snippet is clear about method purposes and signatures but suffers from excessive fully qualified names and repeated annotations which hurt readability. Lack of comments or grouping makes it harder to scan. Consistent formatting helps, yet the verbosity and duplication lower overall comprehension ease.","tokens":939,"name":"144.jsnp"}
{"score":"65","reasoning":"The code follows a consistent pattern but uses very long fully qualified names, nested try catch blocks and reflection which adds noise. Variable names are clear and indentation is proper, however the repeated boilerplate reduces readability, making it moderately hard to follow for newcomers","tokens":915,"name":"162.jsnp"}
{"score":"70","reasoning":"The class is small and its purpose is clear, the getters and setters are straightforward and the hasError method is easy to follow. The naming follows a common convention and the license header is present. The only drawback is that the private fields are not shown in the snippet which slightly reduces readability","tokens":884,"name":"163.jsnp"}
{"score":"45","reasoning":"The snippet is short but confusing; a break appears inside a try without showing the surrounding loop, making control flow unclear. The empty catch block hides exceptions, and the stray closing brace suggests a syntax error. Indentation is decent but lack of comments reduces readability.","tokens":733,"name":"218.jsnp"}
{"score":"85","reasoning":"The class is short and well structured with clear method names and delegation logic. Variable names are descriptive and the setAuthToken method handles null safely. Minor issues are missing field declarations and an extraneous comment marker, but overall the code is easy to follow.","tokens":738,"name":"139.jsnp"}
{"score":"70","reasoning":"The code follows standard Java conventions with clear naming and indentation, making it fairly easy to read. However the logger and string manager reference DeleteAliasAction instead of AliasAction, which can confuse readers, and there are minimal comments. Overall readability is good but not perfect.","tokens":863,"name":"137.jsnp"}
{"score":"45","reasoning":"The snippet is short and uses clear naming and standard imports which aid readability. However it is incomplete, lacking method definitions or documentation beyond an author tag, making it hard to grasp functionality. The presence of annotations suggests intent but without context the code is not easily understood, lowering the overall score","tokens":491,"name":"179.jsnp"}
{"score":"45","reasoning":"The code mixes control flow with a label variable and a switch, making the execution path hard to follow. Repeated selenium calls and magic numbers reduce clarity. Lack of comments and an empty catch block further hurt readability. Overall comprehension is moderate but could be improved with refactoring","tokens":952,"name":"205.jsnp"}
{"score":"80","reasoning":"The snippet is short and uses clear variable names and standard Swing layout calls, making the purpose obvious. It follows typical UI construction patterns. Minor readability issues include inconsistent indentation and a hard coded resource key, but overall it is easy to follow.","tokens":744,"name":"196.jsnp"}
{"score":"30","reasoning":"The snippet is very short and lacks context such as variable declarations and surrounding structure. Naming is unclear and the magic number 6 is unexplained. Formatting is inconsistent and there are no comments to aid understanding. These factors make the code hard to read and comprehend, resulting in a low readability score","tokens":483,"name":"129.jsnp"}
{"score":"70","reasoning":"The code is short and follows a simple flow, making the purpose clear. Variable names are descriptive and the sequence of creating a frame, panel and displaying it is easy to follow. Minor issues such as missing imports, inconsistent indentation and an unfinished class brace reduce readability slightly, preventing a higher score","tokens":790,"name":"123.jsnp"}
{"score":"85","reasoning":"The code is concise and follows standard Java conventions making it easy to read. The else‑if clause clearly checks a value and returns a constant, and the exception provides a helpful message. The getter is straightforward. Minor issues include potential null pointer risk on equals and lack of surrounding context, but overall readability is high","tokens":511,"name":"109.jsnp"}
{"score":"85","reasoning":"The code follows standard JUnit naming conventions and uses clear method names. Variable names are descriptive and the sequence of calls is logical. Formatting is consistent with indentation and spacing. Minor issues include lack of comments and missing closing braces for the last method, but overall readability is high.","tokens":833,"name":"120.jsnp"}
{"score":"70","reasoning":"The snippet consists of three method signatures that are concise and use descriptive names. The use of Liferay specific types may require domain knowledge, but the signatures are straightforward. Lack of comments or documentation reduces clarity for unfamiliar readers, keeping the readability moderate.","tokens":461,"name":"195.jsnp"}
{"score":"70","reasoning":"The code follows a logical structure and uses descriptive method names but contains a typo in a method name raw collection usage and some unconventional naming that slightly reduces clarity overall readability is moderate","tokens":992,"name":"211.jsnp"}
{"score":"85","reasoning":"The method is clearly structured with early null check, logical flow to obtain locale and value, and helpful debug logging. Variable names are descriptive and indentation is consistent. The unsupported methods are explicit. No complex constructs are used, making the code easy to read and understand.","tokens":751,"name":"154.jsnp"}
{"score":"90","reasoning":"The code is well organized with clear class and method names and Javadoc comments that explain purpose. Logic is straightforward: it looks up a curve by name and builds a spec or returns null, and provides an enumeration of names. Minor drawback is use of raw Enumeration without generics, but overall readability is high","tokens":839,"name":"122.jsnp"}
{"score":"78","reasoning":"The interface is concise and well documented with clear Javadoc comments. Method names and parameters are self explanatory, making the purpose easy to grasp. However the use of a raw Map instead of a generic type reduces type safety and clarity. No complex logic is present, so readability is high but not perfect.","tokens":756,"name":"216.jsnp"}
{"score":"70","reasoning":"The code consists of simple getter methods and two string builders. Naming is clear but there is a typo in the class name string, long concatenation makes toString hard to read, magic number 32767 is unexplained and spacing is inconsistent. Overall the logic is simple but formatting reduces readability","tokens":829,"name":"108.jsnp"}
{"score":"85","reasoning":"The code is straightforward and uses clear variable names. The StringBundler section builds a readable toString output in a consistent pattern. Null checks for name and primKey improve safety. The method toEntityModel maps fields directly to a new object, making intent obvious. Minor verbosity prevents a perfect score.","tokens":938,"name":"197.jsnp"}
{"score":"78","reasoning":"The code is short and clear variable name puncher reflects its purpose null check is explicit the final call is readable Minor issues are unnecessary parentheses and extra blank lines but overall easy to follow","tokens":772,"name":"185.jsnp"}
{"score":"80","reasoning":"The code is concise and uses clear naming; the enhanced for loop and method calls are self‑explanatory, making it easy to follow the conversion from model objects to SOAP objects. Minor drawbacks are lack of comments and surrounding context, but overall readability is high.","tokens":470,"name":"171.jsnp"}
