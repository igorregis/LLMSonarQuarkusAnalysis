{"score":"85","reasoning":"The code is concise and well‑structured, using clear method calls to register SQL functions. Naming is descriptive and formatting is consistent, making it easy to follow. Lack of inline comments and limited context about the class purpose slightly reduce clarity, but overall readability is high for experienced Java developers","tokens":620,"name":"21.jsnp"}
{"score":"82","reasoning":"The method is concise and follows a clear pattern of setting configuration properties. Naming is descriptive and the use of super.configure adds context. However the repeated long method calls and string literals reduce readability slightly, and lack of comments or constants for property names makes it harder to maintain. Overall it is easy to understand for experienced developers","tokens":583,"name":"191.jsnp"}
{"score":"70","reasoning":"The test method is straightforward and uses descriptive class names, making its purpose clear. However the repeated getAuditReader().find calls and long variable names reduce brevity, and the assertions could be grouped for better readability. Overall the code is understandable but could be more concise.","tokens":762,"name":"186.jsnp"}
{"score":"70","reasoning":"The test method name is clear and each assertNoLoss call is self explanatory, but the embedded SQL strings are extremely long and complex making them hard to scan quickly. Line breaks improve formatting but the dense queries reduce overall readability, resulting in a moderate score","tokens":988,"name":"101.jsnp"}
{"score":"85","reasoning":"The method is well‑named and parameters are descriptive, making its purpose clear. The control flow is simple with a primary if‑else handling single versus composite keys. Helper calls are concise, though their implementations are not shown, which may require familiarity. Inline comments aid understanding. Overall readability is high.","tokens":698,"name":"112.jsnp"}
{"score":"80","reasoning":"The code is concise and uses a descriptive test method name that explains its purpose The structure follows a clear sequence of opening a session beginning a transaction persisting an entity flushing and rolling back The lack of comments and minimal error handling slightly reduces readability but overall it is easy to understand","tokens":514,"name":"133.jsnp"}
{"score":"92","reasoning":"The method is well documented with a clear Javadoc, uses descriptive names, and consists of a single return statement that constructs a ParameterMemento from the registration fields. The code is concise, follows standard Java conventions and is easy to understand, resulting in a high readability score.","tokens":605,"name":"67.jsnp"}
{"score":"70","reasoning":"The method is straightforward and uses clear variable names, but it repeats the same cleanup code many times and lacks comments. The nested if‑else and try‑catch make the flow a bit dense, and handling of empty string is a no‑op. Refactoring would improve readability, so the score is moderate.","tokens":750,"name":"61.jsnp"}
{"score":"78","reasoning":"The method has clear naming and logical flow, handling defaults and errors explicitly. Use of helper methods improves readability. However, raw Iterator without generics, a lengthy TODO comment, and nested conditionals slightly reduce clarity. Overall the code is understandable but could be cleaner.","tokens":845,"name":"31.jsnp"}
{"score":"78","reasoning":"The test method uses clear variable names and follows a logical sequence of opening sessions, persisting entities, evicting caches, and verifying behavior. However the method is long, repeats similar blocks, lacks comments, and the mapKey usage adds slight confusion, which reduces overall readability and ease of comprehension.","tokens":927,"name":"192.jsnp"}
{"score":"85","reasoning":"The test method is well structured with descriptive names and clear separation of cases. Comments explain the purpose of each block. Assertions are straightforward. The only barrier is domain specific classes that may be unfamiliar, but overall the code is easy to follow","tokens":829,"name":"57.jsnp"}
{"score":"85","reasoning":"The test method is concise and clearly named, using standard JUnit structure. Variable names are simple and the try catch flow is easy to follow. The query string, while long, is readable and demonstrates the purpose of the test. Lack of inline comments and the dense query reduce clarity slightly, but overall the code is easy to understand","tokens":666,"name":"81.jsnp"}
{"score":"70","reasoning":"The method is fairly long and contains several complex conditional checks that repeat instanceof tests, which reduces readability. The use of descriptive method names helps, but the nested if statements and long line lengths make it harder to follow. Overall the code is understandable but could be cleaner, so a score of 70","tokens":1036,"name":"89.jsnp"}
{"score":"78","reasoning":"The code uses clear naming and standard JUnit assertions, making the intent understandable. The annotation list is well formatted and the test steps follow a logical sequence. However the iterator handling and conditional ordering add some cognitive load, and the inline comment is brief. Overall readability is good but not exceptional.","tokens":1040,"name":"181.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and the code follows a consistent naming style. Variable and method calls are self explanatory, making the flow easy to follow. However the duplicated conditional for custom persister adds redundancy and may confuse readers, slightly lowering overall clarity.","tokens":996,"name":"146.jsnp"}
{"score":"68","reasoning":"The code is moderately readable. It uses a clear anonymous Integrator implementation with proper overriding annotations and consistent indentation. However the duplicate integrate methods and a private helper add unnecessary indirection, and the long method chain reduces clarity. Naming is adequate but could be simplified for better comprehension.","tokens":753,"name":"174.jsnp"}
{"score":"65","reasoning":"The test method is clearly structured with separate executor and checker but uses raw types and many casts that reduce clarity. Long assert statements and nested parentheses make it harder to read, though naming is descriptive and flow is logical. Overall readability is moderate","tokens":932,"name":"98.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and logical flow. Final variables and descriptive helper calls make the purpose evident. Comments explain key actions without cluttering code. Some external methods hide details, requiring domain knowledge, but overall readability and comprehension are high.","tokens":910,"name":"170.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical arrange of setup execution and verification steps. Variable names are descriptive and the flow is easy to follow. However the long list of property settings on separate lines makes the code visually dense and the repeated assertions could be grouped for clarity which slightly lowers readability","tokens":1057,"name":"131.jsnp"}
{"score":"65","reasoning":"The code follows a clear procedural flow and uses descriptive variable names for time extraction and bit manipulation, making the overall intent understandable. However the heavy use of decorative print statements, long lines, and external helper methods whose implementations are not shown reduce readability. The bit setting logic is concise but could benefit from comments. Overall readability is moderate.","tokens":1250,"name":"58.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and logical flow. Comments explain the optimistic locking handling and dynamic SQL generation, aiding comprehension. Indentation and spacing are consistent. Some nested conditionals and Hibernate specific concepts add moderate complexity, preventing a higher score","tokens":916,"name":"106.jsnp"}
{"score":"78","reasoning":"The test method is straightforward, uses descriptive names and standard JUnit assertions. The loop and conditional are clear, but the long attribute retrieval lines and embedded comments make it slightly harder to scan. Overall readability is good but could be improved with helper methods or constants.","tokens":902,"name":"90.jsnp"}
{"score":"85","reasoning":"The method is concise and uses clear naming with final parameters and a try finally block that ensures cleanup. The anonymous thread class is straightforward but adds nesting which can reduce readability for some readers. Overall the code is easy to follow and well structured","tokens":638,"name":"73.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear variable names and logical flow. It handles buffered reading first, then falls back to the parent reader, and manages a size limited buffer. The code is concise, uses early returns, and the control flow is easy to follow, resulting in high readability","tokens":847,"name":"151.jsnp"}
{"score":"85","reasoning":"The method follows a standard equals pattern with clear early returns and an instanceof check, uses a cast and compares fields with null‑safe ternary expressions. It is easy to follow but could be simplified using Objects.equals and consistent formatting, so readability is high but not perfect","tokens":559,"name":"60.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names. The arrays xs and ys are defined inline which is readable but could be documented. The call to Geometry.ptClosestTo is self explanatory. Overall the code is easy to follow","tokens":699,"name":"153.jsnp"}
{"score":"78","reasoning":"The method has a clear purpose and uses descriptive variable names which aid comprehension. Annotations are fetched in a straightforward way and the logic for handling inheritance and discriminator settings is well separated. Minor issues include a long ternary expression and slightly dense chaining of calls, but overall the code is readable and maintainable","tokens":766,"name":"28.jsnp"}
{"score":"80","reasoning":"The method is short and clear, with a simple null check and a try catch around reader.close. Variable names are self explanatory. The empty catch block may hide IO errors, and the ignore variable is a minor style issue, but overall the code is easy to understand.","tokens":707,"name":"150.jsnp"}
{"score":"78","reasoning":"The constructor is well formatted and uses clear method calls to register column types and functions, making the intent obvious. Consistent indentation aids readability. However the magic literals like $l, $p,$s and lack of inline comments for mappings reduce clarity, preventing a higher score.","tokens":880,"name":"20.jsnp"}
{"score":"78","reasoning":"The test method is clearly structured with annotations, session handling, and a concise Work implementation. Variable names are descriptive and the try catch finally block is straightforward. The casting and deep coordinator calls add some verbosity but do not obscure intent. Overall the code is easy to follow","tokens":938,"name":"93.jsnp"}
{"score":"70","reasoning":"The test method is lengthy and uses several anonymous inner classes, raw types and casts which reduce readability. However, the naming of variables and the stepwise construction of criteria and HQL queries are clear, and the assertions are straightforward, making the overall flow moderately easy to follow","tokens":999,"name":"99.jsnp"}
{"score":"40","reasoning":"The method packs many null checks and quoted handling into a single long return statement with nested ternary operators. The lack of line breaks and excessive parentheses makes the logic hard to follow, reducing readability. Refactoring into separate boolean variables would improve clarity. Overall comprehension is low.","tokens":722,"name":"36.jsnp"}
{"score":"68","reasoning":"The method is fairly clear with descriptive names but contains deep nesting, multiple casts and long lines that reduce readability. Lack of comments and a commented out line adds minor confusion. Overall it is understandable for experienced developers but could be simplified","tokens":802,"name":"50.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear naming and indentation. It uses straightforward conditional checks and delegates to helper methods, making the logic easy to follow. Minor improvements could include reducing nesting by early returns, but overall readability is high.","tokens":545,"name":"193.jsnp"}
{"score":"45","reasoning":"The method is long and contains many nested conditionals and casts which make the flow hard to follow. Variable names are somewhat descriptive but the mixture of collection handling, listener checks and type specific logic reduces clarity. Overall readability is low making comprehension difficult","tokens":1146,"name":"140.jsnp"}
{"score":"78","reasoning":"The test method is short and follows a clear pattern of loading entities and their revisions then checking expected sets. Variable names are concise but meaningful in context. Use of fluent calls makes flow easy to follow. Lack of comments and generic names like ed1 limit readability slightly, but overall code is understandable","tokens":881,"name":"166.jsnp"}
{"score":"85","reasoning":"The method is well documented with clear Javadoc, uses straightforward conditional checks, and follows common equals implementation patterns. Variable names are self explanatory and the flow is easy to follow. Minor redundancy in the final return could be simplified, but overall readability is high","tokens":655,"name":"39.jsnp"}
{"score":"78","reasoning":"The method is well named and documented, uses clear conditional logic and descriptive variable names. The long chained calls are verbose but follow a consistent pattern, making the intent clear. Overall the code is easy to follow for a Java developer familiar with Hibernate, earning a solid readability score","tokens":854,"name":"103.jsnp"}
{"score":"68","reasoning":"The test is short and uses familiar JUnit and Properties APIs making it easy to follow. Variable names are clear and the assertions are simple. However the repeated password entry and the use of magic string keys reduce clarity, and there is no comment explaining the purpose of the specific properties. Overall readability is decent but not optimal.","tokens":679,"name":"35.jsnp"}
{"score":"55","reasoning":"The test method is fairly long and mixes several anonymous classes which makes the flow hard to follow. Excessive casting and redundant parentheses reduce clarity, and raw List usage hides type information. However the naming is clear and the assertions are straightforward, giving moderate readability.","tokens":1013,"name":"96.jsnp"}
{"score":"78","reasoning":"The method name and parameters are descriptive and the logic follows a clear conditional structure. Variable names are meaningful and indentation is consistent. The use of Model.getFacade() and specific event checks makes intent evident. Minor issues are long line breaks and nested ifs that could be refactored for simplicity.","tokens":900,"name":"47.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and consistent formatting. It demonstrates the use of reflection and annotation reading clearly, but the long chained assertions and lack of comments make it slightly harder to follow. Overall the code is readable for someone familiar with JPA and JUnit, earning a solid mid‑high score.","tokens":988,"name":"135.jsnp"}
{"score":"88","reasoning":"The code is well‑structured and follows standard Java conventions for an equals method. Clear early returns improve readability, and the use of instanceof and field comparisons is straightforward. The Javadoc comment explains purpose and behavior. Minor verbosity in separate if statements could be condensed, but overall it is easy to understand.","tokens":617,"name":"42.jsnp"}
{"score":"85","reasoning":"The test method is well named and uses standard JUnit annotations, making its purpose clear. The query string and expected SQL are formatted with concatenation that remains readable, and the assertion is straightforward. Minor verbosity in string building slightly reduces clarity but overall the code is easy to follow.","tokens":737,"name":"23.jsnp"}
{"score":"85","reasoning":"The method is well‑documented with a clear JavaDoc, uses descriptive variable names and straightforward control flow. Logging and exception handling are explicit. Minor readability hits come from chained map lookups and iterator usage, but overall the code is easy to follow for experienced Java developers","tokens":870,"name":"102.jsnp"}
{"score":"45","reasoning":"The method mixes old collection types without generics, uses vague names like items and path, repeats Designer.theDesigner() calls, and has inconsistent indentation. Lack of comments and magic array size make intent unclear, though the loop logic is simple. Overall readability is moderate to poor.","tokens":883,"name":"46.jsnp"}
{"score":"68","reasoning":"The method is fairly short and follows a clear logical flow, making it moderately easy to understand. Variable names are descriptive, and the null check separates two distinct paths. However readability suffers from missing generic types, an undefined variable, a commented out cast, and mixed indentation which can confuse readers. Overall the code is understandable but could be cleaner","tokens":778,"name":"116.jsnp"}
{"score":"55","reasoning":"The test method is lengthy and mixes many HQL queries, a complex dialect check, and deletions without explanatory comments. While indentation is clear, the dense inline query strings and multiple instanceof checks make the intent hard to grasp, reducing overall readability and comprehension.","tokens":1293,"name":"68.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear purpose, uses descriptive variable names and assertions that convey intent. Annotations explain test conditions. Minor issues include inconsistent indentation and a few long lines, but overall the flow is easy to follow and the code is self explanatory","tokens":976,"name":"136.jsnp"}
{"score":"35","reasoning":"The method is dense and hard to follow. It uses a deep chain of casts and method calls, an anonymous Work class, and silent exception handling, all without comments. The overall intent (dropping and recreating a table) is clear but the code is verbose and low on readability, leading to a low score.","tokens":931,"name":"100.jsnp"}
{"score":"45","reasoning":"The method contains deep nested if‑else blocks, inconsistent indentation and repeated code which makes the flow hard to follow. Variable names are generic and the logic could be simplified with early returns or a switch. Overall readability is moderate but could be improved significantly.","tokens":712,"name":"157.jsnp"}
{"score":"78","reasoning":"The method is clearly named and documented, uses straightforward logic to avoid duplicate loading, and logs each step. Variable names are descriptive. However it mixes raw types, lacks generics, has inconsistent indentation and no handling for a missing bundle, which slightly reduces clarity.","tokens":897,"name":"7.jsnp"}
{"score":"65","reasoning":"The method is well indented and uses a clear try‑finally structure with barrier synchronization and logging. However many sections are commented out, variable names like title(warmup) and opsPerMS are not explained, and the core loop logic is hidden, which reduces overall readability and comprehension.","tokens":944,"name":"172.jsnp"}
{"score":"78","reasoning":"The constructor follows a clear and repetitive pattern of registering SQL functions, making the purpose obvious. Each registration is on its own line, which aids scanning and understanding. The function names are self‑explanatory and the code is well formatted. The long list could be grouped or documented for better maintainability, but overall it is readable and easy to follow.","tokens":1111,"name":"18.jsnp"}
{"score":"78","reasoning":"The method uses clear naming and consistent indentation, making the flow easy to follow. Null checks and branching are straightforward, though nested conditionals add some complexity. The logic for handling composite identifiers is concise but requires knowledge of Hibernate internals. Overall readability is good but not exceptional.","tokens":850,"name":"198.jsnp"}
{"score":"70","reasoning":"The method is a typical JUnit style test with clear naming and straightforward flow. Variable names are descriptive and the code uses standard Java constructs. However the nested anonymous classes and overridden method add some visual clutter, and the long expected string array reduces readability. Overall it is understandable but not exceptionally clean","tokens":716,"name":"12.jsnp"}
{"score":"55","reasoning":"The snippet is short and uses clear naming but the logic is incomplete and always returns null The null check and proxy reassociation are straightforward however the lack of further processing and unexplained return reduce clarity Comments are helpful but the overall flow is not evident leading to moderate readability","tokens":825,"name":"65.jsnp"}
{"score":"85","reasoning":"The method is concise and uses a fluent StringBuilder chain that is easy to follow. Variable names are clear and the null check for region is explicitly documented. Indentation and line breaks improve readability. Minor issues are the inline comment style and lack of final newline but overall comprehension is high","tokens":772,"name":"64.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical structure. It obtains a reader, checks for the presence of a specific annotation and the absence of many others, then validates specific annotation attributes. The code is straightforward for Java developers, though the long list of assertions adds verbosity but does not hinder comprehension","tokens":754,"name":"176.jsnp"}
{"score":"75","reasoning":"The method is short and follows a clear sequence of obtaining an EntityManager, starting a transaction, creating and persisting a Country object, and committing the transaction. Annotations make its purpose evident. Minor issues are missing imports, undeclared variables and a magic number, but overall readability is good.","tokens":916,"name":"168.jsnp"}
{"score":"78","reasoning":"The method is concise and follows standard JUnit and Hibernate patterns. Annotations, variable names and the query are clear. Minor drawbacks are magic numbers for pagination and a commented out print line, but overall the code is easy to read and understand","tokens":775,"name":"92.jsnp"}
{"score":"78","reasoning":"The method is well‑structured with clear naming and consistent indentation. Use of final variables and descriptive log messages aids comprehension. Conditional logic is straightforward, and error handling provides informative messages. Some domain‑specific terms (e.g., CollectionReference, ExpandingFetchSource) may require context, slightly lowering overall readability.","tokens":711,"name":"183.jsnp"}
{"score":"85","reasoning":"The method is well structured with clear variable names and logical flow. Preconditions are checked early, and a StringBuilder accumulates text efficiently. The switch cleanly separates handling of character data, entity references, and ignored events. Minor concerns are the loop condition that relies on end‑document and lack of inline comments, but overall the code is easy to follow.","tokens":1136,"name":"152.jsnp"}
{"score":"68","reasoning":"The method name and purpose are clear and the code is well indented making it easy to follow. However the use of a raw Map type reduces type safety and readability, and the TODO comment indicates incomplete functionality. The long constructor call with many parameters can be hard to parse without named arguments. Overall the snippet is moderately readable but could be improved with generics and documentation.","tokens":555,"name":"55.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear steps and descriptive names, making the flow easy to follow. However long lines, raw List usage, magic revision numbers and lack of comments reduce readability. Overall the code is moderately readable but could be cleaner.","tokens":944,"name":"167.jsnp"}
{"score":"85","reasoning":"The test is well structured with clear setup, execution, and cleanup phases. Variable names are descriptive and the flow follows typical Hibernate session usage. Inline comments explain the purpose of the test, though the very long method name adds visual clutter. Overall the code is easy to follow.","tokens":972,"name":"175.jsnp"}
{"score":"80","reasoning":"The test method is straightforward and uses clear variable names. Each case follows the same pattern making it easy to follow. Repetition could be reduced with a data driven loop but readability is still good. Overall the code is well formatted and understandable for a developer familiar with JUnit","tokens":953,"name":"26.jsnp"}
{"score":"85","reasoning":"The method name is descriptive and follows a clear naming convention, indicating its purpose. The code is short, well‑structured and uses helper methods that abstract complexity, making the test easy to follow. A single inline comment explains the intent of the first call. Overall readability is high, though the snippet lacks inline documentation for the later calls, preventing a perfect score.","tokens":493,"name":"187.jsnp"}
{"score":"78","reasoning":"The method is short and its purpose is clear: it resets usage state for two cache regions by notifying both local and remote listeners. Variable names are concise but could be more descriptive. The repeated calls could be refactored into a loop for better maintainability. Overall readability is good but not optimal.","tokens":618,"name":"190.jsnp"}
{"score":"70","reasoning":"The method is a JUnit test that performs a series of transactional updates on an entity. Annotations, variable names and entity manager usage are clear, but the repeated transaction blocks and find calls make it verbose. Adding helper methods would improve readability, but the logic is easy to follow.","tokens":1003,"name":"188.jsnp"}
{"score":"78","reasoning":"The method is well indented and uses descriptive names for variables and helper methods. The sequential else if structure makes the decision flow clear, though the many conditions add some complexity. Comments in the source aid understanding, but the logic remains easy to follow for someone familiar with the domain","tokens":1053,"name":"107.jsnp"}
{"score":"70","reasoning":"The method is concise and uses a clear naming convention for test cases. Each parse call is on a separate line which aids readability, though the long query strings reduce clarity. The commented out examples are helpful for context but add visual clutter. Overall the structure is simple but the dense strings make quick comprehension harder","tokens":824,"name":"85.jsnp"}
{"score":"85","reasoning":"The method is well documented with clear Javadoc, descriptive parameter and variable names, and straightforward control flow. It uses helper methods for complex tasks, making the core logic easy to follow. Minor improvements could include breaking long lines, but overall readability is high","tokens":854,"name":"126.jsnp"}
{"score":"85","reasoning":"The code is concise and well named making its purpose clear. Method and variable names describe intent, and the assertions are straightforward. Use of helper methods keeps the test readable. Minor lack of comments and reliance on external classes may require context but overall readability is high","tokens":526,"name":"159.jsnp"}
{"score":"78","reasoning":"The method is short and uses descriptive names, making the flow easy to follow. It checks a specific property name, casts the new value to Project, and updates title, critiquing root and target. Minor detractors are the commented out lines and a nested if, but overall readability is good.","tokens":685,"name":"11.jsnp"}
{"score":"85","reasoning":"The constructor is concise and follows standard Java conventions. Method names are descriptive, making the purpose of each call clear. No complex logic is present, aiding comprehension. Lack of inline comments or documentation about the registration methods slightly reduces readability, but overall the code is easy to understand.","tokens":519,"name":"19.jsnp"}
{"score":"78","reasoning":"The test method is clearly organized with a descriptive name and straightforward control flow. Variable names are meaningful and the try-catch-finally structure is easy to follow. The long chained calls to obtain a PreparedStatement reduce readability slightly and the lack of comments requires some familiarity with the API, but overall an experienced Java reader can understand it quickly.","tokens":799,"name":"145.jsnp"}
{"score":"78","reasoning":"The test method is well named and uses straightforward JUnit assertions, making the intent clear. Repeated translator creation and similar assert blocks are easy to follow, though the long lines and lack of comments add minor clutter. Overall the code is readable and comprehensible for a developer familiar with the API.","tokens":869,"name":"88.jsnp"}
{"score":"78","reasoning":"The method is short and its purpose is clear: set a lazy property value, optionally update a snapshot, and return whether the field matches the lazy property name. Variable names are descriptive, but reliance on external arrays and indices makes it slightly harder to follow without surrounding context. Overall readability is good for experienced developers.","tokens":775,"name":"104.jsnp"}
{"score":"78","reasoning":"The method is fairly readable with clear variable names and straightforward control flow. It validates parameters, creates an instance via reflection, and injects fields using annotations. However, it throws generic Exceptions, lacks comments, and uses reflection which can be hard to follow for newcomers, reducing overall clarity.","tokens":690,"name":"13.jsnp"}
{"score":"78","reasoning":"The method is short and well structured with clear descriptive names. Consistent indentation and logical grouping of addNotationProvider calls aid readability. A commented out line adds minor noise and long parameter lists slightly reduce clarity, but overall the code is easy to follow","tokens":793,"name":"5.jsnp"}
{"score":"78","reasoning":"The test method is straightforward and uses descriptive names for entities and variables which aids comprehension. However the repeated session boilerplate, raw collection types, and lack of generics add noise. The long method could be split into helper functions for setup and cleanup, improving readability. Overall the code is moderately readable but could be cleaner","tokens":771,"name":"82.jsnp"}
{"score":"78","reasoning":"The test method is well structured with descriptive names and clear assertions. The sequence of annotation checks followed by detailed verification of AttributeOverride values is logical. However the long series of repetitive assert statements makes it verbose and slightly harder to scan quickly. Overall readability is good but could be improved with helper methods","tokens":1051,"name":"177.jsnp"}
{"score":"78","reasoning":"The method is well documented with a clear Javadoc header and descriptive parameter and exception notes. The implementation follows a simple pattern: defaultReadObject followed by a series of SerialUtilities.readPaint calls for each paint field. The repetitive structure is easy to follow but the long list of similar lines slightly reduces readability, leading to a solid but not perfect score","tokens":1012,"name":"3.jsnp"}
{"score":"78","reasoning":"The method is fairly clear with descriptive names and straightforward loops and conditionals. Comments explain the intent and the logic is easy to follow. However casting without null checks and long chained method calls reduce clarity, and some variable names could be more explicit. Overall readability is good but not exceptional","tokens":837,"name":"51.jsnp"}
{"score":"70","reasoning":"The test method is fairly clear in its intent, using descriptive variable names and standard Hibernate session handling. However indentation is inconsistent, comments are embedded in code, and error handling is missing, which reduces readability. The flow is linear but could be cleaner with helper methods","tokens":983,"name":"72.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical flow, making it fairly easy to follow. Use of descriptive variables and assertions aids comprehension. However the long chained calls and lack of inline comments reduce readability, and the magic index 0 could be clearer. Overall readability is good but not exceptional.","tokens":624,"name":"178.jsnp"}
{"score":"78","reasoning":"The test method is well structured and uses descriptive names, making its intent clear. However the long sequence of similar assertions and repeated iterator handling adds visual noise and makes it harder to follow quickly. The code follows standard JUnit style but could be refactored for brevity, so readability is good but not excellent","tokens":1078,"name":"180.jsnp"}
{"score":"70","reasoning":"The method is concise and well indented with descriptive names for the method and variables which aids readability. However the heavy use of casts and domain specific types such as QueryableCollection OuterJoinLoadable and CompositeType adds cognitive load and may confuse readers unfamiliar with the API. Lack of comments also reduces clarity, resulting in a moderate score.","tokens":706,"name":"148.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear naming and logical flow. It calls the superclass, checks annotation presence, validates indices, and reports errors for out‑of‑range, unused or duplicate parameters. Some lines are long and nested, but overall the code is easy to follow","tokens":877,"name":"14.jsnp"}
{"score":"78","reasoning":"The constructor is well structured with clear method calls and logical grouping of UI elements. Variable names are descriptive and the flow is easy to follow. Minor issues include a typo in label keys and some long inline object creations that could be extracted for clarity, but overall the code is readable and understandable","tokens":712,"name":"158.jsnp"}
{"score":"70","reasoning":"The test method has a clear purpose and a descriptive name but the single assertion uses a long chained call with casting that makes it hard to follow. Breaking the expression into intermediate variables would improve readability. Overall the code is moderately readable but could be clearer","tokens":671,"name":"199.jsnp"}
{"score":"78","reasoning":"The method is short and uses early returns which aid readability. Variable names are descriptive and the logic follows a clear sequence of checks. However the long chained calls, suppressed warning annotation and casting reduce clarity slightly. Overall it is fairly easy to understand","tokens":802,"name":"111.jsnp"}
{"score":"70","reasoning":"The test method is fairly long with nested anonymous classes and many casts which reduces clarity. Variable names are clear and the flow of creating criteria and checking results is logical, but excessive parentheses and inline comments make it harder to read for newcomers","tokens":979,"name":"97.jsnp"}
{"score":"70","reasoning":"The method is short and its intent is clear: it builds an array of UML action objects. Using a literal array makes the flow easy to follow, but the use of raw Object type, many null placeholders and lack of comments reduce clarity. A typed collection or named constants would improve readability.","tokens":695,"name":"156.jsnp"}
{"score":"78","reasoning":"The method is short and clearly structured with separate sections for each revision, making the flow easy to follow. Use of descriptive variable names and consistent transaction handling aids comprehension. However repeated transaction boilerplate could be abstracted, and inline comments are minimal. Overall readability is good but not optimal.","tokens":976,"name":"189.jsnp"}
{"score":"55","reasoning":"The method is short and well indented but uses cryptic names like _loop119 and _tokenSet_6 which are not explained, making it hard for readers unfamiliar with the parser framework. Lack of comments and unclear purpose of the token set reduce readability, though the control flow is simple.","tokens":584,"name":"115.jsnp"}
{"score":"70","reasoning":"The method name and helper calls are descriptive and the inline comment explains the purpose which aids comprehension However the method is long contains many sequential calls and a nested loop mixing several concerns making it harder to follow Splitting into smaller methods would improve readability","tokens":1233,"name":"149.jsnp"}
{"score":"78","reasoning":"The method is well documented and uses clear variable names. The use of a read lock and atomic variables is explained. However the dense for loops with compareAndSet are hard to read and could be refactored. Overall readability is good but not excellent","tokens":821,"name":"62.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc header and uses descriptive variable names. The logic is straightforward with nested loops that accumulate positive and negative sums per category. Indentation and spacing are consistent, making the flow easy to follow. Minor improvements could include extracting the inner loop into a helper method, but overall readability is high","tokens":976,"name":"41.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive final variables making the purpose obvious; the expected string is built with concatenation which is readable but the long literals make the line a bit dense; overall the structure and assertions are straightforward and easy to follow","tokens":841,"name":"24.jsnp"}
{"score":"55","reasoning":"The method is straightforward but suffers from excessive repetition, raw types and many similar if statements. The intent is clear but readability is reduced by verbose type checks and lack of abstraction. A refactor using a type‑to‑action map would improve clarity. Overall moderate comprehension.","tokens":951,"name":"119.jsnp"}
{"score":"80","reasoning":"The method is clear and concise, using a HashSet to collect string constants and returning an unmodifiable view. Variable naming is appropriate and the sequence of adds is easy to follow. However it could be simplified with Set.of in newer Java versions, and the explicit generic type on HashSet is redundant, slightly lowering the score.","tokens":581,"name":"16.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names, making it easy to follow. The use of a constant prime and null checks improves safety. However the order of operations deviates from common hashCode patterns, and the result calculation could be clearer by multiplying before adding each field. Overall readability is good but not optimal.","tokens":478,"name":"141.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming and logical flow. Annotations are verbose but self explanatory, and the code uses straightforward object creation, persistence, and assertions. Minor issues are the dense annotation list and a console print, but overall readability is high","tokens":1000,"name":"138.jsnp"}
{"score":"78","reasoning":"The test method name is descriptive and follows standard JUnit conventions. The use of thrown.expectMessage clearly shows the expected exception message. The try catch block is simple though the empty catch body could be confusing. The code relies on external helper methods whose purpose is not obvious, slightly reducing readability","tokens":704,"name":"160.jsnp"}
{"score":"65","reasoning":"The method is moderately readable but suffers from raw List usage, long lines, nested ternary operators and unclear variable names. Indentation is clear and logic is linear, yet the lack of generics and extensive inline conditions reduce clarity, making maintenance harder","tokens":934,"name":"34.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment, uses descriptive variable names and follows standard Java listener pattern. Indentation and spacing make the flow easy to follow. The lazy creation of the event is clear. Minor complexity comes from the reverse loop over the listener array, but overall the code is straightforward and readable","tokens":836,"name":"9.jsnp"}
{"score":"85","reasoning":"The method is short and self explanatory, uses clear variable names and simple if statements to detect line break characters. The Javadoc comment explains the purpose. Formatting is consistent and indentation is proper. Minor issues are the generic variable names hasLf and hasCr which could be more descriptive, but overall readability is high","tokens":701,"name":"6.jsnp"}
{"score":"70","reasoning":"The method is clearly documented and uses straightforward variable names, but the series of manual shift operations is verbose and harder to follow than a loop or ByteBuffer approach. The repeated pattern is evident, yet the code could be more concise, which slightly lowers readability","tokens":750,"name":"113.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming, inline comments, and straightforward logic. The inner Verifier class encapsulates the tree search, making the test assertions easy to read. Indentation and spacing are consistent, and the use of constants improves clarity. Minor issue is using Stack as a queue which may slightly confuse readers but does not hinder overall comprehension","tokens":925,"name":"87.jsnp"}
{"score":"78","reasoning":"The method name clearly describes its purpose and variable names are descriptive. The flow is simple with null checks and early returns. Minor readability issues are inconsistent indentation, a long string concatenation line, and generic type casting that add some visual noise, but overall the code is easy to follow.","tokens":812,"name":"125.jsnp"}
{"score":"70","reasoning":"The method name clearly states its purpose and the loop structure is simple, but the repeated long getter calls make the inner call hard to read. Storing the arrays in local variables would improve clarity. Indentation is proper and exception handling is explicit, resulting in moderate readability.","tokens":859,"name":"105.jsnp"}
{"score":"55","reasoning":"The method contains many nested if statements and repeated type checks which makes it hard to follow. Casting and multiple event type ranges add verbosity. While naming is clear, the logic could be simplified with polymorphism or a dispatch table. Overall readability is moderate but could be improved","tokens":860,"name":"43.jsnp"}
{"score":"70","reasoning":"The method is concise and uses clear naming. The anonymous subclass with overridden methods is readable but the nesting adds some complexity. Indentation is good, but lack of comments and inline explanations makes it harder for newcomers. Overall readability is moderate.","tokens":766,"name":"132.jsnp"}
{"score":"80","reasoning":"The method is well documented with Javadoc, uses clear variable names and consistent indentation. The flow is straightforward: retrieve element, return its value or null, and handle cache exceptions with specific handling for NonStopCacheException. Minor style issues such as an unnecessary else after a return and a generic catch could be refined, but overall readability is high","tokens":783,"name":"164.jsnp"}
{"score":"78","reasoning":"The test method is well‑named and uses clear variable names, making its purpose easy to follow. Assertions are straightforward and the use of helper methods improves readability. However the long constructor call and lack of inline comments make it slightly harder to parse quickly, preventing a higher score.","tokens":758,"name":"142.jsnp"}
{"score":"92","reasoning":"The constructor is concise and well structured, using clear method calls to map SQL types to database types. Indentation and naming are consistent, making the purpose obvious. The only minor drawback is the absence of inline comments explaining specific mappings, but overall readability is high","tokens":794,"name":"25.jsnp"}
{"score":"85","reasoning":"The method is well documented, uses clear variable names and follows a logical flow. The try‑catch block handles SQL errors cleanly and helper methods make the purpose of each step obvious. Conditional logic for limit handling and type discovery adds some complexity but remains readable. Overall the code is easy to understand.","tokens":834,"name":"33.jsnp"}
{"score":"70","reasoning":"The code uses descriptive names and logical flow, but deep nesting with an anonymous inner class and multiple conditionals makes it harder to follow. Lack of comments and a long method body reduce clarity, though indentation is consistent and variable names are clear.","tokens":784,"name":"173.jsnp"}
{"score":"85","reasoning":"The method is concise and uses descriptive names for variables and parameters, making the flow easy to follow. Generic type handling and JAXB usage are clear. Minor issues are lack of resource closing and limited error handling, but overall readability is high","tokens":699,"name":"194.jsnp"}
{"score":"78","reasoning":"The method is clearly named and parameters are descriptive. Control flow is straightforward with early return on user cancellation. Variable names are meaningful and indentation is consistent. Use of try‑finally ensures resource cleanup, though modern try‑with‑resources would be clearer. Minor issues include a magic default scale value and a long line for the confirm dialog, but overall readability is good","tokens":615,"name":"49.jsnp"}
{"score":"55","reasoning":"The method is short but uses unclear variable names and duplicated logic for two tables. It mixes UI handling with business logic and uses raw collections which reduces clarity. Indentation is inconsistent and comments are missing. Overall readability is moderate leading to a score around 55.","tokens":846,"name":"10.jsnp"}
{"score":"70","reasoning":"The method is short and its purpose is clear from the name. Null check and try catch are straightforward. However the deep cast and chained calls reduce readability and the catch of Throwable with an empty block is a bad practice, which lowers the overall score.","tokens":577,"name":"95.jsnp"}
{"score":"85","reasoning":"The method is concise and uses descriptive names, making its purpose clear. Boolean logic is straightforward though a bit dense, and the flow is easy to follow. Minor improvement could be breaking the complex condition into named variables for readability. Overall the code is readable and maintainable.","tokens":901,"name":"184.jsnp"}
{"score":"45","reasoning":"The method is long and repetitive, making it hard to follow. Each line repeats the same pattern with different boolean arrays, which could be extracted into a loop or helper. Naming is clear but the dense inline array literals reduce readability. Overall the code is functional but not easy to comprehend quickly.","tokens":788,"name":"59.jsnp"}
{"score":"78","reasoning":"The method has a clear Javadoc and inline comments that explain its purpose and the double iteration issue. Variable names are descriptive and the try‑finally structure is logical. The generic bounds add some complexity and the nested try‑finally may be confusing for beginners, but overall the code is readable and easy to follow.","tokens":906,"name":"110.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear variable names and logical sections. The use of a loop to verify sequence values and explicit assertions makes intent obvious. Comments explain the scenarios, and the code follows standard JUnit style, making it easy to follow for developers familiar with testing.","tokens":983,"name":"56.jsnp"}
{"score":"85","reasoning":"The method is concise and follows a common pattern for equals implementations. It uses early returns, clear type check, and field by field comparison, making the logic easy to follow. Variable names are descriptive and the Javadoc explains the contract. Minor improvements could include using Objects.equals or handling floating point precision, but overall readability is high.","tokens":729,"name":"114.jsnp"}
{"score":"70","reasoning":"The method is well commented and uses descriptive variable names making the intent clear. However it repeats almost identical loops which could be extracted, uses raw Vector and casts which hurt readability, and contains a magic offset value. These issues lower the overall ease of comprehension.","tokens":919,"name":"121.jsnp"}
{"score":"35","reasoning":"The method is very long and mixes primitive and object comparisons with inconsistent use of \u003d\u003d and .equals. It contains commented out code fragments and many chained logical operators that make the flow hard to follow. Variable names are short and the array handling is duplicated. Overall the code is difficult to read and understand resulting in a low score","tokens":1326,"name":"74.jsnp"}
{"score":"78","reasoning":"The test method is well named and follows a clear sequence of steps, making the intent easy to follow. Variable names are descriptive and the use of session and filters is straightforward. Minor issues are the raw List type, magic positional parameter index and lack of generics which slightly reduce clarity. Overall readability is good.","tokens":1015,"name":"91.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear setup, save, query and cleanup phases. Variable names are descriptive and the use of Hibernate Session is straightforward. However the inline comments and TODO hint at incomplete behavior, and the purpose of several queries is not obvious, slightly reducing overall clarity.","tokens":1013,"name":"80.jsnp"}
{"score":"85","reasoning":"The method follows a conventional equals implementation with clear structure and indentation. It checks identity, delegates to super, verifies class, casts, and compares a single field with null safety. The naming is descriptive and the logic is straightforward, making it easy to understand. Minor improvements like using Objects.equals could raise readability further.","tokens":594,"name":"169.jsnp"}
{"score":"70","reasoning":"The method name clearly describes its purpose and variable names are meaningful. The logic is straightforward with early returns and simple conditionals. However the long name, nested ifs, and reliance on external context like metadata reduce clarity. Minor formatting issues also affect readability","tokens":857,"name":"147.jsnp"}
{"score":"78","reasoning":"The constructor is well structured with clear variable names and logical ordering of UI setup steps. Formatting is consistent and the code is easy to follow. Minor issues are a repeated setAutoResizeMode call and lack of inline comments for some settings, but overall readability is high.","tokens":835,"name":"118.jsnp"}
{"score":"85","reasoning":"The method is well named and uses clear variable names. Comments explain the JPA spec rules. The two loops are straightforward and the logic is simple. Minor issues are inconsistent indentation and extra spaces, but they do not hinder understanding. Overall the code is easy to follow.","tokens":1066,"name":"27.jsnp"}
{"score":"70","reasoning":"The method name and variable names are clear but the nested try-catch blocks and reflection make it dense. The whimsical comment adds noise. Handling of constructor parameters is a bit opaque. An experienced Java reader can follow it, but readability would improve with helper methods and simpler error handling.","tokens":988,"name":"2.jsnp"}
{"score":"85","reasoning":"The method name clearly describes its purpose and the parameter is well‑named. Each call to registerStrategyImplementor is formatted consistently, making the flow easy to follow. However the repeated pattern could be abstracted into a helper or loop to reduce duplication, which would improve maintainability. Overall the code is readable but not optimal for brevity.","tokens":577,"name":"171.jsnp"}
{"score":"70","reasoning":"The code is straightforward Java using Hibernate, with clear variable names and logical sequence of creating entities, saving them, and committing. However readability suffers from repetitive manual object creation and saves, lack of comments, and non‑sequential ordering which could be simplified with loops or collections. Overall moderate clarity.","tokens":771,"name":"76.jsnp"}
{"score":"70","reasoning":"The method is short and uses clear naming with a single responsibility. The repeated parse calls are easy to follow, but the test strings contain many overloaded keywords making them hard to parse mentally. Comments explain intent but the heavy use of keywordlike identifiers reduces overall clarity","tokens":801,"name":"86.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical sections. Annotations and comments explain purpose. Session handling and entity creation are straightforward. Minor verbosity and nested comments slightly reduce readability but overall easy to follow","tokens":1088,"name":"78.jsnp"}
{"score":"78","reasoning":"The method has clear naming, straightforward loops over super classes, methods and fields, and uses helper functions for sorting and adding to annotation lists. Indentation and structure are clean, making it easy to follow. Minor verbosity and reliance on external utilities slightly reduce clarity but overall readability is good","tokens":745,"name":"52.jsnp"}
{"score":"70","reasoning":"The test method follows a clear arrange act assert pattern with descriptive names and explicit transaction handling. The try catch block shows the expected exception clearly. The long chained calls and use of an anonymous inner class add verbosity and reduce readability, a lambda would simplify it. Overall readability is good but not excellent","tokens":991,"name":"94.jsnp"}
{"score":"85","reasoning":"The method follows a common pattern for equals with early returns and clear null checks. Variable names are descriptive and the logic is straightforward. Use of ternary operators for null handling is concise but may be slightly harder for beginners. Overall readability is good, though using Objects.equals could improve clarity.","tokens":525,"name":"70.jsnp"}
{"score":"85","reasoning":"The snippet is well formatted and uses clear naming. The comment explains the purpose, the @Test annotation and method signature are standard. The anonymous subclass overrides a single method in a concise way, making the intent obvious. No complex logic or obscure constructs are present, resulting in high readability.","tokens":592,"name":"53.jsnp"}
{"score":"85","reasoning":"The snippet is short and self contained it uses standard JUnit classes the variable names are clear the anonymous listener is easy to follow the flow from creating the core to adding the listener then running the test and asserting the failure count is logical however the use of an anonymous inner class could be replaced with a lambda for brevity and the method name is long but descriptive overall readability is high","tokens":615,"name":"124.jsnp"}
{"score":"78","reasoning":"The method name and parameters are clear and the logic follows a straightforward pattern of early returns for non entity types. The use of constants makes intent obvious, but the nested if with multiple conditions and inline comments adds some visual clutter. Overall the code is readable but could be simplified for better flow","tokens":823,"name":"29.jsnp"}
{"score":"78","reasoning":"The method is well indented and uses descriptive names which aid comprehension. The nested calls are a bit long but follow a consistent pattern and the conditional handling of many-to-many is clear. Overall the code is readable for developers familiar with the domain, though the chaining could be broken into variables for extra clarity","tokens":812,"name":"182.jsnp"}
{"score":"78","reasoning":"The test method is clearly named and follows a standard try‑catch‑finally pattern, making the flow easy to follow. Variable names are descriptive and logging aids debugging. However the use of raw Iterator, long inline assert messages, and lack of generics reduce readability, and formatting is slightly inconsistent. Overall readability is good but not excellent.","tokens":947,"name":"137.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and logical flow. Annotations and session handling are straightforward. The inner AbstractWork class adds some nesting but is simple. Minor readability issues include a long line for SQL construction and dialect specific checks, but overall it is easy to follow","tokens":858,"name":"69.jsnp"}
{"score":"80","reasoning":"The test method name clearly states its purpose and the @Test annotation makes its role obvious. Indentation is consistent and the assertEquals call is straightforward. The nested calls are a bit deep which slightly reduces readability, but the use of descriptive helper methods keeps the intent clear. Overall the code is easy to follow","tokens":667,"name":"165.jsnp"}
{"score":"78","reasoning":"The test method is well named and includes a brief comment explaining the context. Each SyntaxChecker call is on its own line, making the HQL queries easy to scan. The repetitive pattern could be refactored into a loop or helper, but overall the code is straightforward and readable for someone familiar with JUnit and Hibernate.","tokens":1199,"name":"79.jsnp"}
{"score":"78","reasoning":"The constructor clearly initializes three collections based on values from the readerCollector. Use of ternary operators keeps it concise but results in long lines that are hard to scan. Generic type declarations are explicit which aids understanding. Overall naming is good but formatting could be improved for readability","tokens":627,"name":"196.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and uses descriptive variables, making its purpose obvious. The flow of setting up a timeout, invoking evaluate, and checking the exception is straightforward. The loop that inspects stack trace elements is simple and well named. Minor verbosity and nested assertions keep the code readable but not overly complex","tokens":1046,"name":"161.jsnp"}
{"score":"78","reasoning":"The constructor is concise and clearly delegates to a more detailed overload. Use of constants for dimensions improves clarity. Inline comments on boolean flags help understand purpose. However the long parameter list makes it harder to read and maintain, and the comments are not part of the signature. Overall readability is good but could be better","tokens":695,"name":"4.jsnp"}
{"score":"80","reasoning":"The method name clearly describes the test purpose and the code follows a logical sequence of setup, action, verification and cleanup. Variable names are meaningful and the flow is easy to follow despite some Hibernate specific calls. Comments aid understanding but are not needed for basic comprehension","tokens":892,"name":"75.jsnp"}
{"score":"85","reasoning":"The test method is well structured with clear naming, logical flow, and concise comments explaining the JPA mapping rule. Use of whitespace and line breaks aids readability. Minor drawbacks are long comment block and nested method calls that slightly reduce clarity, but overall easy to follow","tokens":978,"name":"134.jsnp"}
{"score":"55","reasoning":"The method contains deep nesting and several conditional branches which makes the flow hard to follow Variable names are short and the purpose of some checks is not obvious Repeated calls to Model getFacade add verbosity The second part iterates over layer contents with a cast that could be clearer Overall readability is moderate but could be improved with refactoring","tokens":990,"name":"155.jsnp"}
{"score":"60","reasoning":"The method performs many null assignments and collection removals followed by merging and deleting entities. While each operation is simple, the long sequence of repetitive statements makes the flow hard to follow. Lack of comments or helper methods reduces clarity. Overall readability is moderate but could be improved with abstraction.","tokens":946,"name":"200.jsnp"}
{"score":"78","reasoning":"The constructor clearly creates listener instances and registers them with the event registry using descriptive variable names. The flow is logical and easy to follow. However the inline cast and chained calls make it slightly dense and lack comments or spacing that could improve clarity. Overall readability is good but not exceptional.","tokens":768,"name":"139.jsnp"}
{"score":"65","reasoning":"The test method is a single block that creates data, runs many similar HQL queries and cleans up. Variable names are clear but the code uses raw List, long query strings and repeated patterns without comments or helper methods. The flow is understandable but the verbosity and lack of formatting reduce readability.","tokens":1249,"name":"83.jsnp"}
{"score":"85","reasoning":"The test method is clearly named and follows a logical sequence of setting properties, creating the factory, building regions, and asserting configuration values. Variable names are descriptive and the use of try‑finally ensures cleanup. The only drawback is the repetitive property setup and lack of helper methods, but overall the code is easy to follow","tokens":1028,"name":"130.jsnp"}
{"score":"78","reasoning":"The test is fairly clear: it sets up data, runs a dialect specific SQL query and checks the result. Variable names are meaningful and the flow follows typical Hibernate session usage. However the use of raw List, long inline SQL strings, lack of generics and minimal comments reduce readability.","tokens":1086,"name":"71.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and logical steps. Use of JPA Criteria API is straightforward but the fluent API makes lines long and generic casts add noise. A single comment helps but overall a developer familiar with JPA can follow easily","tokens":764,"name":"163.jsnp"}
{"score":"70","reasoning":"The method is moderately readable but suffers from deep nesting and repeated calls to normalizer making it verbose. Variable names are clear and intent is understandable, yet the flow could be simplified by extracting helper methods. Overall comprehension is decent but could be improved with less nesting and clearer separation of concerns","tokens":647,"name":"30.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc comment and uses descriptive variable names. The code follows a consistent pattern for serializing fields, making it easy to follow. Minor improvements could include grouping related writes or adding inline comments, but overall readability is high.","tokens":584,"name":"38.jsnp"}
{"score":"68","reasoning":"The method is straightforward and uses descriptive names like filename and inSection making the flow easy to follow. However it lacks comments, uses string concatenation inside a loop instead of a StringBuilder, and does not use try‑with‑resources for automatic closing. These issues reduce readability and maintainability.","tokens":668,"name":"48.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear logging and descriptive variable names. Comments explain the purpose of each block. The flow of clearing caches, iterating entries, and handling removal or recreation is logical. Minor complexity arises from the IdentityMap usage but overall the code is easy to follow.","tokens":992,"name":"66.jsnp"}
{"score":"78","reasoning":"The method is short and uses clear variable names and a straightforward switch to map SQL state codes to constraint names. The extraction logic is encapsulated in a helper method, making the main flow easy to follow. However the use of raw numeric SQL state codes without named constants and minimal comments reduces readability.","tokens":852,"name":"22.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear naming and consistent use of constants, making the intent easy to follow. The sequence of hint settings and assertions is logical. However the cast to internal Hibernate classes adds some complexity and the repeated assertions increase length, slightly reducing readability","tokens":1085,"name":"162.jsnp"}
{"score":"78","reasoning":"The method is concise and uses an anonymous inner class to run a test in a separate thread which is clear, variable names are descriptive and the finally block ensures cleanup, however the inline comment and lack of explicit thread naming reduce readability slightly","tokens":719,"name":"1.jsnp"}
{"score":"78","reasoning":"The test method is well structured with clear setup, execution and cleanup phases. Variable names are descriptive and the flow is easy to follow. Use of raw List and an empty IN clause reduces type safety and may confuse readers, but overall the code is readable.","tokens":713,"name":"77.jsnp"}
{"score":"85","reasoning":"The method is well documented with Javadoc, uses clear naming, and simple conditional logic that is easy to follow. It handles null and POJO mode together, MAP mode, and throws a descriptive exception for unknown modes. The temporary TODO comment does not hinder understanding. Overall readability is high","tokens":767,"name":"32.jsnp"}
{"score":"70","reasoning":"The method is short and its purpose is clear, but it uses raw types, lacks generics and comments, and returns null instead of an empty set. The long chain of addAll calls makes the flow dense, and formatting could be improved. Overall readability is moderate.","tokens":737,"name":"123.jsnp"}
{"score":"92","reasoning":"The method is concise and self explanatory with clear naming for the method, parameters and local variable. Proper indentation and line breaks improve readability. It simply creates a strategy object and delegates to a builder, making the flow easy to follow. No complex logic is present","tokens":738,"name":"143.jsnp"}
{"score":"85","reasoning":"The method is straightforward and uses descriptive names like walker and details, making its purpose clear. The repeated System.out.println calls are easy to follow, though they could be consolidated for brevity. The use of StringHelper.join is appropriate for joining collections. Overall the code is well‑spaced and readable, earning a high score.","tokens":580,"name":"144.jsnp"}
{"score":"78","reasoning":"The test method follows a logical sequence and uses descriptive names which aids comprehension. However the heavy use of casts, chained calls and repeated assertions makes it dense. Implicit side effects like session.getFlushMode triggering coordinator actions are not obvious, reducing readability for newcomers. Overall a competent but moderately complex snippet","tokens":828,"name":"127.jsnp"}
{"score":"55","reasoning":"The method has a clear Javadoc header and a logical flow, but readability suffers from inconsistent indentation, raw types, and vague variable names. The use of Enumeration and unchecked casts makes the code harder to follow. Lack of generics and mixed spacing reduce clarity, though the overall algorithm is understandable.","tokens":968,"name":"44.jsnp"}
{"score":"78","reasoning":"The test method is concise and uses descriptive names, making the flow easy to follow. Assertions clearly show expected transaction state before and after begin. Session creation uses a fluent API which is readable but slightly dense without comments. Overall the code is well structured and understandable, earning a high readability score","tokens":738,"name":"128.jsnp"}
{"score":"78","reasoning":"The method is well indented and uses clear naming for token handling, making the flow easy to follow. The switch covers all hex digit cases explicitly, which aids understanding. However the boilerplate token creation and extra variables add noise and could be streamlined, slightly lowering readability.","tokens":861,"name":"117.jsnp"}
{"score":"68","reasoning":"The method is moderately readable but contains deep nesting and mixed responsibilities which reduce clarity. Variable names are clear and the flow is logical, however the handling of the filter option and error cases adds complexity and the long block makes it harder to follow quickly","tokens":808,"name":"15.jsnp"}
{"score":"85","reasoning":"The method is well documented with a clear Javadoc, uses descriptive variable names and early returns which make the control flow easy to follow. Logging statements are straightforward. Generic types and casts add some complexity but are typical for JPA metamodel code. Overall the code is readable and comprehensible.","tokens":992,"name":"84.jsnp"}
{"score":"55","reasoning":"The method is short and its control flow is simple but readability suffers from several issues. It uses raw types such as Vector, Collection and Iterator without generics, making the code harder to understand. Variable names are short and not descriptive. Returning a Vector while the signature declares List is confusing. The comment about wasteful use of Vector is informal. Overall the logic is clear but the style reduces comprehension.","tokens":700,"name":"120.jsnp"}
{"score":"85","reasoning":"The method is clearly documented and follows a logical structure with early returns for simple cases. Variable names are descriptive and the nested loops are easy to follow. Null checks are explicit, making the equality logic transparent. Minor improvements could include extracting the inner comparison to a helper, but overall readability is high","tokens":819,"name":"40.jsnp"}
{"score":"78","reasoning":"The method is fairly clear in purpose and flow, using descriptive variable names and straightforward loops. However readability suffers from raw types, nested conditionals, and magic strings which could be refactored. Synchronization and exception handling are explicit, aiding comprehension but overall code could be cleaner.","tokens":716,"name":"8.jsnp"}
{"score":"68","reasoning":"The code is fairly straightforward with clear method and variable names, but readability suffers from a few issues. The nested call type.sqlTypes(mapping)[getTypeIndex()] is dense and could be broken out. The error messages contain grammatical errors and the method name getSqlTypeCode is overloaded, causing potential confusion. Lack of comments and handling of generic Exception also reduce clarity.","tokens":613,"name":"37.jsnp"}
{"score":"65","reasoning":"The method performs several steps to bind an index column, uses nested conditionals and many chained calls which makes the flow hard to follow. Variable names are reasonable but the long parameter list and raw type casts reduce clarity. Lack of comments and extracted helper methods hurts readability, resulting in a moderate score","tokens":973,"name":"109.jsnp"}
{"score":"78","reasoning":"The method is clearly named and follows a logical sequence of opening a session, beginning a transaction, creating objects, persisting them, and handling the expected exception. Resource cleanup is ensured with finally blocks. Indentation is consistent, but the nested try‑catch adds some complexity. Overall the code is readable and easy to follow.","tokens":805,"name":"129.jsnp"}
{"score":"70","reasoning":"The method uses clear naming and logical structure but suffers from deep nesting and repeated resolveEntityKey calls. Use of instanceof checks makes flow harder to follow and long parameter lists reduce readability. Refactoring into smaller methods would improve comprehension, hence a moderate score.","tokens":839,"name":"197.jsnp"}
{"score":"78","reasoning":"The test method has a descriptive name and follows a clear arrange act assert structure. Variable names are meaningful and comments explain the flush and natural id caching steps. Minor issues include compact spacing and a raw cast, which slightly affect readability, but overall it is easy to follow for developers familiar with Hibernate","tokens":847,"name":"179.jsnp"}
{"score":"78","reasoning":"The method is well indented and uses descriptive names such as translateMouseEvent and setUnderMouse which aid comprehension. The logic for tooltip handling is clear though nested, and the commented out lines slightly distract. Overall the flow is straightforward, making the code fairly readable.","tokens":795,"name":"122.jsnp"}
{"score":"65","reasoning":"The method is short and self contained but uses a raw Vector and repeats addElement calls for each type. The lack of generics, the magic constants and the repetitive code reduce readability. Using a loop or a collection initializer and generic types would make the code clearer and easier to maintain.","tokens":826,"name":"45.jsnp"}
{"score":"72","reasoning":"The test method is straightforward and uses consistent patterns for asserting revision lists, which aids comprehension. Indentation is clear but the repeated long method calls make lines lengthy and slightly harder to scan. Variable names are descriptive, and the use of static imports would improve brevity. Overall readability is good but could be cleaner.","tokens":723,"name":"185.jsnp"}
{"score":"85","reasoning":"The method is straightforward and uses a fluent StringBuilder pattern that is easy to follow. Each field is appended on a separate line, making the structure clear. Variable names are descriptive. Minor improvements could include using String.format or a helper method for brevity, but overall readability is high.","tokens":621,"name":"63.jsnp"}
{"score":"78","reasoning":"The method is clearly named and uses descriptive variable names. It copies existing annotation values, checks for existing schema and catalog, and adds missing defaults in a straightforward way. The logic is easy to follow though a few extra boolean flags and list copying add minor verbosity. Overall readability is good","tokens":854,"name":"195.jsnp"}
{"score":"45","reasoning":"The method mixes UI thread dispatch with model logic, uses an anonymous Runnable and several nested ifs. Variable names are short but the use of raw casts and string comparison with \u003d\u003d is error prone. Comments are sparse and a TODO remains. Indentation is clear but overall flow is hard to follow, reducing readability.","tokens":1045,"name":"154.jsnp"}
{"score":"78","reasoning":"The method is clear and uses descriptive names, but the long chain of else‑if statements makes it verbose and harder to follow; repeated patterns could be refactored into a switch or map and magic strings are hidden in constants. Overall readability is moderate","tokens":1099,"name":"108.jsnp"}
{"score":"78","reasoning":"The method is well structured with clear variable names and consistent indentation. The series of instanceof checks are straightforward, and each branch returns a Description appropriate to the test type. Minor drawbacks are the long if else chain and repeated casts, which could be simplified with polymorphism, but overall the code is easy to follow.","tokens":809,"name":"54.jsnp"}
{"score":"70","reasoning":"The test is straightforward but readability suffers from excessive visual separators and redundant casts. The flow of opening a session, generating ids and asserting values is clear, however the long comment lines and casting to Session reduce clarity. Overall readability is moderate","tokens":1038,"name":"17.jsnp"}
