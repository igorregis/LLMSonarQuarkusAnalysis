{"score":"72","reasoning":"Code shows standard Java Swing overrides for custom container with listener management in addImpl and remove. Logic is straightforward and follows conventions. However, snippet is incomplete starting mid-statement, lacks context for _app and _listener, no comments, and minor indentation inconsistencies hinder full comprehension.","tokens":912,"name":"170.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test methods with descriptive names, clear assertions, and standard persistence testing patterns. Helper method is straightforward. Assumes framework context like _persistence and utilities (nextLong, randomString), making it readable for experienced Java devs but slightly less accessible without full class. Clean formatting and logic flow.","tokens":1172,"name":"204.jsnp"}
{"score":"88","reasoning":"Well-structured Java class following conventions with clear imports, Javadoc, and internationalization via StringManager and i18n interface. Naming is descriptive. Easy to comprehend for Java developers familiar with the framework. Slight deduction for incomplete code and framework-specific dependencies requiring context.","tokens":1011,"name":"172.jsnp"}
{"score":"72","reasoning":"The code has clear logical flow with good indentation and structure for updating fitness and bias based on comparisons. Variable names are mostly descriptive but abbreviated. However, the undefined macro BETTER_THAN obscures the comparison logic, and magic numbers like 0.2f and 0.4f lack explanation, slightly hindering comprehension for non-experts.","tokens":1039,"name":"112.jsnp"}
{"score":"82","reasoning":"The code snippet is a well-structured Java Selenium test case with clear package imports class extension and method naming. It uses standard polling loop for element visibility which is comprehensible for automation testers. However empty catch block hardcoded timeout and link text reduce robustness and readability slightly. Overall easy to follow despite being incomplete.","tokens":1003,"name":"212.jsnp"}
{"score":"88","reasoning":"Code is clean Java utility class with clear static methods and consistent null-check pattern using logging. Method names are descriptive and logic is straightforward. Minor deductions for code repetition in clusterLink checks and abrupt snippet start, but highly readable and comprehensible overall.","tokens":1108,"name":"116.jsnp"}
{"score":"85","reasoning":"Code is short, well-indented, and uses clear method names. Constructor parameter is unused due to commented assignment, which reduces clarity on intent. getIcon method is straightforward with proper static method call. Minor issues prevent perfect score but remains easy to comprehend.","tokens":889,"name":"181.jsnp"}
{"score":"35","reasoning":"Code employs archaic while-switch-label idiom mimicking goto, severely harming readability and comprehension for modern Java developers. Busy-wait timeout loop with Thread.sleep is inefficient and verbose. Lacks clear structure; abrupt end in snippet exacerbates issues. Better suited for explicit sequential methods or WebDriverWait.","tokens":1047,"name":"102.jsnp"}
{"score":"42","reasoning":"Code is a linear Selenium test script with repetitive waitForPageToLoad and loadRequiredJavaScriptModules calls. Brittle XPath selectors reduce readability. Busy-wait polling loop with broad exception catch is poor practice. Lacks comments or abstraction, making it hard for non-experts to comprehend despite clear sequential flow.","tokens":1360,"name":"198.jsnp"}
{"score":"15","reasoning":"Fragmented snippet with unexplained closing braces, empty catch block ignoring all exceptions which is poor practice, hardcoded sleep without justification, and Selenium clickAt call split awkwardly across lines. No indentation, comments, or context provided, severely reducing readability and comprehension.","tokens":950,"name":"174.jsnp"}
{"score":"85","reasoning":"Well-structured Java code with clear variable names, logical flow for loading SQL resources via classloader, updating indexes, and handling upgrades. Proper exception logging and debug/info checks enhance readability. Deductions for framework-specific assumptions like StringUtil, PropsKeys, magic file paths, and incomplete snippet at end.","tokens":1269,"name":"103.jsnp"}
{"score":"82","reasoning":"Code is well-structured Java with clear constructors and Javadoc documentation. Standard getter/setter methods enhance readability. Minor deductions for inconsistent parameter naming prefixes like aTableName, missing getters for some fields like tableName and keySequence, and incomplete snippet lacking field declarations. Overall easy to comprehend for experienced Java developers.","tokens":1231,"name":"221.jsnp"}
{"score":"72","reasoning":"Java interface method declarations are standard and easy to read. getServiceName has proper Javadoc structure but contains typo o auth likely meaning oauth. setGadgetKey lacks any documentation. Stray closing comment marker at beginning confuses context. Minor indentation issues. Comprehensible for Java developers but inconsistent documentation lowers score.","tokens":976,"name":"168.jsnp"}
{"score":"55","reasoning":"The code implements logout automation using Selenium RC with polling loops, Thread.sleep, and empty catch blocks that swallow exceptions, which reduces readability and reliability. Locators like link\u003dSign Out are brittle. Intent is clear: wait for sign out link to vanish, click it, then wait for sign in button. Hardcoded timeouts and deprecated API lower score, but structure is straightforward.","tokens":1039,"name":"146.jsnp"}
{"score":"72","reasoning":"Code uses standard Java structure with clear package, imports, javadoc, and constants. Descriptive naming and AEMonitor for synchronization show good practices. Indentation is consistent. However, snippet is abruptly incomplete mid-method, missing closing braces and logic, hindering full comprehension. Minor trailing spaces present.","tokens":1206,"name":"151.jsnp"}
{"score":"25","reasoning":"Poor indentation disrupts flow and makes nesting unclear. Empty catch-all exception handler ignores errors without logging or handling, hiding issues. Broad XPath selector lacks specificity. No comments or context provided. Structure implies timeout wait loop but is hard to parse quickly.","tokens":926,"name":"192.jsnp"}
{"score":"95","reasoning":"Code is clean, concise Java with clear method names and single responsibilities. Enhanced for loop is used effectively in deleteQuestions. Straightforward delegation to persistence layer. Throws appropriate exceptions. Highly readable and easy to comprehend, minor deduct for no comments and snippet formatting.","tokens":1004,"name":"153.jsnp"}
{"score":"92","reasoning":"Clean Java test class snippet with standard imports clear class and method names and proper Javadoc. Follows Selenium testing conventions making it highly readable for familiar developers. Minor deduction for incompleteness but structure aids comprehension.","tokens":1006,"name":"191.jsnp"}
{"score":"88","reasoning":"Code shows simple, consistent wrapper methods delegating to PortalServiceUtil with uniform exception handling: log and rethrow as RemoteException. Readability is high due to clear structure, standard Java patterns, and good indentation. Minor deduction for high repetition across methods, which could be refactored for better maintainability but does not hinder comprehension.","tokens":966,"name":"140.jsnp"}
{"score":"98","reasoning":"Standard Java getter and setter methods with precise Javadoc comments. Consistent naming, clear structure, and no complex logic. Extremely readable and comprehensible for Java developers. Minor deduction for stray leading characters.","tokens":1042,"name":"136.jsnp"}
{"score":"42","reasoning":"Code snippet shows Selenium test logic with procedural style using hardcoded brittle locators like _15_rowIds and XPath. Flow uses labels and continue for control, indicating potential spaghetti code. Includes waits and assertions but lacks comments, constants, or abstraction like page objects. Readable for Selenium experts but low ease for general developers due to magic strings and incomplete context.","tokens":1152,"name":"193.jsnp"}
{"score":"98","reasoning":"This snippet contains only clean, well-formatted import statements for Liferay portal libraries and Java utilities. They are consistently styled, properly terminated with semicolons, and logically grouped by package. Highly readable and immediately comprehensible as setup for a properties/logging module, with no errors or redundancies.","tokens":1016,"name":"208.jsnp"}
{"score":"78","reasoning":"Class structure is clear with proper inheritance and constructors. getColor method has straightforward caching logic using try-catch, but lacks generics on Map, Override annotations, and active exception logging (commented out). Minor indentation inconsistencies and domain-specific dependencies like ColorCache and Utils reduce general readability. Comprehensible for experienced Java SWT developers.","tokens":1349,"name":"166.jsnp"}
{"score":"85","reasoning":"Well-structured Java Liferay portlet code snippet with clear logical flow clear variable names and proper indentation. Uses standard APIs like BeanParamUtil ParamUtil and ServiceUtil effectively. Handles rule retrieval conditionally. Easy to comprehend for Java developers familiar with Liferay. Deduction for abrupt start end incompleteness and no comments.","tokens":1267,"name":"186.jsnp"}
{"score":"78","reasoning":"Code uses clear variable names and concise methods, making it mostly readable. Logical flow is straightforward with proper exception handling in parts. However, the first method risks NullPointerException as group remains null after try-catch exception, dereferenced later without check, which impacts comprehension.","tokens":1300,"name":"101.jsnp"}
{"score":"72","reasoning":"The code is generally readable with descriptive method names, clear structure for building config models, and helpful comments explaining sections like disable lists. Parameter grouping logic is straightforward. However, single-letter variables lp dm am hurt clarity, missing generics on ArrayList and List reduce modernity, anonymous inner class is verbose, and abrupt snippet start confuses context. Suitable for experienced Java devs familiar with the plugin framework.","tokens":1570,"name":"106.jsnp"}
{"score":"75","reasoning":"The code snippet uses meaningful constants for context keys enhancing readability. It properly checks for key existence before retrieval preventing errors. GetterUtil provides safe type conversion. However the snippet appears incomplete starting mid-statement with unbalanced parentheses and abrupt beginning which hinders full comprehension without surrounding context.","tokens":1105,"name":"133.jsnp"}
{"score":"32","reasoning":"The code is repetitive with frequent selenium.waitForPageToLoad and loadRequiredJavaScriptModules calls. Brittle XPath locators like //td[4]/span/ul/li/strong/a reduce maintainability. Unusual control flow using integer labels and continue statements mimics goto logic, confusing readers. No comments or extraction into helper methods. Clear intent for UI test automation but poor structure lowers comprehension.","tokens":1555,"name":"152.jsnp"}
{"score":"72","reasoning":"The code features simple, clear getter methods that are easy to read. Formatting is consistent with proper indentation and Javadoc comments. However, hashCode and equals implementations have logical flaws: hashCode factors in autoIncrement (not checked in equals) but omits simpleName (checked in equals), violating hashCode-equals contract. Snippet starts abruptly, slightly reducing comprehension. Overall readable but flawed.","tokens":1474,"name":"150.jsnp"}
{"score":"95","reasoning":"Code is concise and follows Java conventions with clear method and variable names. Constructor properly initializes superclass and field. Execute method has simple, logical flow: saves old value before setting new one. Self-explanatory despite no comments or visible field declarations. Highly readable and comprehensible.","tokens":833,"name":"104.jsnp"}
{"score":"42","reasoning":"Code uses Selenium API sequentially for UI automation but employs brittle XPath locators like //input[@id\u003d\u0027_134_name\u0027] which are hard to read. Magic numbers for timeouts (30000,90) lack explanation. Repeated loadRequiredJavaScriptModules calls are unclear. Incomplete for loop with label/continue assumes outer context. No comments or error handling beyond basic timeout. Readable for Selenium experts but low overall comprehension.","tokens":1120,"name":"157.jsnp"}
{"score":"92","reasoning":"Well-structured Java service class with clear method names, consistent permission checks using CommonPermissionUtil, and standard use of localService and persistence. Proper exception handling and imports. Self-explanatory for Java enterprise developers, though Liferay-specific context may reduce accessibility for novices. No inline comments needed due to clarity.","tokens":1095,"name":"175.jsnp"}
{"score":"92","reasoning":"The snippet is a clean Java file header with structured Javadoc comments detailing title description copyright author and LGPL license. Imports are simple and relevant. Text is readable with proper formatting though minor inconsistency in license Foobar vs sqsc-isqlj and HTML tags slightly clutter. No complex logic making it highly comprehensible.","tokens":1127,"name":"190.jsnp"}
{"score":"62","reasoning":"Code is a standard Selenium test for Liferay with clear structure and method naming. However, repetitive busy-wait loops with for loops and Thread.sleep calls are inefficient and reduce readability. Hardcoded timeouts, magic numbers, and multiple loadRequiredJavaScriptModules invocations add verbosity. Incomplete snippet and lack of abstraction lower comprehension for newcomers.","tokens":1218,"name":"145.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear, repetitive setter calls for property copying, making intent obvious. compareTo method is simple and straightforward. Minor deduction for repetition that could use a loop for conciseness, but does not hinder comprehension. Self-explanatory without comments.","tokens":1130,"name":"183.jsnp"}
{"score":"55","reasoning":"Code is boilerplate Java with getters and setters for arrays. Readability hampered by long fully qualified class names like com.sap.engine.services.dc.wsgate.ArchiveFile. Missing declaration for archiveFiles field makes it incomplete. Indexed accessors are clear but unusual. Javadoc is standard but repetitive. Straightforward purpose but verbose and error-prone as presented.","tokens":1261,"name":"188.jsnp"}
{"score":"92","reasoning":"Code is a straightforward JUnit test suite class with clear structure and standard pattern for adding test suites. Javadoc author tag adds context. Highly readable for Java developers familiar with testing frameworks. Minor deduction for incomplete snippet missing closing braces which slightly impacts full comprehension.","tokens":920,"name":"199.jsnp"}
{"score":"92","reasoning":"Code is clean and concise with descriptive variable names like fileEntryTypeId and fieldsMap. Sequential logic is straightforward. Long method call is well-wrapped across lines improving readability. Minor deduction for undefined variables and framework-specific calls assuming prior knowledge.","tokens":1022,"name":"135.jsnp"}
{"score":"25","reasoning":"The snippet is incomplete and poorly formatted, starting with a stray method call getLeecherCount without context or semicolon properly placed, followed by a Javadoc comment split awkwardly and a public int method declaration with bad indentation. Lacks enclosing class or interface, reducing readability and comprehension significantly.","tokens":993,"name":"126.jsnp"}
{"score":"72","reasoning":"Code demonstrates good practices like null checks and specific exceptions. Methods have clear names and logical flow. Indentation is mostly consistent. However, snippet is fragmented with incomplete methods, missing braces, and abrupt end. Relies on external framework knowledge like PortletMode and QName, reducing standalone comprehension.","tokens":1294,"name":"131.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive names like beforeRecurrence and duringRecurrence. Follows standard test pattern: setup recurrence, assert false before, true during specific dates, false after. Well-structured but relies on superclass methods like getRecurrence and getCalendar, and uses date constants without inline explanations, slightly impacting standalone comprehension.","tokens":1122,"name":"159.jsnp"}
{"score":"88","reasoning":"The code snippet defines a clear JUnit TestSuite class with a standard suite method that adds two test suites. Naming conventions are descriptive, indentation is proper, and the author Javadoc tag adds context. It is highly readable and easy to comprehend for its purpose, but incompleteness with missing closing braces slightly impacts full understanding.","tokens":1008,"name":"176.jsnp"}
{"score":"65","reasoning":"Java method signatures with Javadoc comments are mostly clear, showing overloading for parameters like labels, password, and int values. However, inconsistent indentation, mixed tabs and spaces, awkward alignment in parameter lists, and sparse param descriptions reduce readability. Formatting issues make scanning harder despite understandable purpose.","tokens":1153,"name":"201.jsnp"}
{"score":"95","reasoning":"The code consists of a clear, linear sequence of setter calls on a layoutRevision object with descriptive variable and method names. The single if-block for iconImage is straightforward. Consistent formatting and no complex logic enhance readability and comprehension. Minor repetition in setters prevents perfect score.","tokens":1005,"name":"148.jsnp"}
{"score":"92","reasoning":"Code is concise and follows JUnit conventions for test suites. Clear class name, static suite method, proper indentation, and author Javadoc. Easily comprehensible: creates TestSuite and adds two others. High readability, slight deduction for incomplete snippet and missing imports.","tokens":871,"name":"207.jsnp"}
{"score":"75","reasoning":"The code snippet is a partial Java Selenium test method with clear structure: navigation, JS loading, and a polling loop to wait for a link visibility. Readability is good due to standard patterns and indentation, but deducts for incompleteness, magic numbers (90,1000), busy-waiting with Thread.sleep, and outdated Selenium API usage which may confuse modern readers.","tokens":1041,"name":"209.jsnp"}
{"score":"72","reasoning":"Code has clear logical flow for building SchemaLoadInfo objects conditionally based on schema details. Variable names are descriptive and intent is comprehensible. Deductions for redundant else clause in procedure loading which could be simplified, repeated addStringArrays calls violating DRY principle, magic constants like SCHEMA_LOADING_ID_DONT_LOAD, and awkward snippet start with unmatched brace and continue statement affecting readability.","tokens":1251,"name":"187.jsnp"}
{"score":"45","reasoning":"The code is a Selenium test script using outdated RC API with repetitive clickAt, waitForPageToLoad, and loadRequiredJavaScriptModules calls. Hardcoded locators and magic numbers like 30000 and 90 reduce maintainability. The busy-wait loop with try-catch exception suppression is inefficient and unclear. Sequence is linear and comprehensible but verbose and lacks abstraction.","tokens":1219,"name":"167.jsnp"}
{"score":"82","reasoning":"Code exhibits standard Java ORM query pattern with clear try-catch-finally for session management and caching. Logic flows logically: conditional listing based on orderByComparator, post-sort if needed. Indentation aids readability. Drawbacks: framework dependencies like QueryUtil and FinderCacheUtil assume prior knowledge; incomplete snippet lacks full context; generic Collections.sort lacks explicit comparator. Concise and maintainable for familiar developers.","tokens":1229,"name":"202.jsnp"}
{"score":"35","reasoning":"Code intent is clear: wait for delete menu item visibility, assert text, click, and verify confirmation. However, readability suffers from brittle hardcoded XPath with li[6] index, inefficient polling loop with Thread.sleep and magic numbers (90s timeout, 1000ms sleep), empty catch-all Exception block swallowing errors, outdated Selenium API usage, and lack of modern waits like WebDriverWait. Overall, hard to maintain and comprehend without context.","tokens":1151,"name":"215.jsnp"}
{"score":"42","reasoning":"Code employs outdated Selenium RC syntax with verbose hardcoded locators and XPath selectors, making it hard to maintain. Control flow uses labeled cases and continue statements in a loop-like manner, resembling goto which confuses readers. Polling with Thread.sleep is primitive and inefficient. No comments or abstractions hinder comprehension despite clear intent in assertions.","tokens":1377,"name":"107.jsnp"}
{"score":"95","reasoning":"The code snippet defines a Java class with two public static final int constants using standard UPPER_CASE naming convention. Descriptive names like ADD_KB_ARTICLE make intent clear. Javadoc provides author info. Highly readable and comprehensible, though class lacks closing brace, likely due to snippet truncation.","tokens":990,"name":"189.jsnp"}
{"score":"58","reasoning":"Inconsistent indentation and spacing, unusual line breaks in method signatures like private boolean isValuePresent, reduce readability. Regex patterns are complex without inline comments explaining groups. Logic for checking and replacing plist content is clear but code is incomplete at end. Poor formatting outweighs decent structure and javadoc.","tokens":1318,"name":"177.jsnp"}
{"score":"65","reasoning":"The snippet shows three simple Java method declarations with clear, descriptive names following camelCase conventions. Intent is easy to grasp as getters for interval-related values. However, non-standard line breaks splitting return types from method signatures make it fragmented and harder to read at a glance compared to conventional single-line format.","tokens":807,"name":"158.jsnp"}
{"score":"62","reasoning":"The code snippet uses standard Java conventions with try-catch-finally for resource management but has poor readability due to empty catch blocks that silently suppress errors like UnsupportedOperationException and NoSuchFileEntryException hurting debuggability. Nested ifs exception-driven flow and magic constants like PropsKeys.XUGGLER_ENABLED reduce clarity. Underscore-prefixed private methods are okay but lack comments and context makes full comprehension challenging for snippet alone. Decent for experienced devs but needs refactoring.","tokens":1325,"name":"180.jsnp"}
{"score":"82","reasoning":"Code is well-structured with consistent try-catch patterns for specific exceptions like PrincipalException and NoSuchRoleException. Logic flows clearly: validate roles, handle errors by adding to session and forwarding to error page, rethrow others. Framework-specific elements like RoleConstants and WebKeys reduce accessibility without context. No comments and magic strings slightly hinder readability but overall easy to follow for Java devs familiar with portlets.","tokens":1162,"name":"111.jsnp"}
{"score":"95","reasoning":"The snippet features a clean Java interface header with detailed license information, standard package declaration, and informative Javadoc. Structure is professional and follows conventions, making it highly readable and comprehensible, even though the interface body is absent.","tokens":1014,"name":"160.jsnp"}
{"score":"88","reasoning":"Java JUnit test snippet for table model methods. Clear test names like testGetValueAt and testGetValueAt_InvalidColumn. Nested loops are simple and assertions straightforward. Handles multiple exception types appropriately. Logic easy to comprehend. Minor issues: abrupt start with closing braces lacks context, long concatenated fail message, slight indentation inconsistencies reduce perfect score.","tokens":1169,"name":"178.jsnp"}
{"score":"95","reasoning":"Clean, well-structured Java class with proper imports, clear method names, and simple logic. Follows naming conventions, minimal code does exactly what it intends: handles uncheckout by retrieving document tree. Easy to comprehend for any Java developer. Slight deduction for undefined METHOD_NAME constant and broad Exception.","tokens":1096,"name":"125.jsnp"}
{"score":"55","reasoning":"Code structure is straightforward with try-catch and conditional break, making it easy to follow the wait logic. However, broad XPath selector lacks specificity, empty catch block suppresses errors poorly, hardcoded sleep is inflexible, and missing comments or variable names reduce clarity.","tokens":915,"name":"105.jsnp"}
{"score":"75","reasoning":"The code snippet performs clear Selenium automation steps: clicking a link, waiting for page load, loading JS modules, checking element visibility, and a conditional label set. It is linear and easy to follow for those familiar with Selenium RC. Deductions for awkward multi-line clickAt args, redundant locator text, unicode escape, hardcoded values, and abrupt incompleteness.","tokens":1158,"name":"149.jsnp"}
{"score":"72","reasoning":"The snippet shows a synchronized block in Java for cache management and MBean unregistration. Structure is clear with if-else logic and standard conventions like underscore-prefixed fields. Readability is good due to proper indentation and concise operations. However, it starts mid-declaration after throws clause and ends abruptly in else block without closing braces, making full intent harder to grasp without context.","tokens":1045,"name":"156.jsnp"}
{"score":"62","reasoning":"Code employs polling loops with fixed sleep and timeout for element visibility, which is functional but inefficient compared to explicit waits. Uses legacy Selenium RC API like selenium.isVisible and click. Hardcoded magic numbers like 90 seconds and 1000ms hurt maintainability. Lacks comments, constants, or error handling details. Repetitive structure in loops. Readable for experienced testers, but verbose and not modern best practices.","tokens":1048,"name":"220.jsnp"}
{"score":"65","reasoning":"Code strips double quotes and trailing File.separator from library_path. Intent is clear with simple loops, but inefficient temp +\u003d c concatenation is O(n^2) in Java. Inconsistent indentation, tabs vs spaces, cutoff comment, and incomplete if statement hurt readability. Uses basic constructs but lacks StringBuilder and better formatting.","tokens":1159,"name":"115.jsnp"}
{"score":"98","reasoning":"Two simple, well-named delegation methods following standard Java conventions. Clear parameters, return types, and exception handling. Fully qualified types are verbose but precise. Extremely readable and comprehensible for Java developers.","tokens":860,"name":"214.jsnp"}
{"score":"88","reasoning":"Well-structured Java interface with comprehensive Javadoc comments explaining parameters exceptions and behavior. Method names are clear and follow conventions. Minor deductions for stray leading */ formatting inconsistencies like indentation and small comment inaccuracies eg cipher vs MAC reference. Overall highly readable and easy to comprehend.","tokens":1151,"name":"184.jsnp"}
{"score":"25","reasoning":"The code snippet is highly incomplete, ending abruptly without full method bodies or class context, making it difficult to understand purpose or flow. Indentation is inconsistent and fragmented. Simple method delegations to instance are readable individually, but lack of surrounding code severely impacts overall comprehension.","tokens":877,"name":"132.jsnp"}
{"score":"82","reasoning":"Code is a standard Selenium Java test case with clear structure, descriptive class/method names, and Javadoc. Polling loop for element presence is explicit and easy to follow, though verbose with Thread.sleep. Hardcoded values like timeout and link text reduce flexibility. Snippet is incomplete but readable for QA engineers familiar with Selenium.","tokens":960,"name":"203.jsnp"}
{"score":"35","reasoning":"Code shows stub methods for listeners with empty bodies or notSupported calls. Intent is clear as no-op implementations, but readability is poor due to inconsistent indentation, extra spaces in parameters, misaligned braces, and seemingly incomplete first method signature. Lacks comments and uniform formatting, making it hard to scan quickly.","tokens":1062,"name":"138.jsnp"}
{"score":"88","reasoning":"Code is straightforward and easy to comprehend, with clear handling of dates using null checks and Long.MIN_VALUE fallback. Field assignments are simple. Minor issues include repetitive date logic that could be refactored and redundant String name variable before length check. Overall highly readable with good structure.","tokens":1036,"name":"142.jsnp"}
{"score":"70","reasoning":"Code snippet shows Java interface methods: getClassPK, setClassPK, and isNew. Standard getter-setter pattern aids comprehension. Javadoc for setter is present but contains typos like space in class p k instead of classPK. Missing Javadoc for other methods and minor indentation issues slightly hinder readability.","tokens":1007,"name":"141.jsnp"}
{"score":"62","reasoning":"Code uses outdated Selenium RC API with hardcoded locators including unicode escapes. Logic for visibility check, click, and polling wait is straightforward but verbose busy-wait loop with magic numbers and silent exception handling hurts clarity. Assumes external context like label and selenium objects. Comprehensible for Selenium experts but lacks modern practices, comments, and clean structure.","tokens":1129,"name":"217.jsnp"}
{"score":"92","reasoning":"The code demonstrates high readability with clear method signatures using generics, descriptive variable names like visiblePlugins and pluginSetting, and straightforward iteration logic for filtering plugins by active status and user permissions. Efficient ArrayList initialization with capacity. Proper exception declaration. Slight deduction for the incomplete second method body, which cuts off abruptly.","tokens":1245,"name":"119.jsnp"}
{"score":"68","reasoning":"The code follows a linear sequence of Selenium actions for web testing, making the intent clear: navigate pages, wait for elements, and click. Descriptive locators aid comprehension. However, repetitive polling loops with Thread.sleep, empty catch blocks swallowing exceptions, hardcoded timeouts, and outdated Selenium RC syntax hinder readability and maintainability, suggesting room for improvement with explicit waits and better error handling.","tokens":1232,"name":"110.jsnp"}
{"score":"98","reasoning":"The code snippet features a straightforward Java constructor that delegates to the superclass and a simple getter method returning a constant value. It uses clear naming conventions, minimal lines, and standard structure, making it highly readable and easy to comprehend despite minor indentation and potential comment artifact.","tokens":823,"name":"213.jsnp"}
{"score":"42","reasoning":"Selenium test code with clear sequential actions like waiting clicking and typing but uses outdated API fragile long XPath selectors hardcoded Windows file path and magic numbers. Duplicate polling loops with empty catch blocks hide errors no comments constants or page objects reduce maintainability and comprehension for non experts.","tokens":1359,"name":"173.jsnp"}
{"score":"65","reasoning":"Code is a partial Java Selenium test method with clear class and method names indicating purpose. Structure is standard, but incomplete snippet cuts off the loops condition, making full intent unclear. Busy-wait loop without sleep is inefficient and spins CPU. No comments or error handling visible. Readable for Selenium experts, but lacks completeness for easy comprehension.","tokens":964,"name":"114.jsnp"}
{"score":"35","reasoning":"Code is a Selenium automation script with sequential UI interactions. Readability is low due to verbose and brittle XPath selectors like input at value New Message or span 2 span button. Repetitive polling loops use magic numbers 90 and 1000 without explanation. Lacks comments structure or abstraction. Comprehensible for Selenium experts but hard to maintain or understand for others.","tokens":1321,"name":"194.jsnp"}
{"score":"62","reasoning":"Code uses consistent indentation but has complex nested if-else chains and asymmetric quote escape logic, where double quotes ignore escapes unlike single quotes. Abrupt end and dense conditions hinder quick comprehension. Variable names like bit and quote are okay but context-dependent. Overall moderately readable with effort needed.","tokens":1144,"name":"164.jsnp"}
{"score":"100","reasoning":"The code defines a simple Java custom exception class extending PortalException with a default no-arg constructor calling super. It includes a proper import and author Javadoc. Structure is clean, concise, and follows Java conventions perfectly, making it extremely readable and easy to comprehend even for beginners.","tokens":742,"name":"182.jsnp"}
{"score":"98","reasoning":"Well-structured Java interface with comprehensive copyright header, clear package and imports, descriptive method names following conventions, and Javadoc comments. Purpose is immediately clear: provides session and object info for database diff operations. Highly readable and comprehensible with no ambiguities.","tokens":1103,"name":"200.jsnp"}
{"score":"25","reasoning":"Fragmented code snippet with poor structure and missing context. Brittle long XPath locators, empty catch block ignoring exceptions, hardcoded Thread.sleep instead of explicit waits, magic numbers like li[3] and case 4, unclear label jumps. Hard to follow without full method, low readability and comprehension.","tokens":1135,"name":"121.jsnp"}
{"score":"100","reasoning":"This is a perfectly written standard Java setter method. It features clear Javadoc documentation with a descriptive summary and param tag, follows naming conventions with camelCase, has proper indentation, and a simple straightforward body. Exceptionally readable and easy to comprehend for any Java developer.","tokens":870,"name":"161.jsnp"}
{"score":"92","reasoning":"Code is concise, uses enhanced for loop for clarity, standard list-to-array conversion. Variable names like model and soapModels are descriptive. Purpose of converting KaleoTimer to KaleoTimerSoap is immediately clear. High readability despite being a snippet fragment with abrupt constructor.","tokens":835,"name":"171.jsnp"}
{"score":"75","reasoning":"Code is a clear Selenium Java test method with standard polling wait for element visibility. Structure is logical, uses try-catch properly, but relies on inefficient busy-wait loop with Thread.sleep and magic numbers like 90 and 1000. Familiar to Selenium devs, but verbose for newcomers. Incomplete snippet slightly hinders full understanding.","tokens":1004,"name":"219.jsnp"}
{"score":"72","reasoning":"The code shows a standard Liferay CLP proxy pattern with repetitive MethodHandler usage and consistent exception handling across methods. Structure is clear and predictable, but verbosity from full class names and duplication reduces ease of comprehension for newcomers. Suitable for framework experts.","tokens":1157,"name":"165.jsnp"}
{"score":"25","reasoning":"Code snippet has poor readability due to inconsistent indentation, abrupt ending with extra braces, and lack of context. Hardcoded brittle XPath selector. Empty catch block swallows exceptions without handling, which is bad practice. Uses inefficient polling with Thread.sleep. Basic intent is understandable but structure hinders comprehension.","tokens":881,"name":"124.jsnp"}
{"score":"25","reasoning":"The snippet is incomplete, showing only fragments of Java method declarations with the first one cut off. Inconsistent indentation, extra spaces, and lack of context make it hard to read and understand the purpose or structure.","tokens":920,"name":"118.jsnp"}
{"score":"82","reasoning":"Code is straightforward with simple delegation pattern, short methods, and clear purpose as a wrapper panel. Easy to comprehend overall structure and flow. Minor deductions for outdated naming conventions like underscore prefixes and verbose _myscrolledPanel, empty methods with comments, and incomplete snippet showing partial implementation.","tokens":1199,"name":"147.jsnp"}
{"score":"45","reasoning":"Code uses inefficient polling loops with hardcoded timeouts and sleeps instead of WebDriverWait. Long, brittle XPath selectors hinder readability. Repetitive structure lacks abstraction or comments. Selenium RC API feels outdated. Logic is straightforward but overall hard to maintain and comprehend without context.","tokens":1351,"name":"113.jsnp"}
{"score":"35","reasoning":"Code employs busy-wait infinite loops with manual timeouts and empty catch blocks that swallow exceptions, which is poor practice and obscures errors. Hardcoded sleeps and magic numbers like 90 and 30000 reduce maintainability. Repeated polling logic is not refactored into reusable methods. XPath selectors are verbose and brittle. Selenium API usage is outdated. Structure is linear but lacks clarity and modern waits, making it hard to comprehend quickly.","tokens":1221,"name":"210.jsnp"}
{"score":"72","reasoning":"Well-formatted Java code with clear method names, proper indentation, and standard logging practices. Constructor is simple. However, logger and StringManager use DeleteAliasAction.class mismatched with AliasAction class name, and error key is DeleteAliasAction-specific, creating confusion and suggesting copy-paste errors. These reduce ease of comprehension despite good structure.","tokens":1138,"name":"137.jsnp"}
{"score":"35","reasoning":"Incomplete snippet starting with closing brace confuses context. Inconsistent indentation across methods. Relies on undefined variable string. Cryptic toString implementation using Hex.encode without explanation. Lacks comments or documentation making comprehension difficult.","tokens":1055,"name":"169.jsnp"}
{"score":"95","reasoning":"Clean Java interface methods with standard getter setter pattern. Excellent Javadoc documentation on most methods with proper param return and throws tags. Consistent naming. Highly readable and easy to comprehend. Minor deduction for missing Javadoc on setCompanyId.","tokens":948,"name":"130.jsnp"}
{"score":"85","reasoning":"Code is clear and straightforward with consistent naming, simple validation logic using if-else, and proper error handling. Easy to understand intent. However, near-identical duplication between methods reduces readability and suggests refactoring opportunity, slightly impacting overall comprehension efficiency.","tokens":1184,"name":"206.jsnp"}
{"score":"92","reasoning":"The code snippet creates a JPanel with BorderLayout, adds an internationalized JLabel on the west and a JTextField in the center for name input. Variable names are descriptive (pnlName, lblName, txtName). Structure is logical and follows standard Swing practices. The i18n comment adds context without confusion. Highly readable for developers familiar with Java GUI, minor snippet incompleteness.","tokens":970,"name":"196.jsnp"}
{"score":"60","reasoning":"Code is concise with clear intent to poll for a Selenium element in a loop until present. Structure is simple and indentation aids readability. However, empty catch block hides exceptions, hardcoded sleep is inefficient, lacks timeout or comments, and uses potentially deprecated isElementPresent method, reducing overall comprehension for best practices.","tokens":940,"name":"218.jsnp"}
{"score":"98","reasoning":"The code consists of straightforward, repetitive testSuite.addTestSuite calls, each adding a clearly named test class. Structure is consistent, lines are short and aligned, making it highly readable and easy to comprehend instantly as test suite setup. Minor deduction for lack of variety but no issues present.","tokens":963,"name":"155.jsnp"}
{"score":"95","reasoning":"The snippet features a properly formatted copyright notice, LGPL license text, standard Java package declaration, and well-organized imports from related Liferay workflow packages. It adheres to Java conventions with consistent spacing and no errors. Easy to read and understand as a clean class header, though incomplete without body.","tokens":1175,"name":"134.jsnp"}
{"score":"72","reasoning":"Code is simple and linear, easy to follow: initializes app, creates JFrame, adds panel, sets size and visibility. Purpose clear as test UI. Deductions for missing import of SQLAliasConnectionProperties causing compilation error, incomplete Javadoc comment, extra empty lines reducing polish. Still comprehensible for experienced Java devs.","tokens":1058,"name":"123.jsnp"}
{"score":"25","reasoning":"Snippet is a polling loop fragment using Selenium to wait for element visibility. Readability is low due to inconsistent indentation, hardcoded magic string locator, empty catch block that swallows exceptions silently, and inefficient fixed Thread.sleep. Intent is guessable but code quality and safety issues hinder comprehension.","tokens":926,"name":"143.jsnp"}
{"score":"52","reasoning":"Code uses a label-driven while-switch loop resembling old Selenium test patterns, which is traceable but goto-like and not modern. Sequential Selenium actions are clear, but busy-wait polling with 90s timeout, Thread.sleep, empty catch blocks, magic numbers, hardcoded XPaths, and RuntimeVariables placeholders reduce clarity. Incomplete at case 2 and no comments lower comprehension.","tokens":1358,"name":"205.jsnp"}
{"score":"82","reasoning":"This is a clean Java interface snippet with consistent method signatures for a Bookmarks service. Readability is high due to standard naming, proper use of Transactional annotations, and uniform throws clauses. However, verbose fully qualified class names make lines long and slightly harder to scan quickly. No comments or grouping reduces context, but overall comprehension is straightforward for experienced developers.","tokens":1300,"name":"144.jsnp"}
{"score":"15","reasoning":"The snippet shows multiple closing braces without preceding context, making structure unclear. Followed by an incomplete method definition with only one line of body. Poor readability due to fragmentation, lack of indentation consistency, and no full method or class context, hindering comprehension.","tokens":822,"name":"117.jsnp"}
{"score":"68","reasoning":"Code has clear structure with descriptive methods but suffers from typo in _proccessAttributes misspelled process, unconventional underscore prefixes for private methods against Java norms, undefined constants like _EVENT_AFTER_REGEX and abrupt incomplete end. Logic flow is followable yet magic vars and redundancy in maps hinder full comprehension. Suitable for experienced Java devs familiar with framework.","tokens":1285,"name":"211.jsnp"}
{"score":"82","reasoning":"Well-structured Java test methods for persistence CRUD operations with clear names and standard assertions. Easy to comprehend for familiar developers. Deductions for incomplete testUpdateExisting method, testUpdateNew lacking assertions, and reliance on undefined helpers like nextLong and addSCProductVersion.","tokens":1135,"name":"120.jsnp"}
{"score":"92","reasoning":"Clear conditional logic in an enum valueOf method matching string to constant and throwing exception for invalid input. Followed by simple getter returning field value. Standard Java patterns, good naming with underscore prefix, straightforward and easy to comprehend.","tokens":923,"name":"109.jsnp"}
{"score":"25","reasoning":"Code snippet is incomplete fragment with abrupt start, cryptic element ID like _2_announcementsTypetestEmailCheckbox, undefined variables testEmailChecked and selenium, magic number label\u003d6, pointless RuntimeVariables.replace empty string. No comments, poor naming, lacks context reducing readability and comprehension significantly.","tokens":982,"name":"129.jsnp"}
{"score":"92","reasoning":"Code is concise and easy to follow with clear null check and simple return logic. Descriptive variable names aid comprehension. Minor deductions for inconsistent indentation, extra whitespace, and unnecessary parentheses around return statements.","tokens":819,"name":"185.jsnp"}
{"score":"98","reasoning":"This Java interface is exceptionally clean and readable. It features proper package and import statements, comprehensive Javadoc comments explaining purpose and parameters, descriptive method names like getStatistics and getUnit, and adheres to standard conventions. The single responsibility is clear: providing peer statistics by country. Minimal code enhances comprehension.","tokens":968,"name":"216.jsnp"}
{"score":"92","reasoning":"Code is well-structured with clear logic flow in get method, proper null checks, descriptive variable names, and standard JSF locale handling. Stub methods clearly indicate unsupported operations. Minor issues: string concatenation in logging is outdated style, assumes familiarity with LanguageUtil and FacesContext.","tokens":1041,"name":"154.jsnp"}
{"score":"95","reasoning":"Simple, well-structured Java class implementing Serializable with clear getters, setters for result and exception, and a straightforward hasError method. Standard naming conventions, minimal logic, and professional header enhance readability. Minor simplification possible in hasError, but overall highly comprehensible for Java developers.","tokens":1468,"name":"163.jsnp"}
{"score":"98","reasoning":"The code is highly readable with clear package structure, minimal imports, and comprehensive Javadoc comments. Methods are concise, use descriptive names, and follow standard Java conventions. Logic is straightforward: delegates to X962NamedCurves for curve parameters and names. Minor long line in constructor but overall very easy to comprehend.","tokens":1113,"name":"122.jsnp"}
{"score":"85","reasoning":"The code snippet defines a Java interface using Eclipse Sapphire framework annotations. Imports are standard and relevant, Javadoc is minimal but present, naming convention is clear with IPortalPropertiesFile. Syntax is correct, but incompleteness (missing body, methods, closing brace) slightly hinders full comprehension. Easy for Java experts familiar with Sapphire.","tokens":878,"name":"179.jsnp"}
{"score":"88","reasoning":"Code features clear getter methods, protected setter, and utility methods like toString with truncation for long params and concise toShortString. Follows Java conventions well. Minor deductions for incomplete labels in toString like cn without equals sign, typo in PlaformMessage, and abrupt snippet end. Easy to comprehend overall.","tokens":1134,"name":"108.jsnp"}
{"score":"92","reasoning":"Clean Java wrapper class using delegation pattern. Constructor and methods are concise and easy to follow. setAuthToken logic is straightforward. Minor deduction for missing field declarations in snippet and lack of comments, but overall highly readable and comprehensible.","tokens":1064,"name":"139.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear structure. toString uses StringBundler with logical append sequence for fields. toEntityModel explicitly handles nulls for name and primKey via if-else, avoiding surprises. Repetition in setters is straightforward. Consistent naming and simple logic make it easy to comprehend, minor deduction for redundant null checks.","tokens":1162,"name":"197.jsnp"}
{"score":"92","reasoning":"The code snippet is highly readable with standard Java package and import declarations, clear class name ConnectionPoints, and descriptive field names like pointsAreLeftOfWindow. Simple structure with proper indentation makes it easy to comprehend despite being incomplete and lacking methods or comments. Minor deduction for public fields which are not best practice but do not impact understanding.","tokens":988,"name":"128.jsnp"}
{"score":"68","reasoning":"Code uses standard Liferay tunneling pattern with MethodKey and MethodHandler for remote service calls, featuring clear try-catch blocks for exception handling. Readability is hindered by verbose fully-qualified class names, reliance on undefined static arrays like _updateLayoutSetPrototypeParameterTypes4, repetitive exception checks, incomplete snippet starting mid-method, and framework-specific assumptions requiring prior knowledge.","tokens":1381,"name":"162.jsnp"}
{"score":"65","reasoning":"The snippet shows partial Java method declarations likely from a Liferay interface. The first method is incomplete missing return type and name reducing comprehension. The other two are standard with clear signatures and throws Exception. Naming uses camelCase consistently but URL casing varies slightly. Poor indentation and fragmentation lower readability.","tokens":1147,"name":"195.jsnp"}
{"score":"88","reasoning":"Code shows clear repetitive pattern of updatePortletPermissions calls for configuring various Liferay portlets with permission arrays, easy to scan and comprehend. Hardcoded portlet IDs and strings are straightforward but could be more data-driven. getLayout method starts standard JDBC usage cleanly, though snippet is incomplete. Consistent formatting aids readability.","tokens":1337,"name":"127.jsnp"}
