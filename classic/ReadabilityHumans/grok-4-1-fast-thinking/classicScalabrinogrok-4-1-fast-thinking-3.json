{"score":"100","reasoning":"The code is exceptionally readable and easy to comprehend. It features a clear, concise Javadoc comment fully documenting purpose, parameter, and return value. Method name is descriptive, body is a single straightforward constructor call mapping fields directly with intuitive parameter names. No complexity, redundancy, or ambiguity present.","tokens":854,"name":"67.jsnp"}
{"score":"98","reasoning":"The code is highly readable and easy to comprehend. It uses clear structure with null check to avoid NPE, try-catch for safe closing of reader, and ignores IOException as intended for cleanup methods. Follows Java best practices with Override annotation and concise logic. Minor nitpick: empty catch block is explicit but standard.","tokens":842,"name":"150.jsnp"}
{"score":"95","reasoning":"The code is highly readable with clear structure, descriptive variable names like bufferReader and eventBuffer, and concise comments explaining the logic. It follows a straightforward flow: consume from buffer if available, otherwise read from parent and apply buffering with size limits. Minor deduction for nested conditions in buffering, but easy to comprehend for Java developers familiar with XMLStream API.","tokens":1026,"name":"151.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with descriptive name and explanatory comment. Clear logical flow: property setup, factory creation, assertions on cache config, and proper cleanup in try-finally. Variable names are meaningful. Assertions are precise and verify expected behavior. Minor deductions for magic numbers in properties and assumption of framework knowledge, but highly readable for experienced Java developers familiar with Hibernate and Infinispan.","tokens":1204,"name":"131.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method with clear Javadoc explaining purpose. Uses descriptive names like props, dialect, generator. Logical flow: setup properties, configure for two dialects, assert structures and optimizers. Consistent assertions. Highly readable for Java developers, even with framework specifics. Minor deduction for unshown helpers like buildGeneratorPropertiesBase.","tokens":1156,"name":"57.jsnp"}
{"score":"72","reasoning":"The test method has a clear purpose with straightforward assertTranslation calls for HQL queries. Comments explain dialect exclusions well. However, lengthy chained instanceof checks in multiple if conditions make it dense and harder to scan. Minor nesting adds complexity, but overall comprehensible for domain experts.","tokens":1204,"name":"89.jsnp"}
{"score":"78","reasoning":"Code has clear logical flow: extracts name, condition from multiple sources with fallbacks, parses aliases into map, applies filter. Good use of final, logging, and exception handling. Deductions for outdated Iterator loop instead of for-each, TODO comment highlighting design flaw depending on mapping order, and unexplained null parameter in addFilter call, which slightly impacts readability.","tokens":1184,"name":"31.jsnp"}
{"score":"98","reasoning":"The code is a concise JUnit test method verifying that a Hibernate query with fetch join in subquery throws QueryException as expected. Descriptive method name, standard try-catch-fail pattern, clear query intent, and minimal comments enhance readability. Straightforward for Java Hibernate developers.","tokens":930,"name":"81.jsnp"}
{"score":"92","reasoning":"The code is concise, well-structured, and follows standard Java override pattern with clear sequential property settings using Hibernate Environment constants. Easy to comprehend for developers familiar with the framework. Minor deductions for hardcoded string values like true/false and reliance on external getters without inline documentation.","tokens":917,"name":"191.jsnp"}
{"score":"95","reasoning":"The code is a concise JUnit test method using Hibernate. It follows standard patterns with clear variable names like s for session and tx for transaction. The method name is descriptive though long. Logic is straightforward: open session, persist entity, flush, rollback, close. Highly readable and easy to comprehend despite minimal body relative to name suggesting more setup.","tokens":915,"name":"133.jsnp"}
{"score":"82","reasoning":"Code is well-structured overriding method to add Hibernate Integrator for custom load listener. Anonymous inner class implements required methods concisely. Private integrate method centralizes logic. Minor issues: inconsistent indentation, spacing around method calls, and framework-specific assumptions slightly impact general readability.","tokens":1054,"name":"174.jsnp"}
{"score":"85","reasoning":"Well-structured Java method with helpful Javadoc and inline comments clarifying optimistic locking logic. Descriptive variable names like isImpliedOptimisticLocking and loadedState aid comprehension. Logical flow from state loading to SQL generation and execution loop. Deduction for Hibernate-specific concepts and potential density for non-experts.","tokens":1183,"name":"106.jsnp"}
{"score":"95","reasoning":"The code is highly readable with a clear Javadoc comment explaining the constructor purpose. It uses consistent formatting and simple, sequential registerColumnType and registerFunction calls, making the mapping of SQL types to Interbase equivalents immediately comprehensible. The final property set is straightforward. No complex logic or obfuscation, though a long list of registrations could benefit from minor grouping, but overall excellent clarity and ease of understanding.","tokens":1184,"name":"20.jsnp"}
{"score":"95","reasoning":"Clean Java constructor with Javadoc comment explaining purpose. Straightforward super call followed by consistent registerFunction calls, each on separate lines with proper indentation. Easy to comprehend dialect-specific SQL function registrations. High readability, minor deduction for hardcoded function names without constants.","tokens":945,"name":"21.jsnp"}
{"score":"78","reasoning":"The code is a straightforward JUnit test method using assertNoLoss on diverse SQL queries including insert, delete, update, complex selects with joins, subqueries, case statements, and functions. Structure is simple and logical, but long unformatted SQL strings reduce readability and make parsing details challenging without line breaks or comments.","tokens":1465,"name":"101.jsnp"}
{"score":"88","reasoning":"The code is highly readable with a clear pattern of setter calls copying properties from source to binding. Logical structure, descriptive method and variable names enhance comprehension. Minor deduction for potentially redundant if conditions on customPersisterClassName which could confuse readers about intent.","tokens":1224,"name":"146.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test with clear annotations, comments explaining skips and intent, proper exception expectation via fail and catch. Good resource management in try-finally. However, verbose Hibernate internals like long chains of getTransactionCoordinator getJdbcCoordinator reduce ease of comprehension for non-Hibernate experts. Overall readable for domain experts.","tokens":1230,"name":"93.jsnp"}
{"score":"88","reasoning":"The code clearly overrides runTest to execute the test in a new anonymous Thread with try-finally for cleanup via runFinished. Inline comment explains super call replacement due to VA Java limitation. Structure is standard for async test running, readable for experienced Java developers despite verbose inner class style.","tokens":952,"name":"73.jsnp"}
{"score":"85","reasoning":"Clear JUnit test verifying c3p0 PooledDataSource MBean attributes via JMX. Straightforward logic: query MBeans, find target by name, assert pool sizes and timeouts. Good use of descriptive variables and comment. Minor deductions for camelCase inconsistency (mbeanfound), typo (BMean), repetitive attribute fetches, and indexOf instead of contains.","tokens":1369,"name":"90.jsnp"}
{"score":"92","reasoning":"Well-structured method with clear if-else logic distinguishing single vs composite keys. Inline comments clarify sections effectively. Descriptive parameter names and helper functions like repeat and replace enhance readability. Minor deduction for undeclared constants like BATCH_ID_PLACEHOLDER, but comprehensible for ORM context.","tokens":1072,"name":"112.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with descriptive variable names and clear assertions. Handles indeterminate subclass order via iterator check and conditional logic effectively. However, verbose if-else block and domain-specific ORM concepts like entity bindings and single table inheritance reduce general readability slightly.","tokens":1205,"name":"181.jsnp"}
{"score":"35","reasoning":"Clear initial null and reference equality checks. However, the primary return statement is an extremely long, nested chain of ternary operators handling quoted vs case-insensitive comparisons for name, schema, and catalog, with null checks embedded. This density severely hampers readability and requires significant effort to parse the logic flow.","tokens":976,"name":"36.jsnp"}
{"score":"85","reasoning":"The code is a concise JUnit test method with clear structure: entity retrieval, audit history fetches, and assertions. Variable names like ed1, rev1 are descriptive and patterns are consistent. Easy to follow for those familiar with JPA/Envers. Minor issues: deprecated Collections.EMPTY_SET, reliance on external TestTools and predefined IDs slightly reduce standalone readability.","tokens":1103,"name":"166.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test for Hibernate orphan delete feature with clear phases: setup persistence, cache eviction, removal, verification. Descriptive variable names and logical flow aid comprehension. Minor deductions for typos in strings like Widge and if instead of of, repetitive session code, and reliance on Hibernate-specific knowledge.","tokens":1260,"name":"192.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test method with descriptive name. Anonymous inner classes for HqlExecutor and ResultChecker are used appropriately but add verbosity compared to modern lambdas. Query and assertions are clear and precise, checking expected results, courses, and lazy loading. Relies on external variables like yogiExpected and methods like areDynamicNonLazyAssociationsChecked, reducing standalone comprehension. Suitable for Hibernate experts.","tokens":1313,"name":"98.jsnp"}
{"score":"70","reasoning":"The test method has a clear structure with standard JUnit assertions checking entity revisions and list sizes. Logic is straightforward for those familiar with Hibernate Envers. However, excessively long class names hinder quick readability. Repetitive find calls for revisions could be looped or extracted to a helper method for conciseness. External variables like ed2_id and ing2_id are assumed defined elsewhere.","tokens":1248,"name":"186.jsnp"}
{"score":"78","reasoning":"Code has clear structure with if-else for input handling NULL empty invalid and valid ID cases. Logic for bidirectional Person-Address relationship is consistent. However magic strings NULL and empty string with empty block confuse intent. Duplicated removal from old address. Error handling via System.err is basic. Readable but improvable with constants refactoring and clearer empty case.","tokens":1171,"name":"61.jsnp"}
{"score":"88","reasoning":"Well-structured method with clear variable names like middleEntityXml and descriptive comments explaining key steps such as adding where clause and revision info. Logical flow from schema setup to entity creation and relations. Minor deduction for reliance on external context like mainGenerator and propertyAuditingData which assumes prior knowledge.","tokens":1315,"name":"170.jsnp"}
{"score":"92","reasoning":"Well-documented with clear Javadoc. Logical flow: conditional early insert handling followed by shared cache management. Descriptive method and variable names enhance readability. Assumes Hibernate domain knowledge for full comprehension, but structure is clean and concise. High score for professional quality.","tokens":963,"name":"103.jsnp"}
{"score":"88","reasoning":"Code is well-structured with descriptive variable names and logical flow: processes annotations, builds discriminator if no parents, logs errors, sets values and options. Ternary operators used effectively. Long fully qualified class names slightly reduce readability, but overall clear and easy to comprehend for Java/JPA experts.","tokens":1082,"name":"28.jsnp"}
{"score":"45","reasoning":"Code is overly verbose with excessive println statements and tilde separators that dominate and clutter the logic. Magic numbers like 0x3f and bit shifts are unexplained. Depends on undefined classes like BytesHelper and Helper. Purpose of generating custom UUIDs with bit manipulation for version and variant is discernible but hindered by debug noise and lack of inline comments.","tokens":1843,"name":"58.jsnp"}
{"score":"88","reasoning":"Well-indented Java method with clear purpose: updates listeners for stereotype changes in a model. Logical if-conditions are straightforward, using instanceof for event types. Comments aid understanding. Minor deductions for magic string stereotype, lack of null checks, and domain-specific assumptions like Model.getFacade, but highly readable for experienced Java devs.","tokens":972,"name":"47.jsnp"}
{"score":"95","reasoning":"Standard Java equals method implementation following best practices: reference equality check, instanceof, safe casting, primitive comparison, and null-safe string equals via ternary. Highly readable, logical flow, concise. Slight deduction for ternary density which might confuse absolute beginners.","tokens":832,"name":"60.jsnp"}
{"score":"68","reasoning":"Code is concise and functional, approximating closest point on rectangle using five key boundary points via arrays. However, xs and ys arrays are hard to parse visually as coordinate pairings require mental zipping. Duplicate point at indices 0 and 4 adds confusion. Magic number 5 and lack of comments reduce clarity. Moderate readability for experienced Java devs.","tokens":1350,"name":"153.jsnp"}
{"score":"95","reasoning":"Excellent Javadoc documentation clearly explains purpose and exceptions. Method has logical if-else flow: log if empty, else extract first unresolved action details via descriptive variables and throw informative exception. Variable names are verbose but precise. Iterator chains slightly verbose but readable. Highly comprehensible for Java/Hibernate developers.","tokens":1158,"name":"102.jsnp"}
{"score":"68","reasoning":"This Hibernate JUnit test method tests collection queries, joins, and filters. Readability is fair with standard session-transaction pattern and clear entity operations. However, it lacks comments, uses magic strings like foo and A, has a verbose dialect exclusion if-condition, and most queries lack assertions, making intent harder to follow without context. Density impacts ease of comprehension for non-experts.","tokens":1509,"name":"68.jsnp"}
{"score":"65","reasoning":"The code structure is clear with try-finally for timing and barriers, good use of variables like start end duration runs and conditional trace logging. However extensive commented-out while loop and scattered comments like queryItems and deleteCachedItems clutter the view confuse intent and make it seem incomplete reducing overall readability and comprehension.","tokens":1174,"name":"172.jsnp"}
{"score":"95","reasoning":"Clean and concise equals method override with standard checks for reference equality, instanceof, and super.equals. Includes clear Javadoc documentation. Easy to read and understand, follows Java conventions perfectly. Minor deduction for lack of field comparisons if class has state, but readability is excellent.","tokens":841,"name":"39.jsnp"}
{"score":"55","reasoning":"The test method is long and complex, with heavy use of casts, type checks, and repetitive checkResult calls using an incrementing index. It assumes deep knowledge of Hibernate internals like PersistentCollection and listeners. Logical flow exists but is dense and hard to follow without context, reducing overall readability and comprehension ease.","tokens":1388,"name":"140.jsnp"}
{"score":"78","reasoning":"Clear JUnit test method for Hibernate lazy associations using anonymous inner classes for executors and checker. Intent is evident from name, comment, and assertions checking sizes, objects, nulls, and initialization. Verbose due to inner classes and repeated casts; minor redundancy in assertions. Readable for Java/Hibernate experts but less so for juniors.","tokens":1375,"name":"96.jsnp"}
{"score":"92","reasoning":"Code is concise, uses standard JPA practices with clear transaction handling and persistence. Comment aids understanding. Easy to comprehend purpose: initializing a Country entity. Minor deductions for hardcoded values, missing variable declaration visibility (likely class field), and lack of error handling.","tokens":933,"name":"168.jsnp"}
{"score":"25","reasoning":"The code is hard to read due to excessive method chaining like ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator() repeated multiple times, heavy casting, anonymous inner class, hardcoded SQL strings, and silent exception ignoring on drop. Requires deep Hibernate knowledge, lacks comments or abstraction, making comprehension difficult for most developers.","tokens":1042,"name":"100.jsnp"}
{"score":"92","reasoning":"Short and clean Java method with clear structure: null check followed by Hibernate-specific reassociation of uninitialized proxies. Inline comment explains intent effectively. Easy to comprehend for those familiar with Hibernate, despite always returning null which is straightforward.","tokens":952,"name":"65.jsnp"}
{"score":"88","reasoning":"The code is a well-structured JUnit test with a descriptive method name clearly indicating its purpose: testing limit string generation for multi-column multi-table queries. It uses standard assertions, helper methods like toRowSelection and buildLimitHandler, and final variables for immutability. Readability is high due to proper indentation and logical flow. Minor deduction for the very long concatenated expected SQL string, which is dense and slightly harder to parse visually, though typical for dialect tests.","tokens":1081,"name":"23.jsnp"}
{"score":"85","reasoning":"Code has clear if-else structure handling empty list, single item, or multiple items concisely. Descriptive method names and consistent indentation aid readability. Minor issues: unusual MockHelper.isNotEmpty name and reliance on external constants like PRIMARY_KEY_JOIN_COLUMNS slightly reduce immediate comprehension for newcomers.","tokens":949,"name":"193.jsnp"}
{"score":"98","reasoning":"The code is a straightforward Java constructor for PostgresPlusDialect that registers various SQL functions using consistent registerFunction calls. It features a clear Javadoc comment, proper super call, uniform line structure, and good indentation, making it highly readable and easy to comprehend for developers familiar with Hibernate dialects.","tokens":1263,"name":"18.jsnp"}
{"score":"62","reasoning":"The code follows a clear if-else structure for handling parse state and code generation. However, it uses an undefined variable name, opaque methods like ffCodePiece and GeneratorJava.generateClassifierStart, a commented-out cast suggesting incomplete refactoring, outdated Stack usage, and lacks explanatory comments or null checks. Readable for those familiar with the context but challenging for others.","tokens":1093,"name":"116.jsnp"}
{"score":"72","reasoning":"The code is a structured JUnit test for Hibernate Criteria and HQL queries, clearly testing multi-select with aliases and fetch joins. Anonymous inner classes for executors and checker are functional but verbose and nested, reducing readability compared to modern lambdas or methods. Assumes prior knowledge of Hibernate APIs and external variables like yogiExpected. Good assertions and logic flow, but dense style impacts ease of comprehension.","tokens":1344,"name":"99.jsnp"}
{"score":"78","reasoning":"Code has clear structure with nested if-else blocks and descriptive parameter names indicating optionality. Logic flow is logical: prioritizes entityPersister from object if available, handles special composite ID case. However, the long chained condition with multiple getEntityMetamodel and property checks is dense and hard to parse at a glance. Minor redundancy in persister retrieval. Readable for Hibernate experts, less so for newcomers.","tokens":1180,"name":"198.jsnp"}
{"score":"92","reasoning":"Clear JUnit test method testing property filtering. Straightforward structure: populate Properties with prefixed keys, process via getConnectionProperties, assert size and value. Standard Java practices, good use of final. Minor deductions for hardcoded strings and duplicate password entries, but highly readable and comprehensible.","tokens":1296,"name":"35.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method testing JPA annotation overriding in Hibernate. Clear logical flow: builds XML context, accesses fields via reflection, creates annotation reader, and makes precise assertions on annotations like OneToOne, JoinColumns, etc. Descriptive variable names and assertions enhance readability. Minor deduction for lack of comments and assumption of JPA/Hibernate knowledge.","tokens":1417,"name":"135.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with clear annotations explaining purpose and dialect skips. Logical flow: native SQL inserts to force whitespace, HQL queries with assertions, proper transaction and cleanup. Readable variable names and comments aid comprehension. Minor issues: raw JDBC usage and string-concatenated SQL slightly reduce abstraction and increase fragility, but overall highly comprehensible for Java/Hibernate developers.","tokens":1252,"name":"136.jsnp"}
{"score":"78","reasoning":"The code has clear purpose with Javadoc, early return for efficiency, and proper exception handling with logging. Logic flows well: checks cache, tries default loader, then alternatives. Deductions for inconsistent indentation in catch block, legacy Iterator usage instead of for-each, long debug lines, and slightly nested structure making it less modern and readable.","tokens":1202,"name":"7.jsnp"}
{"score":"68","reasoning":"Code is functional and logic is straightforward: iterates posters, checks if any removed items belong to each, and fires tree change event if so. However, uses outdated Vector and Enumeration instead of modern collections and loops, reducing readability. Minor issues include redundant list fetch, hardcoded path array indices, and inconsistent log message singular vs plural method name. Comprehensible but dated style impacts score.","tokens":1403,"name":"46.jsnp"}
{"score":"95","reasoning":"Highly readable Java equals method with comprehensive Javadoc explaining purpose and behavior. Follows standard pattern: identity check, instanceof, cast, then sequential field comparisons with early returns for clarity. Logical flow is intuitive and easy to follow. Minor issue: Javadoc mentions only second and minute but code also checks hour and day, slight documentation inconsistency.","tokens":1120,"name":"42.jsnp"}
{"score":"68","reasoning":"Code has clear overall structure and intent to sync targets to tree selection, using flags to avoid recursion. However, nested loops are inefficient O(n*m), verbose row item access with deep casting, multiple similar flags, no comments, and trailing commented line reduce readability. Best for experienced Java Swing devs familiar with JTree.","tokens":1177,"name":"50.jsnp"}
{"score":"92","reasoning":"The code is a well-structured JUnit test for a Hibernate issue, with extensive comments explaining the complex bidirectional association and composite PK problem. Clear variable names, standard session/transaction patterns, and exception handling enhance readability. Long method name is intentional and documented, making it comprehensible for experienced Java/Hibernate developers despite domain-specific complexity.","tokens":1231,"name":"175.jsnp"}
{"score":"82","reasoning":"The code is a clear unit test for failure reporting in a JUnit-like framework. It sets up expected output, customizes a printer with an anonymous inner class, creates a failing test, runs it, and asserts output. Logic is straightforward and names are descriptive. Deductions for dense nested anonymous classes, magic strings, and assumption of framework knowledge which may hinder quick comprehension for beginners.","tokens":1024,"name":"12.jsnp"}
{"score":"82","reasoning":"Code is well-formatted with clear structure, descriptive variable names, precise exception messages, and efficient StringBuilder use. Switch cases handle relevant XML events logically, ignoring non-text appropriately. However, it fails to skip initial START_ELEMENT leading to immediate throw, and loops to END_DOCUMENT instead of END_ELEMENT, reducing comprehension of intended element-text extraction purpose.","tokens":1574,"name":"152.jsnp"}
{"score":"92","reasoning":"The code effectively uses StringBuilder with fluent chained appends for efficient and readable string construction. Clear structure shows intent: base stats always, optional region stats with null check and helpful comment. Explicit this qualifiers and method calls enhance clarity. Minor density in long chains slightly impacts perfect readability but remains highly comprehensible.","tokens":1128,"name":"64.jsnp"}
{"score":"92","reasoning":"Clear JUnit test method with descriptive name and assertions for annotation presence absence on ElementCollection. Repetitive assertAnnotationNotPresent calls are explicit and straightforward. Logical flow setup asserts properties. Easy to comprehend for Java JPA testers minor repetition does not impact readability.","tokens":1095,"name":"176.jsnp"}
{"score":"92","reasoning":"Well-structured chain of if-else statements with clear precedence logic for selecting loaders. Descriptive names and comprehensive comments explain each condition effectively. Logical flow is easy to follow. Slight deduction for method length and casts, but highly readable for Java developers familiar with Hibernate.","tokens":1239,"name":"107.jsnp"}
{"score":"65","reasoning":"Code logic is straightforward: checks aggregation kind and sets corresponding command. However, deep nesting of if-else reduces readability and makes it harder to follow flow. Long chained method calls and repeated equals checks add complexity. Could benefit from switch statement or enum dispatch for better clarity. Moderately easy to comprehend with some effort.","tokens":1024,"name":"157.jsnp"}
{"score":"95","reasoning":"Clear Java serialization method with comprehensive Javadoc explaining purpose and exceptions. Straightforward logic: default read followed by consistent reads of Paint objects via SerialUtilities. Repetition is predictable and easy to scan, enhancing comprehension. Minor deduction for length but overall highly readable.","tokens":1132,"name":"3.jsnp"}
{"score":"82","reasoning":"The code is a well-structured JUnit test method for JPA entity list modifications across revisions. Clear comments label each step, and the consistent transaction pattern begin-find-modify-commit enhances comprehension. Repetition in blocks slightly reduces elegance, and assumes external variables like c3_1 c3_2. Suitable for experienced developers, strong readability.","tokens":1249,"name":"188.jsnp"}
{"score":"85","reasoning":"The method is concise, single-purpose, and easy to follow. It validates state before creating EntityManagerImpl with clear parameter passing. Multi-line constructor improves readability. TODO note indicates planned features without confusion. Uses likely class fields like transactionType, which is standard. Hard-coded EXTENDED type is a minor inflexibility. Highly comprehensible for Java JPA context.","tokens":1111,"name":"55.jsnp"}
{"score":"92","reasoning":"Well-structured override method with clear if-else logic for handling collection elements. Descriptive variable names like elementType and elementGraph aid comprehension. Effective use of final variables, logging, and precise exception messages. Domain-specific classes assume framework knowledge, but code is concise and readable. Long lines in log and exceptions are minor drawbacks.","tokens":1080,"name":"183.jsnp"}
{"score":"95","reasoning":"This JUnit test method is highly readable with a consistent pattern across test cases for SQL TRIM variants. Clear variable names like fragment and template, straightforward assertions, and logical progression of syntaxes make it easy to comprehend. Repetition is intentional and aids understanding specific behaviors. Assumes familiar context for constants but no major issues.","tokens":1224,"name":"26.jsnp"}
{"score":"72","reasoning":"Clear JUnit test method structure with linear parse calls testing HQL syntax variations. Purpose is easy to grasp for Hibernate developers. Drawbacks include lengthy inline query strings that hinder quick reading, two identical parse invocations, and trailing commented lines with note that introduce minor clutter without adding value.","tokens":1262,"name":"85.jsnp"}
{"score":"88","reasoning":"Well-structured static initializer with clear purpose of registering Java notation providers via factory. Javadoc comment aids understanding. Consistent naming and formatting. Minor deduction for distracting commented-out code and domain-specific class assumptions requiring context knowledge.","tokens":989,"name":"5.jsnp"}
{"score":"78","reasoning":"The code is a well-structured JUnit test method with clear logical flow: setup map, assert revisions 15 and 16, verify deletion at 17. Descriptive variable names and standard assertions aid readability. Drawbacks include magic numbers (15,16,17), undefined external vars (ternaryMapId, intEntity1), and domain-specific Envers query assuming Hibernate knowledge, reducing general comprehension.","tokens":1290,"name":"167.jsnp"}
{"score":"82","reasoning":"Code is concise and follows standard Java event handling pattern with clear if-condition for project change. Uses constant for property name, good. Builds title and sets root/target logically. Minor deductions for short variable name p, commented-out line cluttering the code, and inline comment without action. Easy to follow overall.","tokens":1028,"name":"11.jsnp"}
{"score":"95","reasoning":"Well-documented Javadoc explains purpose parameters and return value clearly. Method signature uses descriptive names. Logic is straightforward: initialize context loop process entities handle leftovers wrap up and return. No complex constructs good naming conventions. High readability for Java developers familiar with Hibernate. Minor deduction for absent inline comments.","tokens":1113,"name":"126.jsnp"}
{"score":"68","reasoning":"The test method has a clear purpose, proper try-catch-finally structure, and a straightforward assertion. However, the long chained method calls like sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement reduce readability significantly. Casting to SessionImplementor and use of internal APIs assume domain knowledge, making it less accessible.","tokens":1005,"name":"145.jsnp"}
{"score":"85","reasoning":"Method is short and clear in purpose: resets state for two regions on local and remote listeners. Repetitive calls for modification and access on both listeners could be refactored into loops for better conciseness. Hardcoded class names should use constants. Straightforward logging. Highly readable and comprehensible.","tokens":1017,"name":"190.jsnp"}
{"score":"98","reasoning":"Simple, concise constructor with clear sequential method calls using descriptive names like registerCharacterTypeMappings. Javadoc provides purpose. No complex logic, easy to follow initialization flow. Minor deduction for assuming superclass knowledge.","tokens":801,"name":"19.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with descriptive name and logical flow: setup reader, assert annotation presence/absence, then verify AttributeOverrides details. Repetitive property checks are thorough but clear. Easy to comprehend for Java/JPA developers, minor verbosity deducts points.","tokens":1357,"name":"177.jsnp"}
{"score":"82","reasoning":"The method is concise with clear purpose: initializes a lazy property, updates snapshot if available, and checks field name match. Parameter names are descriptive, logic flows simply without deep nesting. Deducts points for reliance on undeclared class fields like lazyPropertyNumbers and lazyPropertyNames, assuming external context, and parameter count slightly high impacting quick comprehension.","tokens":1022,"name":"104.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive method and variable names like shouldReturnOnlyTheNamedDataPoints and assignedStrings. Clear intent: verifies supplier returns exactly 4 named string data points using assertEquals and Hamcrest matcher. Logical flow from setup to assertions. High readability for Java testers, slight deduction for external dependencies like signature and getStringValuesFromAssignments.","tokens":947,"name":"159.jsnp"}
{"score":"68","reasoning":"Code has a logical test flow for Hibernate composite IDs: save, SQL query load, and get. Structure is clear with repeated session patterns. Issues include inconsistent indentation, awkward variable names like getted and useForGet, complex SQL aliases specific to Hibernate, and inline comments explaining edge cases. Readable for domain experts but challenging for novices due to boilerplate and specifics.","tokens":1247,"name":"72.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with clear intent: sets up entities, tests HQL query on superclass property after collection access, then cleans up. Meaningful names like tiger, mother, zoo aid readability. Standard Hibernate patterns used consistently. Minor complexity from annotations and domain assumptions, but overall highly comprehensible for experienced Java devs.","tokens":1128,"name":"82.jsnp"}
{"score":"88","reasoning":"The code is well-structured and readable, with a clear test purpose for verifying distinct results in a Hibernate query with join, pagination, and ordering. Logical flow from setup to assertion. Minor deductions for typo in assert message (dublicated instead of duplicated), unexplained magic numbers (10,5), suppressed warnings without specifics, and unused commented print. Easy to comprehend for Java/Hibernate users.","tokens":1099,"name":"92.jsnp"}
{"score":"88","reasoning":"The code is well-structured with a clear purpose: creating a test instance via field injection. Logic flows logically: validate fields, instantiate class, inject parameters with type checking. Meaningful names like annotatedFieldsByParameter and descriptive exceptions enhance comprehension. Minor deductions for long concatenated exception strings and reliance on external methods like getAnnotatedFieldsByParameter, but remains highly readable for Java developers.","tokens":1142,"name":"13.jsnp"}
{"score":"72","reasoning":"Code has clear Javadoc and logical if-else structure for saving shortcuts. Variable names are descriptive. However, long unwrapped lines, repeated Configuration.makeKey calls, and nested conditions make it harder to scan quickly. Assumes familiarity with external classes like Action and KeyEventUtils. Minor redundancy in fetching oldAction per iteration.","tokens":1129,"name":"51.jsnp"}
{"score":"95","reasoning":"Clear JUnit test method with descriptive name and assertion messages. Tests query translator for date arithmetic and parameters using simple, repetitive patterns typical for unit tests. Easy to follow logic, consistent structure, and self-explanatory queries. High readability, minor deduction for repetition that could use parameterization.","tokens":1208,"name":"88.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with descriptive names like noInheritanceEntityBinding and clear assertions for entity binding properties. Logical progression from root checks to attribute bindings. Repetitive iterator assertions and long nested expressions slightly reduce readability, but overall comprehensible for Java developers familiar with JPA or Hibernate.","tokens":1303,"name":"180.jsnp"}
{"score":"85","reasoning":"The code is a concise JUnit test method with clear sequential calls to descriptive helper methods like forceNewSession and loadDataOnSessionAndAuditReader. The structure is easy to follow: setup, load data, and checks. However, the extremely long method name reduces readability and makes it harder to scan. Suitable for developers familiar with the context.","tokens":991,"name":"187.jsnp"}
{"score":"92","reasoning":"Code is well-structured with clear sectional comments for each revision, making intent obvious. Consistent transaction pattern enhances readability. Descriptive variable names and straightforward entity creation. Repetition is logical for test setup but could be slightly refactored. Assumes Hibernate knowledge, but snippet is easy to comprehend.","tokens":1170,"name":"189.jsnp"}
{"score":"45","reasoning":"The JUnit test has a clear intent from the method name, verifying a Hibernate Envers column name. However, deep method chaining with getCfg, getClassMapping on a very long class name, getKey, getColumnIterator next, and casting reduces readability. Requires specific domain knowledge for easy comprehension.","tokens":977,"name":"199.jsnp"}
{"score":"88","reasoning":"Code is well-structured with clear method override, logical flow from super call to index validation and uniqueness check. Variable names like annotatedFieldsByParameter and usedIndices are descriptive. Error messages are informative. Slightly dense nested loops and long strings reduce perfect score, but overall highly readable for experienced Java developers.","tokens":1130,"name":"14.jsnp"}
{"score":"75","reasoning":"The code is a clear JUnit test for Hibernate Criteria with fetch joins. Anonymous inner classes are verbose and dated compared to lambdas, reducing modern readability. Assertions are straightforward with helpful comments on known issues. Assumes familiarity with Hibernate and test fixtures like yogiExpected. Well-structured overall but moderately dense for quick comprehension.","tokens":1205,"name":"97.jsnp"}
{"score":"92","reasoning":"Code is concise, straightforward array initialization with descriptive method calls and null separators for grouping. Highly readable for Java developers familiar with UML context. Minor deductions for undocumented null usage as separators and lack of inline comments for clarity.","tokens":872,"name":"156.jsnp"}
{"score":"92","reasoning":"Concise method with single responsibility. Uses final keyword for clarity. Long parameter list is well-formatted with line breaks improving readability. Domain-specific types and casts are typical for ORM frameworks like Hibernate. Straightforward logic easy to follow for experienced Java developers. Slight deduction for awkwardly split assignment on first line.","tokens":1061,"name":"148.jsnp"}
{"score":"88","reasoning":"Well-documented with Javadoc and inline comments explaining locking and atomic updates. Proper use of try-finally for readLock ensures safety. AtomicLong CAS loops for min/max are efficient and correct but slightly obscure for beginners, impacting immediate comprehension. Overall clear for experienced Java developers.","tokens":1093,"name":"62.jsnp"}
{"score":"82","reasoning":"The method has a clear purpose documented in Javadoc referencing JPA specs. It uses descriptive method names like getFetchType and getColumn for sequential XML processing. Logic flows linearly from building the descriptor to adding overrides and tables. However, length with many calls, magic strings, and external dependencies reduce standalone comprehension. Suitable for experts in JPA metadata.","tokens":1510,"name":"149.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test for Hibernate with clear setup persist retrieve and assert flow. Descriptive variable names like kit and kitkat aid comprehension. Purpose explained in comments. Deductions for complex nested SkipForDialects annotations which are dense and hard to parse quickly plus hardcoded IDs and System.out.println in test which are not ideal practices.","tokens":1292,"name":"138.jsnp"}
{"score":"87","reasoning":"Code is well-structured with descriptive method name, clear variable names, and informative assertion messages. Follows standard JUnit and Hibernate patterns effectively. Minor deductions for magic number 0 in getGetter(0), broad throws Exception, and assumption of Hibernate internals knowledge for full comprehension.","tokens":1062,"name":"178.jsnp"}
{"score":"95","reasoning":"Excellent readability: comprehensive Javadoc explains purpose and references related class. Clear parameter names and inline comments detail lazy event creation and reverse listener processing to avoid issues. Straightforward loop logic using standard listener list idiom. Minor deduction for slightly dense lines and old-style loop decrement, but overall very easy to comprehend.","tokens":970,"name":"9.jsnp"}
{"score":"82","reasoning":"The code is a clean Java constructor with consistent structure using addField addSeparator and addAction methods enhancing readability. Descriptive labels via Translator and clear hierarchy aid comprehension. Minor issues include typos like stimili instead of stimuli long chained initializations and domain-specific classes assuming framework knowledge slightly hinder general ease.","tokens":1181,"name":"158.jsnp"}
{"score":"95","reasoning":"Clear JUnit test with descriptive names for limit, offset, input, expected, and actual. Straightforward setup, method call, and assertion. Tests specific SQL dialect behavior accurately. Concatenated expected string is readable but could be multiline for perfection. Overall highly comprehensible and well-structured.","tokens":1080,"name":"24.jsnp"}
{"score":"68","reasoning":"Clear for loop structure iterating over subclass property closures to initialize paths. Descriptive but verbose method names like getSubclassPropertyNameClosure aid understanding. Major issue is the extremely long initPropertyPaths call with 7 parameters, reducing scannability. No comments or formatting breaks. Suitable for familiar developers but challenging for newcomers.","tokens":1060,"name":"105.jsnp"}
{"score":"95","reasoning":"The code is concise, clear, and follows Java best practices by using HashSet for unique strings and returning an unmodifiable set. The purpose is immediately obvious: populate a set with hint constants. Repetitive add calls are the only minor issue, but it remains highly readable and easy to comprehend.","tokens":898,"name":"16.jsnp"}
{"score":"65","reasoning":"The code is straightforward in intent, handling property changes for owned elements by removing nodes or edges based on type. However, it suffers from high repetition in multiple if statements checking similar Model.getFacade().isA* methods, which could be refactored into a switch or map for better readability. Use of outdated Vector, magic string, and repeated facade calls reduce clarity. Logic is easy to follow but verbose.","tokens":1169,"name":"119.jsnp"}
{"score":"35","reasoning":"ANTLR-generated parser method for statement list using labeled do-while loop. Cryptic names like _loop119 and _tokenSet_6 reduce readability. Relies on parser-specific knowledge like LA(1). Clear control flow but not intuitive or self-documenting for general audience.","tokens":1019,"name":"115.jsnp"}
{"score":"85","reasoning":"The code is a concise JUnit test with a descriptive method name explaining the intent: testing timeout on second call despite first exception. Uses expectMessage for verification, silent try-catch to ignore first throw, then triggers timeout. Readable for Java JUnit users, though relies on external setup like thrown rule and TIMEOUT constant. Minor ding for empty catch and broad throws clause.","tokens":988,"name":"160.jsnp"}
{"score":"88","reasoning":"The method has a clear purpose: creating a timeout exception with optional stuck thread handling. Logic flows logically: capture stack trace, build exception, conditionally add stuck thread info using MultipleFailureException. Uses standard Java idioms like String.format, setStackTrace, and Arrays.asList. Variable names are mostly descriptive. Assumes external fields and methods which is fine in context. Minor density in the conditional block but overall highly readable and comprehensible.","tokens":1117,"name":"125.jsnp"}
{"score":"95","reasoning":"Well-documented with Javadoc, clear parameter checks, and descriptive variables like positive and negative stacks. Logic iterates categories then series, accumulating bounds from base intuitively. Handles nulls and creates Range only if valid. Minor terse inline comment, but overall highly comprehensible and professional.","tokens":1496,"name":"41.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear logical flow: notifications, conditional flush with explanatory comment, completion handling, and close. Variable names like flush, isDriver, isInitiator are descriptive. Nested condition in flush check adds minor complexity but remains comprehensible. Professional readability for framework code.","tokens":906,"name":"184.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with clear comments on verification purpose. Inner Verifier class uses DFS traversal via stack to detect NOT-EXISTS pattern in AST, which is straightforward. Tests two HQL queries effectively. Minor deduct: Stack named queue is misleading as it implies FIFO but uses LIFO. Highly readable for Java devs with AST knowledge.","tokens":1222,"name":"87.jsnp"}
{"score":"95","reasoning":"Well-documented with clear Javadoc. Straightforward logic: fetch cache element and return value or null. Proper exception handling for specific CacheException types. Clean structure, good use of final keywords. Easy to comprehend for experienced Java developers. Minor redundancy in else blocks.","tokens":1067,"name":"164.jsnp"}
{"score":"82","reasoning":"Clear Javadoc explains purpose well. Code correctly converts long to big-endian byte array using bit shifts. Repetitive pattern for each byte is explicit but verbose; a loop would enhance readability and conciseness without losing clarity. Straightforward for bit manipulation experts, mildly tedious otherwise.","tokens":1104,"name":"113.jsnp"}
{"score":"88","reasoning":"Well-structured method with clear if-else chain for Hibernate entity dirtiness check. Descriptive names like CustomEntityDirtinessStrategy and explicit casts aid comprehension. SuppressWarnings annotation is appropriate. Minor drawbacks: long lines and verbose calls reduce scanability slightly, but logic flows intuitively for experienced Java developers.","tokens":1177,"name":"111.jsnp"}
{"score":"78","reasoning":"The method has a clear Javadoc comment explaining its purpose. It uses descriptive types like OuterJoinableAssociation and efficient StringBuilder with good initial capacity estimate. Variable names are meaningful. However, the loop is dense with multiple ternary operators, null checks, and conditional suffix assignments, making it harder to follow at a glance. Magic numbers and nested conditions reduce ease of comprehension slightly. Solid for domain experts but verbose for newcomers.","tokens":1358,"name":"34.jsnp"}
{"score":"98","reasoning":"The code is concise, well-structured with proper indentation and simple if statements. Javadoc comment clearly explains the override purpose for detecting line ends via LF or CR. Logic is straightforward and easy to follow, assuming hasLf and hasCr are defined instance variables. Excellent readability.","tokens":1119,"name":"6.jsnp"}
{"score":"98","reasoning":"The code is a straightforward Java constructor with a clear Javadoc comment. It uses consistent single-line registerColumnType calls for mapping JDBC types to FrontBase SQL types, making it extremely readable and easy to comprehend. No redundancy, logical order, and simple structure enhance scannability.","tokens":932,"name":"25.jsnp"}
{"score":"42","reasoning":"Code employs deeply nested anonymous inner classes which obscure flow and increase cognitive load. Heavy reliance on framework-specific classes like InfinispanRegionFactory and JBossStandAloneJtaPlatform demands prior knowledge. No comments or variable names explaining intent further hinder comprehension despite concise structure.","tokens":1043,"name":"132.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with clear assertions, descriptive variable names, and logical flow. Uses standard testing patterns. Minor deductions for domain-specific Hibernate classes with long names, custom ExtraAssertions, and magic numbers like 1 and 0, which assume framework familiarity.","tokens":1067,"name":"142.jsnp"}
{"score":"72","reasoning":"Code is structured with clear if-else chains and explicit type checks, making intent understandable. Consistent naming and indentation aid readability. However, repetitive patterns for event types and listeners reduce maintainability; ranges like ANY_MODULE_EVENT to LAST_MODULE_EVENT feel magic-number-like. Verbose casting and duplication between ANY_EVENT and specific checks slightly hinder comprehension. Suitable for domain experts but refactorable.","tokens":1225,"name":"43.jsnp"}
{"score":"92","reasoning":"The code features clear Javadoc documentation, meaningful parameter and variable names, proper exception handling, and logical structure with try-catch. Indentation is consistent. Slight deduction for long chained method calls like session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract(st) and reliance on Hibernate-specific classes which assume domain knowledge.","tokens":1078,"name":"33.jsnp"}
{"score":"78","reasoning":"The code has clear if-else structure handling double-clicks on two tables, with early returns and straightforward logic for selecting items and setting targets. Positive aspects include concise flow and debug logging. Drawbacks: outdated Java style with raw types and elementAt on Vectors, cryptic variable names like src sel d, no comments, and external dependencies assumed. Readable for experienced developers but could improve with generics and better naming.","tokens":1120,"name":"10.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method with descriptive name clearly indicating purpose. Logical flow: setup, baseline query, progressive filter enabling with comments explaining each step. Clear assertions and standard Hibernate usage. Minor deductions for magic numbers in asserts and long method name, but overall highly readable and comprehensible for Java/Hibernate developers.","tokens":1173,"name":"91.jsnp"}
{"score":"82","reasoning":"Well-structured test method demonstrating clear intent: register pending put, invalidate region or key, verify lock acquisition fails. Proper try-finally ensures lock release. Nested anonymous inner class and domain-specific elements like PutFromLoadValidator add minor complexity requiring context knowledge. Strong readability for familiar developers.","tokens":1122,"name":"173.jsnp"}
{"score":"92","reasoning":"Code is concise, logical, and follows standard JAXB unmarshalling pattern with schema validation. Variable names are clear and descriptive overall, with minor abbreviations like jc and in. Straightforward flow from resource loading to object creation. Assumes JAXB familiarity but highly readable for experienced developers. No redundancy or complexity.","tokens":954,"name":"194.jsnp"}
{"score":"28","reasoning":"Poor readability from inconsistent spacing and indentation in the bytes check, extremely long chained return statement spanning many lines making it hard to follow, mixed use of \u003d\u003d and equals without uniform null safety leading to potential NPEs, distracting commented lines, varying field naming conventions, and custom comparisons like for foo and custom array that assume structures.","tokens":1476,"name":"74.jsnp"}
{"score":"72","reasoning":"Code structure is simple with null check and try-catch, making intent clear: safely release PreparedStatement ignoring errors. However, long chained method call ((SessionImplementor) session).getTransactionCoordinator().getJdbcCoordinator().release(ps) is hard to read and follow due to depth and casting. Minor issues like Throwable catch-all slightly impact comprehension.","tokens":907,"name":"95.jsnp"}
{"score":"98","reasoning":"The code is highly readable with clear Javadoc documentation, proper annotations, and straightforward logic. It explicitly checks each field after type verification, making it easy to follow and understand without ambiguity. Minor repetition in comparisons is clear and beginner-friendly.","tokens":962,"name":"114.jsnp"}
{"score":"88","reasoning":"Well-structured method with descriptive name and parameters. Early return improves readability. Logical if-checks and assignments flow clearly. Section comment and TODO provide context. instanceof check and casting are standard. Deduction for domain-specific Hibernate knowledge required and nested Datatype creation slightly increasing complexity.","tokens":1031,"name":"147.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear Javadoc, proper generics, and nested try-finally for robust execution and cleanup. Todo note adds transparency. Readable for experienced developers familiar with Hibernate, but complex generics and external dependencies like session and processes slightly reduce accessibility for novices. Strong overall comprehension.","tokens":1195,"name":"110.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test with clear logical flow: setup session, create entities, save, query variations, delete. Descriptive names like redValue and property strings aid comprehension. Indentation good. Drawbacks: no assertions to verify outcomes, suppresses unchecked warnings, TODO note, magic strings in queries, assumes Hibernate expertise.","tokens":1258,"name":"80.jsnp"}
{"score":"88","reasoning":"Well-structured Java method using reflection to create test instances. Clear flow: fetch constructor, instantiate based on params, handle TestCase specially. Descriptive vars and comprehensive exception handling with specific messages. Poetic comment adds flavor but not essential. Minor repetition in warnings and external method deps reduce perfection, but highly comprehensible for experienced devs.","tokens":1171,"name":"2.jsnp"}
{"score":"98","reasoning":"Standard Java equals override with clear structure: reference equality, superclass check, class check, null-safe field comparison. Well-indented, conventional, easy to follow for experienced developers. Minor deduction for lack of hashCode mention, but snippet is focused and readable.","tokens":913,"name":"169.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with clear method name and detailed comments explaining the Hibernate bug HHH-1631 and property hierarchies. Consistent use of SyntaxChecker pattern makes it predictable and easy to follow despite repetition. Assumes domain knowledge but comments bridge gaps effectively. Minor verbosity but high readability overall.","tokens":1285,"name":"79.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test with clear comments explaining two historic scenarios for HiLo optimizer. Descriptive variable names, simple loops, and precise assertions aid readability. Minor repetition in test blocks and magic numbers like 10 and -1 slightly reduce perfect score.","tokens":1233,"name":"56.jsnp"}
{"score":"68","reasoning":"The code is a well-structured JUnit test for expecting SQLGrammarException in Hibernate. It uses clear method naming, proper transaction management, try-catch-finally, and comments. However, readability suffers from deeply nested internal Hibernate API calls like ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer(), verbose anonymous inner class, and reliance on external releaseStatement method. Comprehensible for Hibernate experts but challenging for others.","tokens":1083,"name":"94.jsnp"}
{"score":"92","reasoning":"Code is well-structured Swing constructor with clear variable names, logical initialization flow from model setup to layout. Implements listeners appropriately. Minor redundancy in table.setAutoResizeMode calls, but easy to comprehend for experienced Java developers.","tokens":1034,"name":"118.jsnp"}
{"score":"88","reasoning":"The test method has a descriptive name and uses comments to highlight the intent of testing pathological keyword usage as identifiers. Parse calls are on separate lines for clarity, making it easy to identify individual test cases. The intentionally malformed queries are the only complex part, but context makes them comprehensible. Minor deduction for commented-out line.","tokens":1011,"name":"86.jsnp"}
{"score":"88","reasoning":"The code is well-structured with clear purpose: checks for file overwrite confirmation, saves graphics via command pattern, and handles resources properly with try-finally. Descriptive names, logical flow, but minor deductions for long JOptionPane call, hardcoded strings/keys, and slight spacing inconsistencies make it very readable for Java developers.","tokens":1079,"name":"49.jsnp"}
{"score":"78","reasoning":"Well-documented Javadoc explains purpose caveats and references example enhancing comprehension. Clear variable names and straightforward logic in loops for painting ToDoItem clarifiers. However code duplication in two nearly identical loops hurts readability and suggests refactoring opportunity. Outdated Vector usage with elementAt and manual indexing instead of iterators. Magic number -10 in iconY. Still easy to follow overall.","tokens":1270,"name":"121.jsnp"}
{"score":"92","reasoning":"Code is clean, concise, and follows a recognizable hashCode pattern with null safety checks. Clear variable names, proper indentation, and simple logic flow enhance readability. Slight inconsistency in PRIME multiplication timing may affect hash distribution uniformity, but does not hinder comprehension.","tokens":1227,"name":"141.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with detailed comments explaining the Hibernate issue and test cases. Clear logical flow: setup entities, save, run queries with checkCounts, cleanup. Descriptive variable names and SQL strings aid comprehension. Minor points off for reliance on undefined checkCounts method and potential session scoping nuances for experienced readers.","tokens":1336,"name":"78.jsnp"}
{"score":"35","reasoning":"Highly repetitive code with 11 nearly identical doTest calls varying only by boolean arrays, including duplicates like false false true twice. Violates DRY principle, lacks loops or parameterization for better conciseness. Intent to test configurations is clear but tedious to read and maintain.","tokens":1349,"name":"59.jsnp"}
{"score":"92","reasoning":"Clear JUnit test with descriptive variable names and comments explaining intent. Straightforward logic: run timed statement, inspect stack trace for specific method names using simple loop and assertions. Easy to follow for Java testers, minor verbosity in names but high readability overall.","tokens":1110,"name":"161.jsnp"}
{"score":"88","reasoning":"Clear JUnit test for Hibernate refresh after direct SQL update. Logical structure: setup, update via doWork, refresh with lock modes, assertions, cleanup. Anonymous inner class is readable though dated. Dialect-aware SQL construction and skip annotation add context without confusion. Assumes Hibernate familiarity but easy to follow overall.","tokens":1056,"name":"69.jsnp"}
{"score":"88","reasoning":"Well-structured method with descriptive names for parameters, variables, and helpers like getSuperClasses and addToAnnotationLists. Logical nested loops over classes, methods, and fields. Generics are standard Java but slightly complex. Comment clarifies sorting purpose. Highly readable for experienced Java developers.","tokens":1017,"name":"52.jsnp"}
{"score":"95","reasoning":"Clear Javadoc explains purpose precisely. Method name is descriptive. Concise anonymous inner class overrides one method to use addFirstListener, invoking test(). Straightforward structure assumes base class familiarity but remains easy to read and comprehend with minimal complexity.","tokens":905,"name":"53.jsnp"}
{"score":"92","reasoning":"Well-formatted JUnit test with descriptive method name and clear indentation. Nested method calls are readable due to alignment. Purpose is evident: verifying mod properties extraction. Minor deduction for reliance on external TestTools and getCfg context, and long class name.","tokens":887,"name":"165.jsnp"}
{"score":"92","reasoning":"The code is highly readable due to its simple, repetitive structure using consistent registerStrategyImplementor calls for different transaction factories. Clear naming, proper indentation, and predictable pattern enhance comprehension. Slight deduction for code repetition and hardcoded class names which could be refactored for even better maintainability.","tokens":959,"name":"171.jsnp"}
{"score":"92","reasoning":"Standard Java equals method with correct reference and instanceof checks. Idiomatic null-safe ternary comparisons for fields detailId and master. Concise, efficient, and follows best practices. Slightly dense ternaries may challenge beginners, but highly readable for experienced developers.","tokens":866,"name":"70.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear iteration over maps, explicit if-else logic, and helpful comments referencing JPA spec for context. Good use of descriptive variable names and consistent indentation. Minor deduction for code duplication between the two similar loops and potentially confusing map swaps without broader class context, but overall highly readable and comprehensible for experienced developers.","tokens":1517,"name":"27.jsnp"}
{"score":"88","reasoning":"Code is concise, well-indented, and follows clear logical flow for appending select fragments in ORM context. Descriptive method names aid comprehension. Minor deductions for long chained calls and lack of local variables breaking verbosity, assuming framework familiarity.","tokens":1006,"name":"182.jsnp"}
{"score":"92","reasoning":"Well-structured Java code with clear intent: sets up test data for Parent-Child Hibernate entities. Variable names like child_1_1 effectively convey hierarchy. Logical sequence of session management, saves, and associations. Proper indentation and concise. Minor issues: unsorted child save order slightly confusing initially, no comments, broad Exception. Easy to comprehend for experienced developers.","tokens":1185,"name":"76.jsnp"}
{"score":"98","reasoning":"The code is a well-structured Java constructor with clear Javadoc comment explaining its purpose. It delegates to an overloaded constructor using descriptive constants for dimensions and buffers, and inline comments clarify boolean flags like properties, save, print, zoom, and tooltips. This enhances readability and makes intent obvious without ambiguity. Excellent comprehension for any Java developer.","tokens":855,"name":"4.jsnp"}
{"score":"42","reasoning":"The code has deep nested if-else blocks which reduce readability and make logic hard to follow. Variable names like nod and comp are cryptic. Repeated calls to Model.getFacade() could be extracted. TODO comment signals unresolved issues. Uses outdated iterator instead of modern loops. Domain-specific assumptions hinder comprehension without context.","tokens":1139,"name":"155.jsnp"}
{"score":"85","reasoning":"The constructor initializes three lists with a consistent ternary pattern: defensive copy via new ArrayList if non-null, else emptyList. Code is clear, names descriptive, and intent obvious. Minor issues: long lines and repetition could be refactored for better conciseness, but does not hinder comprehension.","tokens":928,"name":"196.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test with clear purpose documented by comment on JPA spec. Logical setup-persist-retrieve-assert flow. Meaningful names like Employee JobInfo. Minor issues: long chained method in assertEquals hinders readability iterator next is verbose assumes entity class familiarity no entity defs in snippet.","tokens":1213,"name":"134.jsnp"}
{"score":"88","reasoning":"The method has clear purpose and logic: checks class types, handles specific cases with logging, throws exception for invalid types. Good use of enums, descriptive names, inline comments clarify intent. Minor deductions for nested if, long exception message lines, and slight redundancy in checks, but highly readable overall.","tokens":1195,"name":"29.jsnp"}
{"score":"92","reasoning":"The code is concise well-structured and highly readable for developers familiar with JUnit. Descriptive method name clear logic flow from setup to assertion. Anonymous inner class is effective though slightly verbose by modern standards. Minor deduction for undefined fMax and TwoTests references which assume context knowledge.","tokens":997,"name":"124.jsnp"}
{"score":"88","reasoning":"Code is clean and straightforward Java constructor initializing listeners with descriptive names and registering them logically grouped by event type. Repetitive setListeners calls are easy to scan but could use a loop for better DRY principle. Casting and Hibernate-specific types assume domain knowledge, slightly reducing general comprehension.","tokens":1010,"name":"139.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with descriptive comments explaining intent and expected behaviors. Clear logical flow: setup, save, flush, scroll to hold resources, expect serialization fail, then close and succeed. Good use of try-catch for assertions. Variable names are straightforward. Minor issues: very long method name and dialect-specific workaround reduce universality slightly.","tokens":1074,"name":"75.jsnp"}
{"score":"45","reasoning":"The method systematically cleans up bidirectional relationships between entities B C D E F G by nulling references and removing from collections before merging and deleting via Hibernate Session. Logic is sequential and purposeful but hindered by cryptic single-letter variable names requiring domain knowledge. No comments or whitespace issues aid flow yet repetition and assumption of entity schema lower ease of comprehension for newcomers.","tokens":1140,"name":"200.jsnp"}
{"score":"88","reasoning":"Code is concise and follows standard Java practices with anonymous inner class for threading. Clear try-finally structure ensures cleanup. Explicit this reference aids comprehension. Slight deduction for inline comment on VA/Java limitation, which may puzzle unfamiliar readers.","tokens":865,"name":"1.jsnp"}
{"score":"95","reasoning":"Excellent Javadoc documentation clearly describes purpose parameters return and exceptions. Straightforward if-else structure with null checks and mode comparisons. Concise logic easy to follow. Proper exception throwing for unknown modes. TODO note adds context without confusion. Highly readable and comprehensible.","tokens":960,"name":"32.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive name, logical sequence of setup, region building, and assertions. Proper resource cleanup with try-finally. Clear property configurations matching assertions. Minor deductions for magic numbers and domain-specific APIs requiring Hibernate Infinispan knowledge, but highly readable for experienced developers.","tokens":1300,"name":"130.jsnp"}
{"score":"72","reasoning":"The code is a JUnit test for Hibernate EJB3 naming strategy, clearly structured with try-catch-finally for setup, verification, and teardown. Purpose is evident from method name and comments. However, it uses outdated Iterator loop instead of for-each, magic strings for table names, abbreviated variables like sf and foundIt, and repetitive assertions in loop. Logging is mixed. Readable for Hibernate experts but less intuitive for juniors due to legacy style.","tokens":1370,"name":"137.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test using JPA Criteria API with clear variable names like orderRoot and customerSubquery. Logical progression from query creation to subquery correlation and exists clause. Single comment aids understanding of correlated subquery. Concise and readable for Java JPA experts, minor density for novices.","tokens":1069,"name":"163.jsnp"}
{"score":"92","reasoning":"Code is highly readable: clear method purpose, well-commented switch cases with specific SQLState codes, consistent use of extractUsingTemplate pattern, and graceful exception handling. Easy to follow PostgreSQL dialect logic. Minor issues: magic numbers could be named constants, TODO comment indicates incompleteness.","tokens":1036,"name":"22.jsnp"}
{"score":"92","reasoning":"The code is highly readable with a clear Javadoc summary outlining the three main steps. Logical flow: clear caches, iterate over entries with descriptive names, handle postFlush, removal of dereferenced collections, and key recreation. Uses modern Java idioms like enhanced for-loop on Map.Entry. Minor complexity from Hibernate-specific classes like PersistenceContext and CollectionKey, but well-explained inline comments aid comprehension. Professional quality.","tokens":1177,"name":"66.jsnp"}
{"score":"72","reasoning":"The code is a well-structured Hibernate test method testing escaped JDBC queries with dialect-specific handling for TimesTen. Clear setup teardown and assertions aid comprehension. However legacy API lacks generics long SQL strings with complex alias mappings like {a.id} and magic table entity names reduce readability for non-experts. Good for Hibernate veterans.","tokens":1305,"name":"71.jsnp"}
{"score":"85","reasoning":"Concise JUnit test method with clear purpose: verifies transaction status and session creation without auto-joining. Assertions are straightforward. Minor issues include repeated long calls to getTransactionManager which could be extracted to a variable for better readability, and reliance on external context like sessionFactory. Overall easy to comprehend for familiar developers.","tokens":969,"name":"128.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method for Hibernate. Clear separation of setup data insertion, query execution with assertion, and cleanup deletion. Meaningful variable names, standard session management, and annotations. Intent to test empty IN list query returning zero results is immediately comprehensible. Minor indentation quirk at start but does not hinder readability.","tokens":1055,"name":"77.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test method with logical progression of setting cache hints and verifying JPA hints plus Hibernate query cache modes via assertions. Repetitive patterns enhance clarity for testing different combinations. Minor issues: hacky casting to internal Hibernate classes like AbstractQueryImpl and HibernateQuery may confuse non-experts and reduce portability. No comments but self-explanatory for domain knowledge holders.","tokens":1470,"name":"162.jsnp"}
{"score":"88","reasoning":"The method is concise, with a single responsibility: creating a strategy instance and using it to build a LoadPlan. Parameter passing is clear, and the flow is straightforward. Long, verbose type names like FetchStyleLoadPlanBuildingAssociationVisitationStrategy slightly hinder quick readability, but overall structure aids comprehension for Java developers familiar with similar patterns.","tokens":1026,"name":"143.jsnp"}
{"score":"72","reasoning":"Code has clear intent for handling column naming with strategy application. Nested ifs create moderate complexity, reducing flow. Redundant normalization calls and chained assignments on columnName make it less straightforward. Comment adds clarity but inline logic could be extracted to methods for better readability. Suitable for experienced devs but not ideal for quick comprehension.","tokens":981,"name":"30.jsnp"}
{"score":"88","reasoning":"Code is clear and concise, with straightforward logic: checks if parent is a class, collects various dependencies via facade into a HashSet, returns it or null. Consistent structure and naming aid comprehension. Minor repetition in facade calls could be optimized by caching the facade instance. No comments needed due to self-explanatory nature. Suitable for Java developers familiar with facade pattern.","tokens":1122,"name":"123.jsnp"}
{"score":"85","reasoning":"The code is a straightforward JUnit test method for Hibernate HQL select expressions, covering functions like lower, concat, sum, abs, joins, and parameters. Setup and teardown are clear. Repetitive query executions without assertions or result checks make it slightly monotonous and less comprehensive, but indentation, naming, and structure enhance readability for developers familiar with Java and Hibernate.","tokens":1726,"name":"83.jsnp"}
{"score":"78","reasoning":"Code is readable with helpful Javadoc explaining purpose caching and complexity. Logic flows clearly: direct hashtable check then linear interface search with caching. Drawbacks include outdated Enumeration Hashtable usage abbreviated vars like chlist similar names cls clazz minor Javadoc typos like noone. Comprehensible for experienced Java devs but could improve with modern idioms better naming.","tokens":1251,"name":"44.jsnp"}
{"score":"92","reasoning":"Well-documented Javadoc with clear params and return. Logical flow: checks synthetic props, logs trace, wraps context, resolves metadata, handles plural/singular cases. Meaningful names like ownerType, attributeMetadata. Generics handled properly with suppressions. Minor complexity in metamodel types and casts, but highly readable for experienced Java/Hibernate devs.","tokens":1340,"name":"84.jsnp"}
{"score":"68","reasoning":"ANTLR lexer method for hex digits using switch on lookahead char with matchRange for 0-9, A-F, a-f. Structure is clear but verbose case lists and underscore-prefixed vars reduce readability. No comments or whitespace optimization. Comprehensible for parser experts, dense otherwise.","tokens":1231,"name":"117.jsnp"}
{"score":"95","reasoning":"The code is highly readable with a clear Javadoc comment explaining purpose and exceptions. The method performs straightforward serialization: default write followed by consistent SerialUtilities calls for shapes, paints, and strokes. Repetition is logical and easy to comprehend, with excellent variable naming and no complex logic.","tokens":944,"name":"38.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with clear sequential assertions verifying transaction states before and after operations. Logical flow from setup to explicit join. Minor issues include verbose casts like SessionImplementor and TransactionImplementor, and reliance on Hibernate internals which may reduce accessibility for non-experts. Overall highly readable for familiar audience.","tokens":1207,"name":"127.jsnp"}
{"score":"98","reasoning":"The code is highly readable with clear Javadoc documentation, standard equals method structure, simple loops for value comparison, proper null checks, and consistent indentation. Logic is straightforward and easy to follow for any Java developer familiar with dataset equality.","tokens":1016,"name":"40.jsnp"}
{"score":"95","reasoning":"Simple debug method printing SQL strings and suffixes for comparison using clear labels and dashed separators. Well-formatted with line breaks on long println statement. Straightforward logic, good use of StringHelper.join. Easy to read and understand despite hardcoded outputs.","tokens":1015,"name":"144.jsnp"}
{"score":"92","reasoning":"The code is a clear JUnit test for Hibernate one-to-one association with generated IDs. It uses descriptive variable names like Child c2 and ChildInfo info, proper try-catch-finally structure for session management, and expected exception handling with fail assertion. Comments explain intent. Slight nesting and domain-specific assumptions minorly impact general comprehension.","tokens":1029,"name":"129.jsnp"}
{"score":"92","reasoning":"Code is highly readable: clear Javadoc, simple if-null initialization, descriptive constant names from Critic class make purpose obvious. Repetitive addElement calls are straightforward but could be refactored. Legacy Vector use is dated but does not hinder comprehension. Overall easy to understand.","tokens":1010,"name":"45.jsnp"}
{"score":"78","reasoning":"Code follows Java conventions with clear structure and logical flow: checks implicit index, builds holders, sets binders, handles one-to-many backrefs. Variable names are descriptive. However, dense framework-specific logic (Ejb3Column, SimpleValueBinder, Hibernate internals) and long expressions reduce ease for non-experts. Professional but context-dependent readability.","tokens":1276,"name":"109.jsnp"}
{"score":"68","reasoning":"Code has clear structure with super call, locals extracted, and invokeLater for thread safety. Comment explains concurrent region logic well. However, uses risky string \u003d\u003d comparison with TODO note, magic strings incoming/outgoing, unchecked casts to Collection, framework-heavy with Model facade assuming prior knowledge, reducing ease of comprehension for outsiders.","tokens":1160,"name":"154.jsnp"}
{"score":"62","reasoning":"Code logic is straightforward: checks if port is ClassifierRole, retrieves association ends, iterates to collect associations. However, outdated Vector usage with wasteful comment, poor variable names (cr, aer, res), no generics, and reliance on external Model facade reduce readability and modern comprehension. Structure is clear but dated style hinders ease.","tokens":970,"name":"120.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test method with descriptive name and logical steps for Hibernate natural ID caching test. Comments explain key actions like insert update and flush effects. Clear assertions. Minor issues: typos like excpect in assert message, generic variable name it, and minor indentation. Easy to comprehend for Java Hibernate users.","tokens":1245,"name":"179.jsnp"}
{"score":"78","reasoning":"Code has clear structure with logical flow: handles bidirectional references first, then iterates over fetches distinguishing EntityFetch and CompositeFetch. Good use of final variables and descriptive names. However, long parameter list, recursive self-call, and instanceof checks reduce readability slightly. Assumes domain knowledge of ORM concepts, making it moderately easy to comprehend for experienced Java developers.","tokens":1171,"name":"197.jsnp"}
{"score":"68","reasoning":"The code parses command-line args for JUnit filters with clear intent but suffers from manual index manipulation via ++i inside the loop, making flow harder to track. Unusual for condition i !\u003d args.length instead of i \u003c args.length. Nested ifs for filter handling are okay but redundant checks exist. Relies on external vars like parserErrors and filter without declaration. Try-catch is well-placed. Readable for experienced devs but confusing for beginners due to loop control.","tokens":1406,"name":"15.jsnp"}
{"score":"88","reasoning":"The test method has a clear purpose testing HiLo ID generation with visual separators using tildes for sections. Comments explain initial state and historical behavior effectively. Repetitive generate-assert patterns are consistent and easy to follow step-by-step. Minor deductions for verbose casting like SessionImpl and Long, and lack of loop for repetition, but overall highly comprehensible.","tokens":1305,"name":"17.jsnp"}
{"score":"85","reasoning":"Code has clear purpose and logical flow: translates event, manages editor state, handles tooltips conditionally, delegates to managers. Descriptive names like currentFig and tip help. Deductions for distracting commented lines, nested ifs in tooltip logic, and reliance on Globals which assumes context knowledge.","tokens":1073,"name":"122.jsnp"}
{"score":"92","reasoning":"Well-structured method with clear if-else chain handling different Test types using instanceof and casting. Logic is straightforward, recursive for suites, concise variable names like tc and ts. Easy to follow for Java/JUnit familiarity. Minor issues: instanceof chain less ideal than polymorphism, single comment, undefined createSuiteDescription assumed external.","tokens":1073,"name":"54.jsnp"}
{"score":"88","reasoning":"Code has clear method name and logical flow: copies annotation values, checks for schema and catalog presence, adds defaults if missing, creates new instance. Descriptive variables like schemaDefined aid comprehension. Straightforward conditionals. Minor verbosity in list creation and lack of comments prevent perfect score.","tokens":1221,"name":"195.jsnp"}
{"score":"72","reasoning":"The code is a clean JUnit test method with consistent assertEquals structure checking revisions for entities. Repetition is clear but could be looped for brevity. Major issue is overly long class names like ChildIndexedListJoinColumnBidirectionalRefIngEntity which hinder quick reading. Cryptic vars like ing1_id assume prior context. Overall comprehensible with domain knowledge but not highly readable.","tokens":1153,"name":"185.jsnp"}
{"score":"65","reasoning":"Code structure is clear for reading file lines and parsing sections using a state flag inSection. Intent is comprehensible but variable names are terse like f fr mAry. Major issue: last sections content not stored as put only triggers on next section. Lacks try-with-resources no explicit FileReader close. Relies on undefined getSectId LINE_SEPARATOR LOG. Readable for experienced Java devs but bugs and style issues reduce ease.","tokens":1364,"name":"48.jsnp"}
{"score":"82","reasoning":"The method uses a clear chain of if-else statements to handle specific collection property names, each with appropriate validation and SQL column generation. Logic flows logically, exceptions have descriptive messages. Repetition in fetching column names and checking lengths makes it slightly verbose and refactorable with a switch or map. Lacks comments but comprehensible for Java ORM experts.","tokens":1450,"name":"108.jsnp"}
{"score":"82","reasoning":"The code is a standard Java toString method using StringBuilder for efficient concatenation. Chaining append calls with line breaks improves readability. Easy to comprehend the purpose: building a formatted string of statistics fields. Minor issues: no spaces after equals signs in labels, long chain slightly dense, inline method call getExecutionAvgTime. Overall clear and professional.","tokens":1084,"name":"63.jsnp"}
{"score":"78","reasoning":"Code has clear sequential logic: bind self, eval to list, iterate and process values with type checks via Model facade, append non-empty to buffer with separator. Good use of iterator and conditional appends. Deducts for domain-specific Model calls, magic strings like misc.name.anon, reused var v, old iterator style over for-each, and assumed instance fields like _scratchBindings. Readable for experts, less for general audience.","tokens":1277,"name":"8.jsnp"}
{"score":"85","reasoning":"Code is concise and follows standard Java practices with clear try-catch for error handling and informative exceptions. Logic flows logically: retrieve type, validate against cached value, return or throw. Minor deducts for grammar error in exception message SQLType codes does not match, redundant getSqlTypeCode call, and reliance on undeclared fields like name assuming class context. Easy to comprehend for Hibernate users.","tokens":1280,"name":"37.jsnp"}
