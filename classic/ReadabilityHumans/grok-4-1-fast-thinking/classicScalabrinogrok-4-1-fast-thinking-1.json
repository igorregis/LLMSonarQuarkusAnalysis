{"score":"98","reasoning":"The code is exceptionally readable with comprehensive Javadoc explaining purpose, parameters, and return value. Method name is descriptive, body is concise and straightforward, directly mapping registration fields to constructor args. No redundancy or complexity, highly comprehensible for any Java developer.","tokens":799,"name":"67.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method with clear Javadoc explaining purpose. Logical flow testing two dialects with identical setup and assertions. Descriptive variable names, concise code, and effective use of assertions for verification. Highly readable for Java developers familiar with Hibernate generators.","tokens":1048,"name":"57.jsnp"}
{"score":"92","reasoning":"The code is a concise override method in Java for Hibernate configuration. It clearly sets properties in sequence using standard setter patterns. Super call first is good practice. Chained methods like getCacheRegionFactory().getName() are readable. No comments but self-explanatory for Java devs familiar with Hibernate. Minor deduction for assuming domain knowledge.","tokens":918,"name":"191.jsnp"}
{"score":"98","reasoning":"The code is a concise JUnit test method with a descriptive name clearly indicating its purpose. It follows standard Hibernate patterns: open session, begin transaction, persist entity, flush, rollback, close. Straightforward logic, proper indentation, no redundancy or complexity, making it highly readable and easy to comprehend for any Java developer familiar with ORM.","tokens":810,"name":"133.jsnp"}
{"score":"82","reasoning":"Clear JUnit test verifying c3p0 PooledDataSource MBean attributes using JMX. Logical structure with good variable names and a helpful comment. Minor issues include inconsistent indentation, long lines, and magic numbers in asserts, which slightly hinder perfect readability but do not obscure comprehension.","tokens":1177,"name":"90.jsnp"}
{"score":"98","reasoning":"Code is concise, well-indented, and follows good practices with Override annotation, null check before closing reader, and try-catch for IOException handling. Intent is clear: safely release resource ignoring errors. Empty catch with ignore variable enhances readability. Minor deduction for not using try-with-resources, but excellent overall comprehension.","tokens":867,"name":"150.jsnp"}
{"score":"68","reasoning":"The test method has a clear purpose with straightforward assertTranslation calls testing query translations. However, readability is hampered by long repetitive instanceof chains in multiple if conditions, making them hard to parse at a glance. Dialect exclusions are explicit but could benefit from helper methods or constants for better maintainability and comprehension.","tokens":1234,"name":"89.jsnp"}
{"score":"95","reasoning":"Clear JUnit test method with descriptive name testing Hibernate query failure. Well-structured: opens session, executes query in try-catch, expects QueryException, fails if not. Concise, standard patterns, easy to comprehend for Java/Hibernate developers.","tokens":846,"name":"81.jsnp"}
{"score":"72","reasoning":"Clear JUnit test structure verifying entity revision history. Asserts are straightforward and logical. However, excessively long class names like ChildIndexedListJoinColumnBidirectionalRefIngEntity hinder readability. Repetitive audit reader finds for rev1-rev4 could use a loop for better conciseness. Assumes external IDs defined elsewhere. Overall comprehensible but verbose.","tokens":1191,"name":"186.jsnp"}
{"score":"98","reasoning":"The code is a concise Java constructor for a database dialect class with a clear Javadoc comment. It calls super then registers multiple SQL functions using consistent registerFunction calls. Each line is straightforward with descriptive function names and StandardBasicTypes. Formatting is clean and uniform making it highly readable and easy to comprehend for experienced developers.","tokens":1027,"name":"21.jsnp"}
{"score":"82","reasoning":"Code is well-structured with a clear Javadoc comment and logical flow: handles optimistic locking case, generates delete SQL, then executes in loop. Descriptive names like loadedState and deleteStrings aid readability. Assumes Hibernate knowledge, adding slight complexity, but overall comprehensible for experienced developers.","tokens":1107,"name":"106.jsnp"}
{"score":"85","reasoning":"Clear override of runTest using anonymous Thread inner class to run test asynchronously, with try-finally for cleanup via runFinished. Comments note inlining due to VA/Java limitation, replacing super call. Readable and comprehensible for Java developers familiar with threading and JUnit patterns, though anonymous class adds minor verbosity.","tokens":950,"name":"73.jsnp"}
{"score":"95","reasoning":"Code is highly readable with clear structure, descriptive variable names like bufferReader and eventBuffer, and helpful comments explaining iterator usage and buffering logic. Flow is straightforward: check buffer first, fallback to parent, manage buffer size. Proper use of final variables and indentation. Slight deduction for a few long lines but overall excellent comprehension.","tokens":1048,"name":"151.jsnp"}
{"score":"72","reasoning":"Code is straightforward Java main loop generating UUIDs via bit manipulation on timestamp bytes. Extensive debug prints enhance traceability but create visual clutter with repetitive tildes. Magic numbers like 0x3f and casts reduce clarity. Dependencies on undefined BytesHelper and Helper obscure full comprehension. Suitable for experts familiar with UUID format.","tokens":1373,"name":"58.jsnp"}
{"score":"35","reasoning":"The equals method starts with standard null and reference checks, which are clear. However, the single return statement chains multiple nested ternary operators for name, schema, and catalog comparisons, handling nulls, quoting, and case sensitivity. This extreme nesting and length severely reduce readability and ease of comprehension, requiring significant effort to parse the logic.","tokens":960,"name":"36.jsnp"}
{"score":"88","reasoning":"The code is concise and logically structured, handling single vs composite keys clearly with nested conditions based on dialect support. Helper methods like StringHelper.replace and repeat enhance brevity. Assumes context for constants like BATCH_ID_PLACEHOLDER and functions like joinWithQualifier, which may confuse newcomers. Variable names are mostly clear, overall highly readable for experienced Java developers.","tokens":1015,"name":"112.jsnp"}
{"score":"96","reasoning":"Clean Java constructor for InterbaseDialect with clear Javadoc comment. Registers column types and functions in logical sequence, each on separate line for easy readability. Consistent method calls and formatting enhance comprehension. Minor deduction for lack of grouping similar types but overall excellent.","tokens":1027,"name":"20.jsnp"}
{"score":"82","reasoning":"The method has clear if-else structure handling NULL empty valid and invalid inputs logically. It correctly manages bidirectional Person-Address relationship by adding to new and removing from old. Repetition in old address removal code could be refactored into a helper. Magic strings like NULL and empty check slightly hurt readability. Suitable for Java devs familiar with JPA.","tokens":1168,"name":"61.jsnp"}
{"score":"82","reasoning":"The code is a well-structured JUnit test for Hibernate orphan delete, with clear setup persist remove verify flow across sessions. Logical progression aids comprehension. Minor deductions for typos in strings like Widge and if instead of of, lack of comments, and reused variable names. Cache handling is explicit and correct. Easy to follow for Java Hibernate experts.","tokens":1325,"name":"192.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive variable names like ed1 ed2 rev1-rev5. Straightforward logic: fetch entities and audit revisions then assert set equality. Repetitive assertions for rev2-rev5 could be refactored but do not hinder comprehension. Assumes external context like IDs and TestTools but overall highly readable for Java Hibernate Envers users.","tokens":1126,"name":"166.jsnp"}
{"score":"85","reasoning":"Well-structured override method with clear intent: adds a custom Hibernate integrator for event listeners. Methods are concise with single responsibilities. Minor duplication in two integrate methods calling the same private method. Anonymous inner class is readable but verbose by modern standards. Strong readability for experienced Java developers.","tokens":1026,"name":"174.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test with clear purpose, descriptive comments explaining the scenario, logical flow using try-finally for cleanup, and precise assertions verifying cache configurations. Variable names are appropriate. Minor deductions for magic numbers like 60000 and 30000, repetitive property settings, and domain-specific knowledge required for full comprehension.","tokens":1255,"name":"131.jsnp"}
{"score":"78","reasoning":"Well-structured method with logical flow for parsing XML filter elements. Descriptive variable names and proper null checks enhance readability. Handles multiple condition sources clearly. Drawbacks include outdated raw Iterator and HashMap without generics, verbose TODO comment on design issue, and slight redundancy in condition logic. Comprehensible for experienced Java developers familiar with ORM contexts.","tokens":1361,"name":"31.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear variable names like middleEntityXml and logical flow: schema/catalog setup, entity creation, conditional where clause, ID configuration, and relations. Helpful comments clarify purpose. Minor issues: domain-specific terms and external dependencies need context, but overall highly readable for experienced developers.","tokens":1251,"name":"170.jsnp"}
{"score":"87","reasoning":"The method is concise and follows a clear pattern of copying properties from source to binding using simple setter calls. Variable names are descriptive and logic flows logically. Minor redundancy in two if blocks for custom persister class slightly reduces clarity but does not hinder overall comprehension. Suitable for developers familiar with Hibernate APIs.","tokens":1291,"name":"146.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with descriptive variable names and clear assertions. Handles indeterminate iterator order logically via if-else. Comment aids understanding. Minor issues: long method name, repetitive assertTrue calls, and domain-specific terms like EntityBinding require context knowledge, impacting general readability.","tokens":1248,"name":"181.jsnp"}
{"score":"72","reasoning":"Well-structured JUnit test for Hibernate HQL with join fetch. Clear purpose from long method name. Anonymous inner classes for HqlExecutor and ResultChecker are standard but verbose. Assertions are precise, checking list size, entities, courses, and lazy loading conditionally. Assumes external variables like yogiExpected. Readable for Hibernate experts, less so for novices due to domain specifics and nesting.","tokens":1294,"name":"98.jsnp"}
{"score":"78","reasoning":"The code is a straightforward JUnit test method using assertNoLoss on various SQL queries. Java syntax is clean and simple, with clear method structure. However, embedded SQL strings are long, unformatted, and complex with joins, conditions, and functions, making them difficult to read and comprehend without reformatting. Lacks comments for context.","tokens":1516,"name":"101.jsnp"}
{"score":"72","reasoning":"Code is concise and logically structures boundary points using arrays for a closest-point calculation on a rectangle. Integer division for centers is standard. However, duplicate top-center point is confusing, magic number 5 lacks explanation, and dependency on undocumented Geometry.ptClosestTo reduces immediate comprehension without context.","tokens":1291,"name":"153.jsnp"}
{"score":"98","reasoning":"Standard Java equals method with clear structure using early returns for quick failures. Proper null-safe string comparisons via ternary operators, which are idiomatic. Concise, efficient, and highly readable for experienced developers, with intuitive logic flow.","tokens":896,"name":"60.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with clear purpose: testing FK constraint violation via invalid insert. Proper annotations, transaction handling, exception expectation, and resource cleanup in try-finally. Comments aid understanding. Drawbacks: verbose anonymous Work class, lengthy internal Hibernate API chain for JDBC (hard to follow), magic numbers for IDs. Readable for ORM experts but less so for general audience.","tokens":1193,"name":"93.jsnp"}
{"score":"85","reasoning":"Well-structured Java method with clear purpose: updates listeners for stereotype changes in a model. Logical flow with if conditions, good indentation, and inline comments aid readability. Minor deductions for magic string stereotype, instanceof reliance, and assumption on event types having new/old values. Comprehensible for experienced Java devs.","tokens":976,"name":"47.jsnp"}
{"score":"68","reasoning":"The code has clear structure and standard Java idioms, with descriptive flags like updatingSelection to avoid recursion. However, nested loops scanning all rows for each target are inefficient and reduce clarity. Verbose expressions like getPathForRow(j).getLastPathComponent() and magic booleans hinder quick comprehension. Lacks comments explaining purpose or assumptions about Fig and tree nodes. Overall moderately readable for experienced Java devs familiar with Swing trees.","tokens":1108,"name":"50.jsnp"}
{"score":"62","reasoning":"This JUnit test method tests Hibernate queries on collections effectively but readability suffers from a lengthy dialect exclusion if-statement, numerous inline complex HQL strings without constants or comments, scattered assertions without descriptive variables, and a linear flow mixing setup teardown and tests. Experienced Hibernate developers can follow it but juniors may struggle with comprehension.","tokens":1458,"name":"68.jsnp"}
{"score":"72","reasoning":"The code is a well-structured JUnit test for Hibernate lazy associations using anonymous inner classes, which clearly define CriteriaExecutor, HqlExecutor, and ResultChecker. Method intent is evident from name and comments. However, verbosity from nested anonymous classes, repeated type casts like ((Student)), long assertion lines, and minor redundancy in checks slightly hinder readability for newcomers. Suitable for experienced Java/Hibernate developers.","tokens":1272,"name":"96.jsnp"}
{"score":"88","reasoning":"Well-structured method with descriptive names and logical flow for processing discriminator annotations. Ternary operators used effectively. Handles edge cases like parent inheritance clearly. Verbose fully qualified class names slightly reduce readability but do not hinder comprehension for experienced Java developers.","tokens":1151,"name":"28.jsnp"}
{"score":"25","reasoning":"Code suffers from extremely long chained method calls on internal Hibernate objects like SessionImplementor, making it very hard to follow. Hardcoded SQL strings, silent exception ignoring on drop, and anonymous inner class add to poor readability. Purpose of dropping and recreating table is inferable but implementation is obfuscated and brittle.","tokens":1079,"name":"100.jsnp"}
{"score":"72","reasoning":"The test method is well-structured with clear purpose using Hibernate Criteria and HQL for multi-select with joins. Anonymous inner classes for executors and checker add verbosity, making it harder to scan. Variable names are descriptive, assertions precise, but requires Hibernate expertise and external vars like yogiExpected reduce standalone readability. Overall solid but dated style impacts score.","tokens":1318,"name":"99.jsnp"}
{"score":"98","reasoning":"The code is a clean, standard Java equals override with proper Javadoc. It uses clear sequential checks: reference equality, instanceof, and super.equals. Highly readable and easy to comprehend, assuming no additional fields in PinNeedle as superclass handles comparison. Minor deduction for potentially incomplete logic if fields exist.","tokens":948,"name":"39.jsnp"}
{"score":"92","reasoning":"The code features a clear Javadoc comment detailing the methods purpose. It employs standard Java naming conventions, descriptive parameters like generatedId and state, and simple control flow with an if statement followed by an unconditional call. Method chains are logical and typical for ORM frameworks like Hibernate, enhancing readability for experienced Java developers despite domain-specific APIs.","tokens":1066,"name":"103.jsnp"}
{"score":"68","reasoning":"Complex JUnit test for Hibernate listeners with clear intent from method name. Logical flow from setup to verification but lengthy with repetitive checkResult calls, multiple casts, instanceof branches, and index tracking. Assumes deep Hibernate knowledge, lacks helper methods for better modularity, impacting readability for non-experts.","tokens":1505,"name":"140.jsnp"}
{"score":"88","reasoning":"Code is concise with clear if-else logic for handling single vs multiple primary key join columns. Descriptive method names and consistent formatting aid readability. Minor issues: unusual MockHelper utility name and reliance on external constants like PRIMARY_KEY_JOIN_COLUMNS slightly reduce universality, but easy to follow overall.","tokens":970,"name":"193.jsnp"}
{"score":"72","reasoning":"The code is a concise JUnit test with clear purpose: populating properties and verifying filtered output. Structure is simple and linear, easy to follow. However, magic strings for keys and values lack constants, duplicate password entry is redundant and confusing, hardcoded credentials reduce clarity, and prefixed keys like rpt.1 add unnecessary noise. Minor issues like broad Exception throw. Comprehensible but needs cleanup for better readability.","tokens":1155,"name":"35.jsnp"}
{"score":"82","reasoning":"Well-structured method with clear parameter names indicating optionality and logical if-else flow. Handles Hibernate-specific logic cleanly, distinguishing persister retrieval and composite ID cases. Minor deductions for long chained condition, deep nesting, and no inline comments, assuming domain knowledge for full comprehension.","tokens":1147,"name":"198.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method testing Hibernate JPA annotations. Clear logical flow: build context, get field, create reader, assert annotations properties. Descriptive assertions and variable names enhance readability. Standard practices used. Minor issues: long method could be split, magic strings for paths and values reduce slight portability.","tokens":1370,"name":"135.jsnp"}
{"score":"92","reasoning":"Well-documented Javadoc explains purpose and exceptions clearly. Method name is descriptive. Logic is straightforward: if empty log trace else extract first dependent action dependencies and throw detailed TransientPropertyValueException. Variable names are long but descriptive. Chained iterator next calls add slight complexity but code is professional and easy to follow for Java ORM experts.","tokens":1179,"name":"102.jsnp"}
{"score":"92","reasoning":"Code is concise, well-structured JPA test method with clear transaction flow: begin, persist Country entity, commit. Purpose evident from name and comment. High readability due to simplicity and standard patterns. Minor deductions for hardcoded ID/name reducing flexibility and no exception handling, but easy to comprehend overall.","tokens":1012,"name":"168.jsnp"}
{"score":"82","reasoning":"Code is concise, well-indented, and includes a clear comment explaining intent. Logic is simple: conditional reassociation of proxy if value not null. Deductions for unused entityType parameter and unconditional null return, which obscure purpose and reduce comprehension.","tokens":1014,"name":"65.jsnp"}
{"score":"78","reasoning":"Code has clear purpose with Javadoc, logical flow checking cache first then loading via default and custom classloaders. Variable names are descriptive. Drawbacks include outdated Iterator usage instead of for-each, verbose logging, potential null bundle insertion, minor indentation quirks, and no thread-safety for static map. Overall comprehensible but dated style reduces score.","tokens":1085,"name":"7.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test with descriptive method name and annotations. Query string is clear and final. Expected SQL is concatenated readably despite length and nesting. Consistent indentation aids comprehension. Slight deduction for SQL complexity potentially confusing non-SQL experts.","tokens":1176,"name":"23.jsnp"}
{"score":"92","reasoning":"Code is highly readable with StringBuilder chained appends split across lines for clarity. Defensive null check on region with helpful comment prevents errors. Logical flow from class name to stats and closing bracket is straightforward. Minor deduction for lengthy chain potentially wrapping poorly in some editors but excellent overall comprehension.","tokens":1051,"name":"64.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with clear annotations explaining purpose and dialect skips. Logical flow: native SQL inserts to force whitespace, Hibernate queries with assertions, parameterized query test, and cleanup. Uses final locals appropriately. Assumes Hibernate knowledge for SessionImplementor and EnumType, but easy to follow. Minor nit: SQL string concatenation and direct connection access are test-idiomatic but not ideal.","tokens":1327,"name":"136.jsnp"}
{"score":"68","reasoning":"The method logic is straightforward: peek stack, create classifier if possible, generate and write code or copy original via ffCodePiece. Structure is clear with if-else. However, undefined name variable, external dependencies like GeneratorJava and ffCodePiece lack explanation, commented-out cast is distracting, outdated Stack and StringBuffer reduce modernity. Assumes domain knowledge, moderately comprehensible.","tokens":1170,"name":"116.jsnp"}
{"score":"85","reasoning":"Clear unit test for failure output in a test framework. Logical structure: defines expected output, customizes printer with override, sets up failing test case, runs suite, asserts result. Anonymous inner classes are standard Java but verbose. Assumes context like runner and expected helper. Easy to follow for experienced Java devs.","tokens":1005,"name":"12.jsnp"}
{"score":"92","reasoning":"Well-documented equals method with standard implementation pattern: identity check, type check, field comparisons. Clear variable names and straightforward logic using early returns. Highly readable and easy to comprehend, though Javadoc return description mentions only second and minute while code also checks hour and day, creating minor inconsistency.","tokens":1183,"name":"42.jsnp"}
{"score":"78","reasoning":"The code is a well-structured JUnit test with logical flow: setup map, assert revisions, modify, query deletion. Variable names are descriptive, assertions clear. However, magic numbers (15,16,17) for revisions lack explanation, external vars (ternaryMapId, intEntity1) assumed from setup, and Envers-specific API (AuditReader, RevisionType) requires domain knowledge, impacting standalone comprehension.","tokens":1190,"name":"167.jsnp"}
{"score":"68","reasoning":"The code uses clear structure with try-finally for barrier synchronization, precise timing with nanoTime, and conditional trace logging. Variable names like start, end, duration, runs are intuitive. However, extensive commented-out while loop and related lines create confusion about the actual execution flow, as queryItems is called once outside it with runs remaining 0, lowering overall comprehension.","tokens":1470,"name":"172.jsnp"}
{"score":"62","reasoning":"Code logic is clear: notifies tree changes for posters with removed items. However, uses outdated Vector and Enumeration instead of modern collections. Redundant ToDoList fetch twice. Log message typo (singular vs plural). Unclear comment source?. Inner loop inefficient but simple. Overall comprehensible but dated and improvable style reduces readability.","tokens":1394,"name":"46.jsnp"}
{"score":"92","reasoning":"Clear JUnit test method with descriptive name and logical flow: setup reader then series of assertAnnotationNotPresent calls followed by positive assertions on ElementCollection. Repetitive negative checks are straightforward and easy to scan. Assumes JPA knowledge but code is concise self-explanatory and well-structured for comprehension.","tokens":1120,"name":"176.jsnp"}
{"score":"92","reasoning":"The code is highly readable with clear structure, descriptive logging, and precise if-else logic for handling element types. Uses final locals effectively, throws meaningful exceptions. Minor issues: long lines in log and exceptions, assumes Hibernate domain knowledge which aids experts but may challenge newcomers.","tokens":1041,"name":"183.jsnp"}
{"score":"68","reasoning":"Code logic is clear: checks aggregation kind and sets corresponding command. However, deep nesting of if-else statements reduces readability and makes it harder to follow flow. Repeated calls to Model.getAggregationKind() getters are redundant. Awkward line breaks in long expressions. Could be improved with flatter if-elseif chain or switch on enum for better comprehension.","tokens":1144,"name":"157.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with descriptive name and detailed comments explaining the Hibernate issue HHH-2277 involving bidirectional eager fetching and composite PK. Clear variable names, logical flow: setup entities, save, load with error handling, cleanup. Assumes Hibernate knowledge but easy to follow for experienced developers. Minor snippet formatting quirks do not detract much.","tokens":1221,"name":"175.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive name testing Hibernate distinct select with join, pagination, and no duplicates. Standard structure: setup, query execution, assertion, teardown. Query HQL is readable. Minor deductions for typo in assert message (dublicated instead of duplicated), suppressed unchecked warning without context, and reliance on external feedDatabase for test data. Highly comprehensible for Java/Hibernate developers.","tokens":1101,"name":"92.jsnp"}
{"score":"88","reasoning":"Well-structured chain of if-else statements with clear precedence logic for selecting loaders. Comments provide excellent context for each condition, improving comprehension. Descriptive names and straightforward flow. Minor deductions for long lines, type casts, and domain-specific assumptions requiring Hibernate knowledge.","tokens":1205,"name":"107.jsnp"}
{"score":"98","reasoning":"The code is a clean Java constructor for a database dialect, invoking super and registering SQL functions via consistent registerFunction calls. Each line is uniform, well-indented, and self-explanatory with clear parameter types. Javadoc adds clarity. Highly readable and comprehensible for developers knowing Hibernate or similar ORMs, with no complex logic or errors.","tokens":1524,"name":"18.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear indentation, descriptive variable names, final keywords, and detailed exception messages. Switch statement comprehensively handles XML events like CHARACTERS, CDATA, ENTITY_REFERENCE, ignoring COMMENT and PI appropriately. Efficient StringBuilder usage. Minor deduction for apparent logic issue: processes START_ELEMENT in loop without handling, leading to immediate throw, which reduces ease of comprehension.","tokens":1629,"name":"152.jsnp"}
{"score":"95","reasoning":"The code is a clear JUnit test method with consistent repetitive structure for testing SQL TRIM function variants. Each test case uses descriptive fragment strings, renders a template, and asserts expected output with Template.TEMPLATE placeholder. Easy to follow due to uniformity, good naming, and explicit expectations. Minor deduction for repetition without parameterization, but highly readable overall.","tokens":1226,"name":"26.jsnp"}
{"score":"88","reasoning":"Well-commented test method with clear descriptions of each revision and operations on embeddable list. Consistent transaction pattern aids comprehension despite repetition. Assumes external variables like c3_1 and c3_2 are defined elsewhere, slightly reducing standalone readability. Structure is logical and easy to follow.","tokens":1266,"name":"188.jsnp"}
{"score":"98","reasoning":"Well-documented Javadoc with clear param and exception details. Method signature is standard for Java serialization. Body is simple and sequential: defaultReadObject followed by consistent deserialization of named paint fields using SerialUtilities.readPaint. Descriptive variable names, no complex logic, highly readable and comprehensible despite repetition.","tokens":1113,"name":"3.jsnp"}
{"score":"78","reasoning":"The method is concise with clear sequential logic: set property value, conditionally update snapshot with deep copy, and return field name match. Parameter names are descriptive, and a comment provides context. However, reliance on external arrays like lazyPropertyNumbers, lazyPropertyNames, and lazyPropertyTypes makes it less self-contained, requiring class context for full comprehension. Minor grammar issue in comment.","tokens":1065,"name":"104.jsnp"}
{"score":"72","reasoning":"Clear JUnit test structure with try-catch-finally for exception handling on invalid SQL. Descriptive assert message and boolean flag aid comprehension. However, deep nested method chains like sessionImpl.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer() harm readability. Internal casting to SessionImplementor assumes Hibernate knowledge. Concise but verbose internals lower score.","tokens":1069,"name":"145.jsnp"}
{"score":"78","reasoning":"The test method has a simple, linear structure with clear sequential method calls using descriptive names like forceNewSession and loadDataOnSessionAndAuditReader, making intent easy to follow. A brief comment provides context. However, the excessively long method name significantly impacts readability at a glance. Suitable for developers familiar with the codebase.","tokens":947,"name":"187.jsnp"}
{"score":"95","reasoning":"The method is highly readable with comprehensive Javadoc explaining purpose, parameters, and return value. Code is concise, uses descriptive names like MetadataContext and locateOrBuildEntityType, and follows a clear linear flow: initialize context, process classes in loop, handle extras, wrap up, and return. Assumes Hibernate knowledge but internals are straightforward and well-organized.","tokens":1147,"name":"126.jsnp"}
{"score":"82","reasoning":"The code is concise with clear intent: handles project change events logically. Uses standard Java PropertyChangeEvent pattern. Multi-line if condition improves readability. Commented code is inactive and minimal. Assumes familiarity with custom classes like ProjectManager and Designer, but flow is straightforward and easy to follow without confusion.","tokens":990,"name":"11.jsnp"}
{"score":"98","reasoning":"The code is highly readable and easy to comprehend. It features a clear Javadoc comment, simple constructor with super call followed by self-explanatory register method invocations. Method names are descriptive, no complex logic or unnecessary elements. Minor grammar issue in Javadoc (a vs an) but does not impact comprehension.","tokens":759,"name":"19.jsnp"}
{"score":"72","reasoning":"The code is a concise JUnit test method invoking parse on various HQL queries. Structure is simple and consistent, aiding readability. However, dense HQL strings require Hibernate knowledge for full comprehension, duplicated parse calls, uppercase inconsistency, and commented uncertain lines slightly hinder clarity and flow.","tokens":1277,"name":"85.jsnp"}
{"score":"87","reasoning":"Code is concise and well-formatted with clear purpose of registering Java notation providers. Descriptive Javadoc comment aids understanding. Consistent method chaining improves flow. Minor issues: commented-out line adds slight confusion, domain-specific classes assume framework knowledge, reducing broad accessibility.","tokens":1001,"name":"5.jsnp"}
{"score":"92","reasoning":"The method is concise, with a single clear purpose: validate state and instantiate EntityManagerImpl. Parameters are vertically aligned for easy scanning. TODO comment flags future work without confusing current logic. Uses likely instance fields like transactionType, which is idiomatic. Excellent readability and comprehension.","tokens":1099,"name":"55.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive method name and assert messages clearly indicating expectations. Consistent pattern across test cases makes intent obvious: verifying return types and parameter types for date arithmetic in HQL queries. Repetition is minor and aids clarity, assuming familiarity with framework types like DoubleType and CalendarDateType. Highly readable and comprehensible.","tokens":1235,"name":"88.jsnp"}
{"score":"88","reasoning":"Code is well-structured with clear comments labeling each revision, making intent obvious. Consistent pattern of transaction begin-persist-commit improves readability. Descriptive variable names and standard Hibernate usage aid comprehension. Minor deductions for long hardcoded class mapping strings and lack of error handling, assuming framework familiarity.","tokens":1105,"name":"189.jsnp"}
{"score":"82","reasoning":"Code is simple and clear in purpose: resets region usage by calling methods on two listeners for two class names. Repetitive pattern for local/remote and mod/access calls makes it slightly verbose and less elegant; loops or helper method would improve. Good variable extraction for names and final log. No complex logic, easy to follow for Java devs.","tokens":1009,"name":"190.jsnp"}
{"score":"68","reasoning":"Code structure is logical for a Hibernate test: save entity, SQL query with aliases, load via get. Comments clarify intent and issues. However, repetitive session opens/closes reduce readability. Variable names like id2, useForGet, getted are poor. Complex SQL and noted bugs hurt comprehension. Suitable for experts but needs cleanup.","tokens":1331,"name":"72.jsnp"}
{"score":"92","reasoning":"The code is well-structured with a clear purpose: creating a test instance via field injection for @Parameter annotated fields. Logical flow from validation to instantiation and setting fields. Descriptive variable names and comprehensive exception messages enhance comprehension. Minor deductions for long exception strings and raw List type, but highly readable for experienced developers.","tokens":1078,"name":"13.jsnp"}
{"score":"95","reasoning":"Clear JUnit test with descriptive method and variable names. Concise logic: creates supplier, gets assignments, extracts strings, asserts size and contents. Standard assertions enhance readability. Easy to comprehend purpose despite external dependencies like signature and getStringValuesFromAssignments.","tokens":918,"name":"159.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with descriptive name and logical flow: setup reader, assert annotation presence/absence, then verify AttributeOverrides details. Precise assertions on column properties are repetitive but clear and consistent. Easy to follow for Java/JPA experts, minor deduction for length and lack of helper methods.","tokens":1381,"name":"177.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with descriptive name and clear assertions testing entity binding properties for no polymorphism. Uses standard Java testing idioms like assertTrue, assertSame, and iterators effectively. Easy to comprehend for developers familiar with JPA or Hibernate inheritance. Deductions for repetitive iterator validations and lengthy Resources annotation list impacting quick readability.","tokens":1387,"name":"180.jsnp"}
{"score":"72","reasoning":"The code has a clear Javadoc comment explaining purpose and a straightforward loop structure. Logic for handling shortcuts is understandable, distinguishing default, custom, and voided cases. However, long unwrapped lines with chained method calls like Configuration.makeKey(oldAction.getKey()) hinder readability. Repeated oldAction.getKey() calls could be extracted to a variable. Minor redundancy and dense if-else reduce ease of comprehension for quick review.","tokens":1095,"name":"51.jsnp"}
{"score":"95","reasoning":"The code is concise, well-structured, and highly readable. It uses a clear array initializer with descriptive method names like getActionPackage and null separators for grouping. No complex logic, just initialization and return. Easy to comprehend as a UML actions provider. Minor deduction for long initializer line.","tokens":893,"name":"156.jsnp"}
{"score":"78","reasoning":"The code is a well-structured JUnit test for Hibernate Criteria with fetch joins. Clear method name, logical flow, and detailed assertions enhance comprehension. Comments explain known issues. However, verbose anonymous inner classes, long lines, and dependency on external variables like yogiExpected reduce modern readability.","tokens":1209,"name":"97.jsnp"}
{"score":"92","reasoning":"The code is a well-structured JUnit test for Hibernate, using clear variable names like tiger and mother, standard session management patterns, and a helpful comment. The HQL query is complex but purposeful for the test. Minor repetition in opening/closing sessions, but overall very readable and easy to comprehend for developers familiar with Java and ORM.","tokens":1231,"name":"82.jsnp"}
{"score":"82","reasoning":"The code is well-structured with a clear constructor flow using consistent method calls like addField and addSeparator. Logical grouping with separators enhances readability. However, minor deductions for misspelled stimili, short variable name a, and heavy reliance on framework-specific classes without inline explanations, assuming prior knowledge.","tokens":1044,"name":"158.jsnp"}
{"score":"88","reasoning":"The code is well-structured and readable, with clear logic for validating Parameter annotations: checks bounds, tracks usage with an array, and reports missing or duplicate indices. Descriptive variable names and detailed error messages aid comprehension. Minor density in loops and use of raw array instead of a Map slightly reduce perfect score, but overall easy to follow for experienced developers.","tokens":1186,"name":"14.jsnp"}
{"score":"82","reasoning":"Well-structured method with informative header comment referencing JPA spec. Sequential method calls are logical and use descriptive names like getMapKeyColumn and buildAttributeOverrides. Handles complex annotation merging cleanly. Minor density from many chained calls and reliance on external vars like elementsForProperty reduces ease for newcomers, but excellent for experts.","tokens":1466,"name":"149.jsnp"}
{"score":"82","reasoning":"Well-structured method with clear if-else chain for entity dirtiness checks. Professional use of Hibernate-specific APIs like SelfDirtinessTracker and instrumentation metadata. SuppressWarnings is appropriately targeted. Minor issues: long lines, chained method calls, and domain knowledge required reduce general readability. Strong for experienced developers.","tokens":1111,"name":"111.jsnp"}
{"score":"82","reasoning":"Code is well-structured with descriptive method name and assert messages explaining expectations. Clear setup using AnnotationConfiguration and SessionFactory. Chained method calls are readable for Hibernate experts. Minor issues: magic number 0 in getter index lacks explanation, throws generic Exception, and assumes domain knowledge. Proper factory close. Overall highly comprehensible with small improvements possible.","tokens":1006,"name":"178.jsnp"}
{"score":"95","reasoning":"Well-documented Javadoc, clear parameter checks, intuitive logic for stacking positive and negative values from base. Good variable names like positive and negative. Straightforward double loops over categories and series. Handles nulls properly. Minor deductions for generic loop vars like item and terse inline comment on negative addition.","tokens":1143,"name":"41.jsnp"}
{"score":"88","reasoning":"Well-documented with Javadoc and inline comments explaining locking strategy and optimizations. Uses standard Java concurrency patterns like AtomicLong CAS loops for min/max updates and try-finally for readLock. Concise and efficient, but the tight CAS loops require familiarity with atomic operations, slightly reducing accessibility for novices. Strong readability for senior engineers.","tokens":1050,"name":"62.jsnp"}
{"score":"35","reasoning":"Clear test intent via method name and assertion, but extremely long method chain with deep nesting, casting, iterator next call, and verbose class name string reduce readability and make it hard to follow without refactoring into variables.","tokens":1088,"name":"199.jsnp"}
{"score":"82","reasoning":"Method has a descriptive name and clear purpose. Uses final for local variable, good formatting with multi-line parameters for readability. Straightforward logic: extract persister and delegate to another method. However, dense framework-specific types like QueryableCollection and casts assume deep domain knowledge, slightly hindering broad comprehension.","tokens":1126,"name":"148.jsnp"}
{"score":"98","reasoning":"The code is a clear JUnit test method with descriptive name, meaningful variable names like limit, offset, input, expected, and actual. It concisely sets up SQL strings, calls the dialect method, and asserts equality. Easy to follow the test intent: verifying limit/offset insertion with for update and with clauses. Minor deduction for long concatenated expected string, but overall highly readable and comprehensible.","tokens":958,"name":"24.jsnp"}
{"score":"98","reasoning":"The code is exceptionally readable with a clear Javadoc comment explaining the override for line-end detection. Simple, linear if-statements handle newline characters concisely, setting boolean flags and returning appropriately. Consistent indentation and minimal logic enhance comprehension, assuming context for hasLf and hasCr variables.","tokens":855,"name":"6.jsnp"}
{"score":"85","reasoning":"The code is a concise JUnit test with a descriptive though long method name clearly stating intent. It uses standard patterns like expectMessage and try-catch to ignore first exception before triggering timeout. Readable for Java developers familiar with testing libraries, but assumes external context like thrown, TIMEOUT, and evaluate methods which slightly reduces standalone comprehension.","tokens":955,"name":"160.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear comments explaining test purpose and cases. Verifier class implements efficient DFS traversal using Stack to detect NOT-EXISTS subtree pattern. Test structure is logical with two distinct cases for AND and OR inversion. Minor nit: Stack variable named queue but functions as stack correctly. Easy comprehension for Java and AST-savvy readers.","tokens":1144,"name":"87.jsnp"}
{"score":"98","reasoning":"Excellent readability with comprehensive Javadoc explaining purpose and references. Clear parameter names, standard listener list traversal from end to avoid issues, lazy event creation for efficiency, proper type checking and casting. Concise, follows Java idioms perfectly, easy for experienced developers to understand instantly.","tokens":1087,"name":"9.jsnp"}
{"score":"35","reasoning":"Generated ANTLR parser code with low readability due to opaque identifiers like _loop119 and _tokenSet_6, magic LA(1) lookahead, and unconventional do-while loop with labeled break. Extra braces add clutter. Comprehensible to experts with context but hard for general understanding.","tokens":941,"name":"115.jsnp"}
{"score":"45","reasoning":"Code is straightforward in intent: handles removal from ownedElements by removing nodes or edges based on type. However, severe repetition in multiple if statements checking similar isA methods, all calling removeNode or removeEdge. Lacks abstraction like polymorphism or switch. Uses outdated Vector casting. Repeated Model.getFacade calls. Easy to follow logic but verbose and maintainability poor.","tokens":1225,"name":"119.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test with clear setup, persistence, retrieval, and assertions. Meaningful variable names like kit and kitkat enhance readability. Annotations provide context for dialect skips. Minor issues: verbose multi-line annotations, unnecessary debug print, manual ID setting, and trim calls reduce polish slightly. Easy to follow for Hibernate users.","tokens":1227,"name":"138.jsnp"}
{"score":"72","reasoning":"Code uses a clear for loop to iterate over subclass property closures and initialize paths via propertyMapping. Descriptive method names aid understanding, but repeated lengthy getter calls like getSubclassPropertyNameClosure()[i] and very long argument list make it harder to scan quickly, slightly impacting readability.","tokens":989,"name":"105.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear Javadoc documentation, straightforward try-catch structure, and descriptive variable names. Logic is simple and easy to follow. Uses final modifiers appropriately. Minor deductions for raw Object types lacking generics and slightly verbose if-else, but overall excellent comprehension for a cache get method.","tokens":954,"name":"164.jsnp"}
{"score":"98","reasoning":"The code is a straightforward Java constructor with a clear Javadoc comment. It calls super() and registers JDBC column types to FrontBase SQL types in a consistent, single-line format per type. Excellent indentation, no redundancy, and easy to scan and comprehend the mappings.","tokens":948,"name":"25.jsnp"}
{"score":"95","reasoning":"The code is concise, straightforward, and self-explanatory. It initializes a HashSet with predefined constants using clear add statements and returns an unmodifiable set for safety. Standard Java idioms are used correctly. The repetitive adds are minor and do not hinder comprehension. High readability for any Java developer.","tokens":1010,"name":"16.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear Javadoc comment explaining purpose. Logical flow: extract ResultSet, wrap if needed, handle limits, discover types, return. Uses try-catch for error handling. Meaningful names and final modifiers aid readability. Dense parameter list and Hibernate-specific APIs like JdbcCoordinator and LimitHandler assume domain knowledge, slightly hindering broad comprehension.","tokens":1071,"name":"33.jsnp"}
{"score":"72","reasoning":"Well-documented purpose with Javadoc. Structured if-else and loop logic is clear. Efficient StringBuilder use. However, dense inner loop with nested ternaries, repeated casts, magic numbers like size*100, and domain-specific calls reduce ease of comprehension for non-Hibernate experts. Variable names are decent but some abbreviations. Overall professional but intricate.","tokens":1351,"name":"34.jsnp"}
{"score":"85","reasoning":"Well-structured test method with clear purpose: verifies lock acquisition fails after registration and invalidation. Descriptive names like testee, KEY1. Proper try-finally for lock handling. Minor issues: anonymous inner class adds verbosity, framework dependencies like CacheManagerCallable reduce standalone readability, magic constant NAKED_PUT_INVALIDATION_PERIOD.","tokens":1085,"name":"173.jsnp"}
{"score":"82","reasoning":"The code is a well-structured JUnit test method with a descriptive name and clear assertions using standard JUnit methods. Variable names are mostly descriptive, and the logic flows logically from setup to verification. However, heavy reliance on Hibernate-specific classes like EntityPersister and CascadeStyleLoadPlanBuildingAssociationVisitationStrategy, along with casting and magic numbers, requires domain knowledge, slightly hindering general comprehension.","tokens":1123,"name":"142.jsnp"}
{"score":"68","reasoning":"Code is clear in intent, safely using instanceof before casting to specific event types. Structure follows logical if-else flow for event dispatching. However, repetitive if blocks for range checks and listener types make it verbose and harder to maintain. ANY_EVENT branch omits generator handling unlike specific branches, adding inconsistency. Refactoring to polymorphism or switch on enums would enhance readability.","tokens":1237,"name":"43.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with descriptive name capturing the test intent. Clear logical progression: baseline query, then enabling filters step-by-step with explanatory comments. Uses standard Hibernate patterns effectively. Assertions are precise. Easy to follow for developers familiar with Java and Hibernate. Slight deduction for reliance on external TestData without inline details and long method name.","tokens":1147,"name":"91.jsnp"}
{"score":"88","reasoning":"The method has a clear purpose of creating a timeout exception with optional stuck thread info. Logic flows logically: capture stack trace, check for stuck thread, build exceptions. Uses standard Java idioms like String.format and Arrays.asList. Variable names are mostly descriptive. Minor deductions for dense if-else block, magic strings, and reliance on undefined fields/methods which is typical in snippets.","tokens":1119,"name":"125.jsnp"}
{"score":"90","reasoning":"Well-structured Java method with clear logical flow: notifications, conditional flush with explanatory comment, context-specific calls, and cleanup. Variable names like flush, isDriver, isInitiator are descriptive. Complex flush condition is readable despite nesting. Uses final keyword appropriately. Highly comprehensible for developers familiar with transaction APIs.","tokens":1054,"name":"184.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear Javadoc, generic typing, and try-finally for cleanup. Inline comments explain todo and rationale. Nested blocks add slight complexity, and external dependencies assume context knowledge, but overall readable and professional for experienced developers.","tokens":1154,"name":"110.jsnp"}
{"score":"82","reasoning":"Code is well-structured with logical test flow, descriptive variable names like redValue and ps, and clear Hibernate usage. Humorous string values add clarity. Minor deductions for SuppressWarnings hiding potential issues, TODO comment indicating limitation, and assumption of ORM framework knowledge reducing general accessibility.","tokens":1138,"name":"80.jsnp"}
{"score":"72","reasoning":"Code is correct for big-endian byte extraction from long using bit shifts, with clear Javadoc. However, repetitive unrolled shifts are verbose and less intuitive than a loop like for(int i\u003d0; i\u003c8; i++) bytes[i] \u003d (byte)(longValue \u003e\u003e (56 - i*8)), violating DRY and hindering quick comprehension.","tokens":1227,"name":"113.jsnp"}
{"score":"92","reasoning":"The code is concise, logically structured, and follows standard JAXB unmarshalling with schema validation. Variable names are clear and descriptive, with a straightforward sequence of operations. Good use of generics and exception handling. Minor deductions for abbreviations like jc and lack of inline comments, but highly readable for experienced developers.","tokens":988,"name":"194.jsnp"}
{"score":"72","reasoning":"The code handles double-click events on two tables clearly with early returns for invalid selections and simple if-else structure. Variable names are mostly intuitive. However, it uses outdated Java practices like raw Object types, Vector elementAt method, unchecked casting, and relies heavily on undeclared global variables, which reduces clarity without context. Lacks comments and could benefit from generics and error handling for better comprehension.","tokens":1044,"name":"10.jsnp"}
{"score":"35","reasoning":"The code employs deeply nested anonymous inner classes, making it dense and hard to parse at a glance. It assumes deep knowledge of Infinispan, Hibernate, and JTA frameworks. Overrides are logical but the inline complexity and lack of explanatory comments reduce readability and ease of comprehension significantly.","tokens":1079,"name":"132.jsnp"}
{"score":"72","reasoning":"Code is concise with clear intent to safely release a PreparedStatement, using null check and try-catch ignore pattern. Structure is simple and standard. However, the long chained method call with casting to SessionImplementor obscures readability and requires Hibernate-specific knowledge to fully comprehend.","tokens":898,"name":"95.jsnp"}
{"score":"88","reasoning":"Code is clear and concise with logical flow: checks overwrite, handles user confirmation, manages file output safely with try-finally. Descriptive names like theFile and fo aid comprehension. Minor issues: awkward line break in JOptionPane call and tab inconsistencies slightly hinder perfect readability.","tokens":1073,"name":"49.jsnp"}
{"score":"98","reasoning":"Excellent readability with clear Javadoc documentation, proper Override annotation, standard equals method pattern including null and type checks, straightforward field comparisons with early returns, and concise logic that is easy to follow for any Java developer.","tokens":918,"name":"114.jsnp"}
{"score":"35","reasoning":"Code has poor readability due to inconsistent indentation spacing and formatting. Extremely long chained return statement is hard to follow. Mix of \u003d\u003d and equals methods inconsistently applied risking bugs like NPE or incorrect equality for objects. Commented lines distract. No null checks for most fields. Lacks structure like helper methods. Method name non-standard. Overall low comprehension ease.","tokens":1520,"name":"74.jsnp"}
{"score":"98","reasoning":"This is a standard, well-formatted equals method override in Java following best practices: reference equality, superclass check, class check, and null-safe field comparison. Code is clean, indented properly, and easy to read for any Java developer with no ambiguities or unnecessary complexity.","tokens":944,"name":"169.jsnp"}
{"score":"92","reasoning":"The code is a clear JUnit test method testing HiLo optimizer with two scenarios separated by descriptive comments. Logical flow with loops, assertions, and state checks. Descriptive variable names like increment, next, sequence. Minor repetition between tests but easy to follow. Assumes domain knowledge but highly readable for Java developers.","tokens":1260,"name":"56.jsnp"}
{"score":"85","reasoning":"Well-structured Java Swing constructor with clear variable names, logical flow for table setup, font, columns, and layout. Minor redundancies like duplicate autoResizeMode calls and hardcoded widths slightly reduce perfection, but easy to comprehend for experienced developers.","tokens":1035,"name":"118.jsnp"}
{"score":"45","reasoning":"Highly repetitive code with 11 similar doTest calls varying only boolean arrays passed to CacheableResultTransformer.create. Duplication hinders readability and quick comprehension of test cases. Some arrays repeated. Could use a loop for better conciseness. Intent clear but verbose implementation lowers score.","tokens":1155,"name":"59.jsnp"}
{"score":"88","reasoning":"Excellent Javadoc comment provides clear purpose, caveats, and example reference. Code logic is straightforward: fetches ToDoItems for owner and self, paints their clarifier icons horizontally. Variable names are descriptive. Deductions for code duplication in two nearly identical loops and use of outdated Vector with indexing instead of modern iterators or for-each. Easy to comprehend despite minor refactoring opportunities.","tokens":1267,"name":"121.jsnp"}
{"score":"88","reasoning":"Code is well-structured with clear setup test teardown flow. Descriptive comments explain Hibernate issue and expectations effectively. Variable names are mostly clear though some abbreviations like e1 e2. Logical progression of tests. Assumes domain knowledge of Hibernate sessions and queries but readable for experienced Java devs. Minor indentation consistency in snippet.","tokens":1220,"name":"78.jsnp"}
{"score":"85","reasoning":"Well-structured method with early null return, clear conditional sets for type info, and instanceof check before cast. Descriptive name and section comment aid readability. TODO highlights limitation clearly. Minor deductions for magic array index [0] and generic value parameter name, but overall easy to follow for Java developers familiar with Hibernate.","tokens":1053,"name":"147.jsnp"}
{"score":"82","reasoning":"Well-structured method using reflection to create Test instances with comprehensive try-catch blocks for various exceptions. Clear variable names and logical flow distinguish parameterless vs named constructors. Handles TestCase subclassing appropriately. Drawbacks include external undefined methods like warning and exceptionToString, and a whimsical non-technical comment. Readable for experienced Java developers familiar with JUnit and reflection.","tokens":1160,"name":"2.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive name indicating purpose. Comments effectively contextualize the pathological keyword usage in queries. Test cases are sequentially listed on separate lines for easy scanning. Intent is straightforward despite intentionally confusing query strings testing parser robustness.","tokens":1045,"name":"86.jsnp"}
{"score":"68","reasoning":"Clear test purpose for SQLGrammarException on non-existent table. Good structure with transaction handling, try-catch-finally, and rollback. However, verbose anonymous inner class and deeply nested getter chains like ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator() harm readability and comprehension. Modern Java could use lambdas for brevity.","tokens":1098,"name":"94.jsnp"}
{"score":"88","reasoning":"Code is cleanly formatted with good indentation and spacing. Logic is straightforward: initializes result, adds hashCodes with null checks, multiplies by prime. Easy to follow intent. Minor deduction for non-standard hash combination order which might confuse experts expecting canonical PRIME multiplication before each addition.","tokens":1457,"name":"141.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear purpose: scans superclasses for annotated methods and fields, populating maps. Descriptive parameter names, logical nested loops, and helper methods like getSuperClasses and addToAnnotationLists enhance readability. Comment clarifies field sorting intent. Generics introduce minor complexity but code flows intuitively for experienced developers.","tokens":997,"name":"52.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive variable names and comments explaining purpose. Logic is straightforward: execute timeout-prone code, inspect stack trace for specific methods, and assert presence/absence. Minor deductions for verbose booleans and long names reducing conciseness, but highly comprehensible for Java developers familiar with testing frameworks.","tokens":1083,"name":"161.jsnp"}
{"score":"88","reasoning":"Code is concise with clear intent, good use of enums and inline comments for clarity. Logic flow is straightforward but first if-condition chain is lengthy. Nested if and multi-line exception message slightly hinder quick comprehension. Professional style overall.","tokens":1018,"name":"29.jsnp"}
{"score":"95","reasoning":"The code is a concise JUnit test method with a clear doc comment explaining its purpose. It uses an anonymous inner class to override addListener, calling addFirstListener, and invokes test(). Descriptive name, standard annotations, and straightforward structure make it highly readable for Java developers familiar with testing. Minor deduction for reliance on external classes like AbstractConcurrentFailuresTest and fNotifier.","tokens":968,"name":"53.jsnp"}
{"score":"92","reasoning":"The code is a well-structured JUnit test method with detailed comments explaining the bug context and property definitions. It follows a consistent repetitive pattern using SyntaxChecker for HQL queries, which is straightforward and easy to comprehend. Minor repetition could be optimized but does not hinder readability for Hibernate developers.","tokens":1354,"name":"79.jsnp"}
{"score":"92","reasoning":"Standard Java equals method with reference check, instanceof, and null-safe field comparisons using ternary operators. Concise, follows idioms, highly readable for experienced developers. Minor density in ternaries slightly impacts novice comprehension.","tokens":854,"name":"70.jsnp"}
{"score":"88","reasoning":"Well-structured override method with clear intent: appends select fragments for collections and many-to-many elements. Descriptive chained method calls follow Java conventions. Relies on framework-specific knowledge like Hibernate ORM, which aids experts but may challenge others. No redundancy, clean logic, minor density in long lines.","tokens":979,"name":"182.jsnp"}
{"score":"78","reasoning":"Code is a clear JUnit test for Hibernate naming strategy with proper try-catch-finally structure and explanatory assert messages referencing JPA spec. Readability is good for domain experts but hindered by short variable names like sf and foundIt, manual Iterator loop instead of for-each, magic strings for table names, and redundant assert inside loop for every table. Overall comprehensible with minor improvements needed for better flow.","tokens":1183,"name":"137.jsnp"}
{"score":"88","reasoning":"The code is well-structured and follows a logical flow for preparing Hibernate test data with Parent-Child relationships. Variable names clearly indicate hierarchy (e.g., child_1_1), though prefix letters (a,y,d) are arbitrary. Saves are interleaved between groups, likely intentional for testing order. Proper session/transaction handling, flush, and cleanup. Indentation is consistent. Highly readable for experienced Java developers, minor deduction for naming and lack of comments.","tokens":1211,"name":"76.jsnp"}
{"score":"95","reasoning":"The code is highly readable with a clear repetitive pattern for registering transaction factories using strategySelector. Consistent structure across Jdbc Jta and CMT factories with SHORT_NAME and full class names. Purpose is immediately clear: adding strategy implementors. No complex logic or obfuscation. Explicit registrations enhance comprehension despite minor repetition.","tokens":1014,"name":"171.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test for Hibernate refresh functionality with logical flow: session setup, save, direct SQL update, refresh, assertions on value and lock modes, cleanup. Dialect-aware quoting and conditional checks enhance portability. Anonymous inner class is clear but slightly verbose compared to lambdas. Hardcoded SQL and generic Foo entity name are minor readability drags, but overall easy to comprehend for Java/Hibernate users.","tokens":1182,"name":"69.jsnp"}
{"score":"88","reasoning":"The constructor initializes three lists consistently using ternary operators to copy from readerCollector getters or use empty lists if null. Pattern is clear and defensive against nulls. Long lines and generic verbosity slightly hinder readability but overall comprehension is high due to repetition and descriptiveness.","tokens":922,"name":"196.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test using JPA Criteria API with clear variable names like orderRoot and customerSubquery. Logical progression from query creation to subquery correlation and exists clause. Single comment aids understanding of correlated subquery. Concise and readable for Java/JPA experts, minor density for novices.","tokens":954,"name":"163.jsnp"}
{"score":"98","reasoning":"Well-structured Java constructor with clear Javadoc, single parameter, and delegation to overloaded constructor using named constants. Inline comments clarify boolean flags. Professional, concise, and highly readable for experienced developers.","tokens":892,"name":"4.jsnp"}
{"score":"92","reasoning":"Concise JUnit test method with clear name testModFlagProperties. Single assertEquals call with well-indented nested method invocations enhances readability. Relies on context-specific utilities like TestTools and getCfg but structure is straightforward and easy to comprehend for familiar developers.","tokens":1072,"name":"165.jsnp"}
{"score":"92","reasoning":"The code is concise, well-indented, and follows standard JUnit patterns. Descriptive method name clearly indicates purpose: verifying listener behavior during test failures. Logic flows logically from setup to execution and assertion. Anonymous inner class is clear though slightly verbose. Minor issues: fMax and TwoTests are external references, assuming context knowledge.","tokens":1085,"name":"124.jsnp"}
{"score":"42","reasoning":"Code suffers from deep if-else nesting which obscures logic flow. Heavy reliance on framework-specific Model.getFacade() calls assumes prior knowledge. Unclear separation between model updates and layer manipulation. TODO comment highlights unresolved issues. Uses outdated iterator instead of modern loops. Variable names like nod and comp are vague.","tokens":1246,"name":"155.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with clear method name and purpose. Properties setup is logical, assertions precise and verify specific configs. Try-finally ensures cleanup. Good use of comments. Minor issues: type casts to impl classes and framework-specific knowledge assumed, but code flows intuitively for experienced developers.","tokens":1228,"name":"130.jsnp"}
{"score":"78","reasoning":"The test method has a clear structure for Hibernate session management, entity CRUD, and dialect-specific SQL query handling. Readability is good with standard JUnit patterns and logical flow, but hindered by long unwrapped SQL strings, magic strings like from A and TA, older Hibernate API usage, and minimal comments. Dialect if-condition adds complexity but is necessary. Overall comprehensible for experienced developers.","tokens":1247,"name":"71.jsnp"}
{"score":"88","reasoning":"Code is concise and clear, overriding runTest to spawn a thread for test execution with proper finally block for cleanup. Anonymous inner class is straightforward, comments justify inlining. Flow is easy to trace: thread start, test run, runFinished call. Slight deduction for pre-lambda style and nested structure, but highly comprehensible for Java developers.","tokens":965,"name":"1.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with logical flow: setup, save/flush, query with open resources, expected serialization failure, cleanup, and success. Descriptive name and comments clarify intent, edge cases like Sybase dialect, and Hibernate behaviors. Clear assertions via try-catch and fail. Minor complexity from framework specifics but highly readable overall.","tokens":1238,"name":"75.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test method with descriptive name and JPA spec comment for context. Logical flow: setup entities, persist, retrieve, assert. Meaningful variable names like Employee, JobInfo. Minor issues: repeated openSession calls could be extracted; long chained assertion with iterator.next() is hard to read and brittle. Assumes entity class knowledge. Readable for Hibernate experts.","tokens":1325,"name":"134.jsnp"}
{"score":"35","reasoning":"Code uses cryptic single-letter variable names like b c d e f g making it hard to follow without prior context. Repetitive nulling and collection removals lack abstraction or comments. Merge and delete sequence assumes specific entity graph knowledge. Syntactically clean but overall comprehension is low due to poor naming and no documentation.","tokens":1094,"name":"200.jsnp"}
{"score":"78","reasoning":"This JUnit test method for Hibernate HQL select expressions is straightforward, with proper setup teardown and varied queries covering functions like lower concat sum abs. Readability is good for experts due to clear structure and annotations. However repetition of similar result assignments without assertions makes it less intuitive and harder to comprehend purpose fully. Minor indentation issues in snippet. Suitable for domain experts.","tokens":1545,"name":"83.jsnp"}
{"score":"90","reasoning":"Constructor initializes multiple collection event listeners clearly with descriptive names and passes this reference. Registry setup is logically grouped by event type pairs, making intent obvious. Repetitive pattern aids comprehension despite length. Minor deduction for unchecked cast and framework assumptions, but overall highly readable for Java developers familiar with Hibernate.","tokens":1060,"name":"139.jsnp"}
{"score":"82","reasoning":"Code is concise and logically structured, clearly collecting dependencies for a class using a HashSet. Intent is easy to grasp. Repetitive addAll calls are straightforward but could benefit from a loop or constants for better maintainability. Domain-specific Model facade assumes framework knowledge, mildly impacting general readability. No major issues with syntax or flow.","tokens":994,"name":"123.jsnp"}
{"score":"88","reasoning":"Well-structured method with clear purpose. Switch statement uses descriptive comments for PostgreSQL error codes, making cases easy to understand. Consistent template extraction and proper exception handling enhance readability. Deductions for magic numbers instead of constants and undefined extractUsingTemplate method. Concise and comprehensible overall.","tokens":1047,"name":"22.jsnp"}
{"score":"85","reasoning":"Code is well-indented with clear structure and informative comments citing JPA spec. Null checks and continue statements enhance readability. However, map names fieldAccessMap and propertyAccessMap seem counterintuitive with put operations like putting FIELD access into propertyAccessMap, potentially confusing readers. Duplicated loop logic reduces maintainability. Suitable for experienced developers.","tokens":1851,"name":"27.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test for JPA query cache modes with clear setup and repetitive assertion pattern for different configurations. Logical progression from store to mixed retrieve/store modes. Initial cast to Hibernate internals is complex but done once and reused. Assumes domain knowledge but highly readable for Java/Hibernate experts with consistent naming and minimal boilerplate.","tokens":1445,"name":"162.jsnp"}
{"score":"95","reasoning":"The code features excellent Javadoc documentation explaining purpose parameters return and exceptions. Logic is simple with clear if-else chain handling POJO MAP and unknown modes throwing appropriate exception. Descriptive names and static method enhance readability. Minor TODO note does not hinder comprehension making it very easy to follow.","tokens":1074,"name":"32.jsnp"}
{"score":"82","reasoning":"Code is short, concise, and follows Java conventions with clear method purpose. Parameters are logically passed to strategy constructor and builder. However, excessively long class names like FetchStyleLoadPlanBuildingAssociationVisitationStrategy hinder quick readability and comprehension for those unfamiliar with the library.","tokens":988,"name":"143.jsnp"}
{"score":"92","reasoning":"Well-documented Javadoc explains purpose, params, and generics clearly. Logical flow: checks synthetic props, logs actions, builds context, resolves metadata, handles plural/singular cases. Descriptive names like ownerType, attributeMetadata. SuppressWarnings justified. Minor complexity from generics casting and long constructor call reduces perfect score slightly.","tokens":1182,"name":"84.jsnp"}
{"score":"92","reasoning":"The code is highly readable with a clear Javadoc comment outlining the three main steps. Logic flow is straightforward: clear caches, process each collection entry by calling postFlush, then either remove or recreate key mappings. Uses descriptive variable names, proper indentation, and final for context. Minor complexity from concurrentEntries for safe iteration during modification, but overall easy to comprehend for Java developers familiar with frameworks.","tokens":1344,"name":"66.jsnp"}
{"score":"78","reasoning":"Code has clear Javadoc explaining purpose caching and complexity. Logic is straightforward: direct hashtable check then linear search over keys matching interfaces with caching. Good variable names and structure. Deductions for outdated Enumeration API no generics raw casts inconsistent spacing and minor Javadoc typos like noone exist reducing modern readability.","tokens":1285,"name":"44.jsnp"}
{"score":"98","reasoning":"Excellent readability with clear Javadoc, logical flow starting with reference equality and type check, then key comparisons, followed by nested loops for value equality with proper null handling and early returns. Concise, standard Java equals method easy to comprehend.","tokens":990,"name":"40.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method with clear setup, execution, and teardown phases. Descriptive variable names like human and session. Standard Hibernate session management and query usage. Logic is straightforward: save entity, query empty IN list expecting zero results, then delete. Easy to comprehend for Java/Hibernate developers. Minor deduction for hardcoded query string and data values.","tokens":1041,"name":"77.jsnp"}
{"score":"98","reasoning":"The code features a clear Javadoc comment detailing purpose param and throws clause. Method is concise invoking defaultWriteObject then a consistent series of SerialUtilities calls for serializing shapes paints and strokes. Logical flow clear naming and no redundancy ensure high readability and ease of comprehension.","tokens":946,"name":"38.jsnp"}
{"score":"72","reasoning":"Code has clear structure with if-else blocks and descriptive names like applyNamingStrategy and propertyName. Intent is understandable: handle column naming with or without strategy. However, nested conditions reduce flow readability, redundant normalization calls (twice in one branch), and chained assignments make it slightly harder to trace. Suitable for experienced devs but improvable by extracting methods.","tokens":1103,"name":"30.jsnp"}
{"score":"88","reasoning":"Well-structured Java test method with clear try-catch-finally usage for handling expected TransientObjectException in Hibernate context. Variable names are descriptive, intent is evident from comments and fail assertion. Minor deduction for nested blocks and domain-specific assumptions like Session and persist, but overall highly readable and comprehensible for developers familiar with JPA testing.","tokens":980,"name":"129.jsnp"}
{"score":"92","reasoning":"The code is straightforward Java debug method printing SQL strings and suffixes for comparison. Clear labels, simple logic using System.out and StringHelper.join. Easy to comprehend for any Java developer. Minor deductions for verbose multiple println calls and hard-coded separator strings which could be constants or use a logger for better style.","tokens":942,"name":"144.jsnp"}
{"score":"87","reasoning":"Well-structured JUnit test method with logical sequence of setup, actions, and assertions clearly verifying JTA transaction states during explicit joining. Descriptive variable names and consistent checks aid comprehension. Minor deductions for verbose type casts and reliance on Hibernate internals which assume prior knowledge.","tokens":1281,"name":"127.jsnp"}
{"score":"82","reasoning":"Code is concise with clear test intent: verify transaction states before and after begin, then open session with autoJoinTransactions disabled. Logical flow is easy to follow. Minor issues: repeated long TransactionManager calls could be extracted to a variable for better readability; casting to SessionImplementor and sessionFactory call assume framework knowledge, slightly reducing general comprehension.","tokens":991,"name":"128.jsnp"}
{"score":"92","reasoning":"The code features clear lazy initialization of a static Vector with KnowledgeTypeNode objects using constants from Critic. Javadoc is concise and descriptive. Structure is simple and easy to follow. Deductions for outdated Vector usage instead of List, repetitive addElement calls, and lack of generics. Overall highly readable for experienced Java developers.","tokens":1049,"name":"45.jsnp"}
{"score":"65","reasoning":"Code intent to read file and parse sections into map is clear. Structure is straightforward with try-catch. However, poor variable names like f fr mAry reduce readability. While loop uses anti-pattern with null check inside. Bug: last sections content not stored after loop. No try-with-resources for auto-close. Nested ifs slightly complicate flow.","tokens":1140,"name":"48.jsnp"}
{"score":"68","reasoning":"Code structure is clear with proper override, final locals, and SwingUtilities for thread safety. Logic for redirecting transitions in concurrent regions is understandable via comment. However, incorrect string comparison with \u003d\u003d instead of equals, noted in TODO, reduces reliability. Assumes trCollection is Collection without null/type checks. Repeated Model facade calls could be extracted. Moderately readable but flaws hinder full comprehension.","tokens":1129,"name":"154.jsnp"}
{"score":"72","reasoning":"Well-structured JUnit test with clear method name and logical flow: setup, insert/update, flush/commit, reload, assert cache hit. Good use of comments explaining actions. Drawbacks: poor variable name it, typo excpect in assert message, minor formatting inconsistencies. Comprehensible for Hibernate experts, less so for beginners.","tokens":1174,"name":"179.jsnp"}
{"score":"72","reasoning":"Standard ANTLR lexer method for matching a single hex digit using switch on lookahead char with explicit ranges for 0-9, A-F, a-f. Clear logic flow: match, then create token if needed. Underscore-prefixed variables and ANTLR-specific calls like LA(1), matchRange are idiomatic but may confuse non-ANTLR users. Dense case lists reduce readability slightly. Overall comprehensible with Java knowledge.","tokens":1321,"name":"117.jsnp"}
{"score":"55","reasoning":"Code is linear and functional but suffers from outdated Vector usage with addElement, non-generic collections, and cryptic variable names like cr and aer. Framework-specific calls like Model.getFacade assume prior knowledge. Comment notes wastefulness but offers no improvement. Readable for experts, challenging for others due to legacy style and lack of clarity.","tokens":999,"name":"120.jsnp"}
{"score":"78","reasoning":"Code has clear structure and logical flow for mouse event handling, tooltip updates, and manager delegation. Positive aspects include descriptive method name and straightforward purpose. Deductions for repeated getJComponent calls, reliance on Globals for state, distracting commented-out lines, and slightly nested conditional logic which could be simplified for better comprehension.","tokens":1079,"name":"122.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with clear visual separation using long tilde comment lines for each test phase. Comments explain historical context and expectations effectively. Sequential ID generation tests are repetitive but intentionally explicit for verification, enhancing traceability. Minor noise from type casts like SessionImpl and Long. Highly readable and easy to comprehend for developers familiar with Hibernate sequences.","tokens":1339,"name":"17.jsnp"}
{"score":"72","reasoning":"Code parses args for JUnit options like --filter using a loop with manual index management. Functional logic handles double-dash stop, filter specs with equals or next arg, and errors. However, unusual for loop condition i !\u003d length with ++i, nested ifs, and inner ++i reduce readability. Assumes external vars like filter and parserErrors. No comments or input validation on substring. Comprehensible for experts but not beginner-friendly.","tokens":1480,"name":"15.jsnp"}
{"score":"88","reasoning":"The method has a clear purpose: overriding schema and catalog with defaults if missing. Descriptive variable names like schemaDefined and logical if-conditions enhance readability. Slightly verbose with new ArrayList and addAll, but flow is straightforward and easy to comprehend without deep domain knowledge.","tokens":1078,"name":"195.jsnp"}
{"score":"72","reasoning":"Code is straightforward: evaluates expression to list, processes model elements or expressions by extracting names/bodies with fallbacks, joins with separator. Clear flow with iterator loop. Deductions for raw types (no generics), magic strings, reliance on external Model facade without context, undeclared fields (_scratchBindings, _strBuf), and lack of comments. Readable for experienced Java devs but assumes domain knowledge.","tokens":1078,"name":"8.jsnp"}
{"score":"72","reasoning":"Code follows Java conventions with proper indentation and logical structure. Variable names are mostly descriptive. Flow is clear: conditional setup of index column, binder creation, and backref handling. However, dense framework-specific calls (e.g., PropertyHolderBuilder, Ejb3Column) and magic strings reduce accessibility without Hibernate knowledge. Exception handling is straightforward but abrupt.","tokens":1263,"name":"109.jsnp"}
{"score":"82","reasoning":"Clear if-else chain handles specific collection properties with consistent checks, exceptions, and SQL fragment returns. Uses constants for property names. Repetitive patterns in column name retrieval and length checks make it slightly verbose and harder to scan quickly. Commented line adds minor confusion. Overall comprehensible for Java ORM context.","tokens":1322,"name":"108.jsnp"}
{"score":"92","reasoning":"Well-structured method using clear if-else chain for instanceof checks on test types. Logical flow from TestCase to fallback. Good use of descriptive variables like tc and ts. Recursive handling for suites and decorators is intuitive. Single comment aids understanding. Minor deduction for instanceof pattern over polymorphism, but excellent readability for Java developers familiar with JUnit.","tokens":1021,"name":"54.jsnp"}
{"score":"75","reasoning":"The code is a clear JUnit test method with repetitive assertEquals calls checking revision lists for specific entities using getAuditReader. Structure is consistent and purpose is evident. However, extremely long class names like ChildIndexedListJoinColumnBidirectionalRefIngEntity hinder readability and make lines hard to scan. Assumes ids like ing1_id are defined elsewhere. Solid for tests but could benefit from shorter names or aliases.","tokens":1187,"name":"185.jsnp"}
{"score":"72","reasoning":"Code is concise and follows standard Java practices with proper try-catch for error handling. Purpose is clear: retrieve SQL type code and validate consistency. However, heavy reliance on undefined class fields and methods like getValue, getTypeIndex, name reduces standalone comprehensibility. Minor typo in error message SQLType codes does not match. Suitable for Hibernate experts but less accessible generally.","tokens":1097,"name":"37.jsnp"}
{"score":"82","reasoning":"Well-structured method with clear logic: resolves bidirectional references first, then iterates over fetches handling EntityFetch and CompositeFetch cases. Descriptive parameter and variable names, appropriate use of final, single helpful comment. Minor deductions for domain-specific types requiring ORM knowledge, instanceof/casting patterns, and implied method overloads which may confuse without full context. Concise and maintainable for senior Java engineers.","tokens":1337,"name":"197.jsnp"}
{"score":"92","reasoning":"The toString method employs a fluent StringBuilder chain with each append on a separate line, enhancing readability and clearly showing the fields included. It follows a standard format like ClassName[field\u003dvalue,...], which is intuitive. Efficient avoidance of string concatenation. Slight deduction for mixing direct field access with a method call like getExecutionAvgTime, but overall highly comprehensible.","tokens":1140,"name":"63.jsnp"}
