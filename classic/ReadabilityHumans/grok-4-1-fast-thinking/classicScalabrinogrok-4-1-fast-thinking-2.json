{"score":"95","reasoning":"The code is concise, well-structured, and uses descriptive constants from Hibernate Environment class. Each property setting is on a separate line, enhancing readability. Method calls like getCacheRegionFactory are clear. Minor complexity from chained methods and assumptions about external getters, but overall highly comprehensible for Java developers.","tokens":914,"name":"191.jsnp"}
{"score":"95","reasoning":"Clean Java constructor with Javadoc comment explaining purpose. Registers SQL functions using consistent pattern on separate lines for clarity. Straightforward logic, no complexity, assumes Hibernate context knowledge. Excellent readability and comprehension ease.","tokens":941,"name":"21.jsnp"}
{"score":"65","reasoning":"The code is a clear JUnit test method using assertTranslation for HQL queries. Strengths include straightforward assertions and explicit dialect exclusions. Weaknesses are long chained instanceof checks with repetition, making conditions hard to scan. Lacks helper methods or constants for dialects, impacting readability. Comprehensible for experts but verbose for quick understanding.","tokens":1231,"name":"89.jsnp"}
{"score":"85","reasoning":"Clear JUnit test method querying JMX MBeans for c3p0 PooledDataSource and verifying pool settings with assertions. Descriptive variable names like actual_minPoolSize aid readability. Logical flow with loop and break. Minor deductions for generic variable set, magic numbers in asserts, and slight formatting inconsistencies. Overall easy to comprehend for Java developers familiar with JMX.","tokens":1187,"name":"90.jsnp"}
{"score":"98","reasoning":"Clean Java constructor for InterbaseDialect with clear Javadoc comment. Registers column types and functions in a straightforward, consistent manner with each call on its own line for easy scanning. Simple super call and property set. Highly readable and comprehensible, minor grammar nit in comment irrelevant to code.","tokens":1090,"name":"20.jsnp"}
{"score":"95","reasoning":"Code is highly readable with clear comments guiding the buffering and reading logic. Logical if-else structure, descriptive names like bufferReader and eventBuffer, concise operations. Easy to follow event flow from buffer or parent reader. Minor deduction for nested conditions in buffer management.","tokens":993,"name":"151.jsnp"}
{"score":"98","reasoning":"The code features excellent readability: comprehensive Javadoc comment clearly documents purpose, parameters, and return value. Method name is descriptive. Body is simple and direct, using constructor with direct field mappings. No complexity, ideal for quick understanding by any Java developer.","tokens":847,"name":"67.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test with clear Javadoc explaining purpose. Uses meaningful names, concise setup, and targeted assertions for two dialects. Logical flow distinguishes dialect behaviors effectively. Minor repetition is intentional and clear. Easy to comprehend for Java developers familiar with testing frameworks.","tokens":1168,"name":"57.jsnp"}
{"score":"72","reasoning":"Clear test method name describes HQL fetch join scenario. Anonymous inner classes for executor and checker are verbose but idiomatic for older Java. Assertions are precise, checking list size, entities, fields, nulls, and lazy init conditionally. Relies on undeclared vars like yogiExpected. No generics, some deep nesting. Readable for Hibernate experts, moderate for others.","tokens":1215,"name":"98.jsnp"}
{"score":"98","reasoning":"Code is concise, well-indented, and follows best practices: null check prevents exceptions, try-catch safely closes reader ignoring IOExceptions common in cleanup. Override annotation adds clarity. Intent clear with ignore label. Extremely readable and comprehensible.","tokens":851,"name":"150.jsnp"}
{"score":"92","reasoning":"The code is a concise JUnit test method testing entity history in Hibernate Envers. It fetches current entities and audit revisions linearly, then asserts set equality with clear expectations. Descriptive variable names like ed1, rev1 aid comprehension. Repetitive assertions for rev2-rev5 are minor drawback, but logic is straightforward and easy to follow for framework users.","tokens":1116,"name":"166.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test with clear annotations, descriptive name, and comments explaining intent. Proper transaction handling, exception expectation, and resource cleanup. Minor deduction for complex Hibernate internals like SessionImplementor casting and long getter chains, which may challenge non-experts.","tokens":1134,"name":"93.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with descriptive variable names and clear assertions for entity binding closure. Handles indeterminate subclass order via iterator check and conditional logic effectively. Verbose iterator hasNext and next calls add slight repetition. Domain-specific terms assume familiarity, but logic flows logically. Good readability overall.","tokens":1260,"name":"181.jsnp"}
{"score":"82","reasoning":"The code has a clear structure with if-else blocks handling NULL, empty, valid ID, and invalid inputs. It correctly manages bidirectional Person-Address relationships by adding/removing from lists. Logic is straightforward and consistent. Minor issues: magic strings like NULL and empty string if-block doing nothing; uses System.err for errors instead of logging; assumes entityManager context. Readable for Java devs familiar with JPA.","tokens":1160,"name":"61.jsnp"}
{"score":"82","reasoning":"The code clearly overrides a method to register a Hibernate Integrator via anonymous inner class. It prepends a CustomLoadListener for EventType.LOAD events. Structure is logical with proper overrides and a private helper method to avoid duplication. Indentation is consistent, names are descriptive. Slightly verbose due to anonymous class and redundant integrate signatures, but comprehensible for Java and Hibernate users.","tokens":1081,"name":"174.jsnp"}
{"score":"95","reasoning":"Clear JUnit test method with descriptive name testing expected QueryException for fetch join in subquery. Follows standard try-catch-fail pattern. HQL query is concise and understandable for Hibernate users. Proper session management. Minimal but effective comments. Excellent readability and ease of comprehension.","tokens":916,"name":"81.jsnp"}
{"score":"98","reasoning":"The code is a clear concise JUnit test method for Hibernate. Descriptive test name explains purpose. Simple linear flow: open session start transaction persist entity flush rollback close. Follows standard practices no complex logic or errors highly readable and easy to comprehend.","tokens":872,"name":"133.jsnp"}
{"score":"88","reasoning":"Code is concise and clear: overrides runTest to spawn a thread running the test with try-finally for cleanup via runFinished. Anonymous inner class is old-style but straightforward. Comments clarify inlining due to VA/Java limits and super call avoidance. Minor nesting reduces perfect score but highly comprehensible for Java experts.","tokens":1019,"name":"73.jsnp"}
{"score":"82","reasoning":"Code has clear logical flow: extracts name and condition from XML element with fallbacks, processes aliases in a loop, and applies filter. Descriptive variable names and debug logging aid understanding. Drawbacks include outdated Iterator usage, TODO highlighting design flaw with mapping order dependency, and minor null check. Readable for experienced Java developers but could improve with modern Java idioms.","tokens":1214,"name":"31.jsnp"}
{"score":"72","reasoning":"The code is a straightforward JUnit test method with clear naming testNoLoss. It invokes assertNoLoss on multiple SQL strings testing various queries like insert delete update and complex selects with joins subqueries case statements and functions. Java structure is simple and easy to follow. However long multi-line SQL strings are dense hard to parse at a glance lack explanatory comments and include embedded SQL comment reducing overall readability and comprehension for quick review.","tokens":1478,"name":"101.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with descriptive name, clear variable names, helpful comment explaining scenario, logical flow with try-finally for cleanup, and precise assertions. Minor deductions for magic numbers in properties, type casts, and reliance on domain-specific Hibernate/Infinispan knowledge which may hinder broader comprehension.","tokens":1181,"name":"131.jsnp"}
{"score":"40","reasoning":"The method starts with clear null and identity checks, which are readable. However, the single return statement is extremely dense with chained conditions and deeply nested ternary operators for schema and catalog comparisons, handling quoting and case sensitivity. This makes the logic hard to parse at a glance, reducing overall readability and comprehension. Refactoring into helper methods or if statements would help significantly.","tokens":1043,"name":"36.jsnp"}
{"score":"88","reasoning":"Well-structured method with clear variable names using final for locals, logical flow from schema setup to entity creation, ID configuration, and relations. Helpful comments explain key decisions like where clause and revision info. Domain-specific terms and external dependencies slightly reduce standalone comprehension, but easy for experienced Java devs.","tokens":1378,"name":"170.jsnp"}
{"score":"87","reasoning":"Code follows a clear pattern of copying properties from source to binding via setters, making it easy to follow. Logical progression from fetch settings to custom SQL and meta attributes. Variable names are descriptive. Minor deduction for duplicated conditional logic for setting collectionPersisterClass, which could be merged for better clarity. Suitable for developers familiar with Hibernate.","tokens":1367,"name":"146.jsnp"}
{"score":"72","reasoning":"Clear JUnit test structure with descriptive method name and straightforward assertions on entity revisions. Intent is easy to grasp for those familiar with Hibernate Envers. However, verbose class names like ChildIndexedListJoinColumnBidirectionalRefIngEntity hinder readability. Repeated identical find calls for revisions 1-4 indicate lack of refactoring opportunity. Assumes predefined IDs like ed2_id.","tokens":1219,"name":"186.jsnp"}
{"score":"82","reasoning":"The code is a well-structured Hibernate test method testing orphan delete functionality. It follows a clear logical flow: setup data, persist, remove orphan, verify deletion while keeping other entities, and cleanup. Descriptive variable names and standard assertions aid comprehension. Minor deducts for string typos (e.g., if instead of of), repetitive session handling, cache evictions cluttering the test, and use of raw types. Highly readable for Java and Hibernate experts.","tokens":1489,"name":"192.jsnp"}
{"score":"92","reasoning":"Well-structured method with clear if-else branching for single vs composite keys. Concise comments clarify non-composite and composite cases. Leverages helper functions like repeat and replace effectively. Logic for dialect row value support is straightforward and readable. Assumes familiarity with constants and helpers, but overall highly comprehensible for experienced Java developers.","tokens":1178,"name":"112.jsnp"}
{"score":"62","reasoning":"Code has clear sequential logic for generating UUIDs by packing time bytes and setting version bits, with descriptive variable names and a validation check. However, excessive verbose print statements with long tilde strings severely clutter the code, making it hard to skim. Relies on undefined external classes like BytesHelper and Helper, reducing standalone comprehension. Suitable for experienced Java devs but not novices.","tokens":1606,"name":"58.jsnp"}
{"score":"82","reasoning":"Code is well-structured with descriptive variable names like isImpliedOptimisticLocking and loadedState. Clear logical flow: checks locking, loads state if needed, generates SQL deletes, loops over tables. Javadoc and comments aid understanding. Minor complexity from Hibernate-specific calls like generateEntityKey and persistence context reduces general accessibility.","tokens":1195,"name":"106.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear Javadoc explaining purpose. Descriptive names like handleNaturalIdPostSaveNotifications and getPersistenceContext. Straightforward logic: conditional early insert handling followed by shared cache management. Domain-specific Hibernate terms like NaturalIdHelper and Persister assume framework knowledge, slightly impacting broad comprehension, but highly readable for experts.","tokens":984,"name":"103.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear variable names, logical flow, and effective use of ternary operators. Handles annotations concisely, checks inheritance state appropriately. Long fully qualified class names slightly hinder readability. Highly comprehensible for developers familiar with JPA and Hibernate.","tokens":1126,"name":"28.jsnp"}
{"score":"98","reasoning":"Standard Java equals implementation with clear early returns for quick failures. Proper instanceof check, casting, and null-safe string comparisons using ternary operators. Concise, follows conventions, highly readable and easy to understand for any Java developer.","tokens":868,"name":"60.jsnp"}
{"score":"72","reasoning":"The method is concise and logically structures boundary points using xs and ys arrays for a Geometry utility call. Intent is clear for experts in graphics code, but arrays lack intuitive labeling, include a duplicate point, use magic number 5, and have no comments, making it less accessible for quick comprehension.","tokens":1415,"name":"153.jsnp"}
{"score":"65","reasoning":"The test method has a descriptive name and logical flow for Hibernate collection listener testing, with clear setup, modification, and verification steps using an index counter. However, it suffers from excessive type casting, nested if conditions for specific child types, magic strings, and reliance on Hibernate internals, reducing readability for non-experts.","tokens":1438,"name":"140.jsnp"}
{"score":"25","reasoning":"The code is hard to read due to excessive method chaining like ((SessionImplementor)session).getTransactionCoordinator().getJdbcCoordinator() repeated multiple times. Heavy reliance on internal Hibernate APIs with casting reduces comprehension. Hardcoded SQL strings, anonymous inner class nesting, and ignoring exceptions on drop table add to obscurity. Requires expert knowledge of Hibernate internals.","tokens":1055,"name":"100.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear parameter names, proper indentation, and logical if-conditions. Comments clarify intent for add/remove stereotype listeners. Single-statement blocks are concise. Drawbacks: magic string stereotype and domain-specific classes like Model.getFacade require context knowledge, slightly impacting broad comprehension.","tokens":1109,"name":"47.jsnp"}
{"score":"82","reasoning":"Clear JUnit test method with descriptive name testing Hibernate dialect limit handler for multi-table query. Simple input query contrasts with long expected SQL using window functions and TOP clause. String concatenation for expected value is readable but verbose. Assumes familiarity with Hibernate APIs like buildLimitHandler and toRowSelection. Good structure and purpose evident, minor deduction for length impacting quick scan.","tokens":1068,"name":"23.jsnp"}
{"score":"92","reasoning":"The code is short, clear, and follows standard JPA patterns: obtain EntityManager, begin transaction, persist entity via static factory, commit. Purpose of initializing data is obvious. Readable for Java/JPA users. Slight deduction for indentation inconsistency and undeclared country variable, likely a class field.","tokens":915,"name":"168.jsnp"}
{"score":"85","reasoning":"The method has a clear, logical structure with nested if conditions handling empty, single, and multiple list cases effectively. Indentation and spacing are consistent, enhancing readability. Descriptive method names aid comprehension. Minor deductions for unusual MockHelper utility name and assumed knowledge of constants like PRIMARY_KEY_JOIN_COLUMNS, which may confuse newcomers.","tokens":973,"name":"193.jsnp"}
{"score":"98","reasoning":"Clean and standard Java equals override with Javadoc documentation, clear early returns for null, type, and super checks. Straightforward logic flow makes it highly readable and comprehensible for all levels of developers.","tokens":1038,"name":"39.jsnp"}
{"score":"72","reasoning":"Code follows Java conventions with clear intent to sync targets to tree selection using flags to avoid recursion. However, nested loops over all rows per target are inefficient and hard to follow, long chained casts like getPathForRow(j).getLastPathComponent() reduce readability, magic booleans like updatingSelectionViaTreeSelection confuse, and domain types like Fig require context knowledge. Commented line distracts.","tokens":1081,"name":"50.jsnp"}
{"score":"62","reasoning":"This Hibernate JUnit test method tests collection queries with joins and filters. Readability is moderate: logical setup-teardown flow, but hindered by lengthy negated dialect if-condition, numerous unvariable-ized createQuery calls, magic HQL strings, sparse assertions, no comments, and assumption of entity model knowledge. Dense for quick comprehension, better for experts.","tokens":1619,"name":"68.jsnp"}
{"score":"92","reasoning":"Code uses StringBuilder efficiently with chained appends for performance and readability. Clear structure, logical conditional null check with helpful comment. Minor deduction for long chained lines slightly reducing scannability, but overall highly comprehensible and professional.","tokens":897,"name":"64.jsnp"}
{"score":"98","reasoning":"Clean Java constructor with descriptive Javadoc. Straightforward super call followed by consistent registerFunction registrations. Uniform line structure, no complex logic, excellent formatting. Minor deduction for long repetitive list, but remains highly readable and comprehensible.","tokens":1219,"name":"18.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test for Hibernate lazy associations using anonymous inner classes, clear method name and assertions verify expected results, sizes, nulls, and initialization states. Comment aids understanding. Minor issues: verbose anonymous classes, repeated casts like ((Student) resultList.get(0)), and redundancy in checks slightly hinder readability for non-experts.","tokens":1289,"name":"96.jsnp"}
{"score":"72","reasoning":"Well-structured JUnit test for Hibernate Criteria and HQL queries using aliases and fetch joins. Descriptive names and clear assertions aid comprehension. However, verbose anonymous inner classes, absence of comments, Hibernate-specific jargon, and conditional logic slightly hinder readability. Suitable for experienced developers but less accessible to novices.","tokens":1374,"name":"99.jsnp"}
{"score":"65","reasoning":"The method has a clear structure with conditional logic to generate code or copy input based on parsing success. However, readability is hindered by undefined variable name, unclear helper methods like ffCodePiece and newClassifier, outdated Stack usage instead of modern collections, StringBuffer over StringBuilder, inconsistent naming like mInterface prefix, and a commented-out cast. Requires significant context knowledge for full comprehension.","tokens":1061,"name":"116.jsnp"}
{"score":"95","reasoning":"Comprehensive Javadoc explains purpose and exceptions clearly. Descriptive method and variable names like firstDependentAction and nonNullableTransientDependencies aid understanding. Straightforward if-else logic: log if empty, else extract details and throw informative exception. Professional Hibernate-style code, highly readable for experienced Java developers. Slight deduction for iterator usage and external dependencies assumption.","tokens":1184,"name":"102.jsnp"}
{"score":"65","reasoning":"Code has clear structure with try-finally for barriers and timing logic. Good use of trace logging and descriptive variables. However, large commented-out while loop obscures intent, runs always 0 making it non-functional, and undefined vars like isTrace barrier reduce standalone comprehension. Indentation slightly off.","tokens":1172,"name":"172.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test with clear variable names and assertions. Logic is straightforward: populates properties and verifies filtered output has only create\u003dtrue. Numbered prefixes on most keys indicate testing extraction logic. Minor duplication in password properties slightly reduces clarity but does not hinder comprehension.","tokens":1118,"name":"35.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method testing JPA association annotations in Hibernate. Clear logical flow: builds XML context, accesses fields, creates annotation reader, and performs precise assertions on annotation presence, properties, and values. Descriptive variable names and concise assertions enhance readability. Assumes domain knowledge but straightforward for experienced Java developers. High comprehension ease.","tokens":1360,"name":"135.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with clear annotations explaining purpose and dialect skips. Logical sequence: native SQL inserts to force whitespace, Hibernate queries with assertions, parameterized query test, and cleanup. Uses final locals appropriately. Minor concerns: string concatenation in SQL and transaction begin after inserts, but easy to follow for Hibernate users.","tokens":1210,"name":"136.jsnp"}
{"score":"62","reasoning":"Code is functional but uses outdated Vector and Enumeration instead of modern iterators or streams. Inconsistent log message singular vs plural method name. Redundant ToDoList fetching. Hardcoded path array with magic size 2. Nested loops are clear but inefficient. Logic comprehensible for Java experts, but lacks modern style and comments.","tokens":1305,"name":"46.jsnp"}
{"score":"88","reasoning":"Short, clear method with simple if-check and single method call. Descriptive name and comment aids understanding of proxy handling intent. Good indentation. Always returns null regardless of input, which slightly reduces clarity on purpose without broader context. Overall highly readable.","tokens":1194,"name":"65.jsnp"}
{"score":"82","reasoning":"Well-structured method with clear if-else flow and descriptive parameter names like optionalEntityName. Indentation and braces are consistent. Single long chained condition for composite identifier check reduces readability slightly. Assumes domain knowledge of Hibernate but logic is straightforward and commented helpfully.","tokens":1115,"name":"198.jsnp"}
{"score":"92","reasoning":"The code is highly readable with clear structure following standard equals implementation: identity check type check then field comparisons. Simple if statements with early returns enhance comprehension. Excellent Javadoc documentation though return description inaccurately mentions only second and minute while code checks hour and day too. Minor doc mismatch but code logic is straightforward and professional.","tokens":1183,"name":"42.jsnp"}
{"score":"88","reasoning":"The code is a well-structured JUnit test for a Hibernate HQL query with distinct select and join. Clear flow: setup database, execute paginated query, assert no duplicates by checking list contents. Readable variable names and logical assertion. Minor deductions for typo in comment (dublicated), magic numbers (10,5), broad suppress warnings, and commented-out print statement. Highly comprehensible for Java/Hibernate users.","tokens":1092,"name":"92.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test for Hibernate issue HHH-2277 with clear setup save load and cleanup phases. Extensive comments explain the bidirectional association composite key and infinite loop problem enhancing comprehension. Descriptive method name intentional but lengthy. Standard patterns used minor variable reuse. High readability for familiar audience slight deduction for specificity.","tokens":1189,"name":"175.jsnp"}
{"score":"88","reasoning":"The code is well-structured with clear if-else logic, descriptive variable names like elementType and collectionReference, and informative logging and exceptions. It follows Java conventions effectively. Minor deductions for long lines in log and exception messages, and reliance on domain-specific classes which may reduce accessibility for non-experts.","tokens":1025,"name":"183.jsnp"}
{"score":"82","reasoning":"Well-structured Java unit test for failure reporting in a test runner. Uses anonymous inner classes idiomatically to customize printer and test case. Clear purpose, logical flow from setup to assertion. Dense nesting and assumed context like expected method slightly reduce ease for beginners, but highly readable for experienced developers.","tokens":1007,"name":"12.jsnp"}
{"score":"92","reasoning":"The code is a well-structured JUnit test method using descriptive assertion names to verify ElementCollection annotation presence, absence of related annotations, and specific properties like fetch type. Repetitive assertAnnotationNotPresent calls are verbose but clearly enumerate each check, aiding comprehension. Easy to read for Java and JPA experts, with proper setup and no complex logic.","tokens":1183,"name":"176.jsnp"}
{"score":"85","reasoning":"The method is short, has a clear name, and uses vertical alignment for constructor parameters, enhancing readability. It performs a simple validation and creation task. Minor issues include reliance on undefined instance variables like transactionType and a TODO comment signaling incomplete features, which may confuse newcomers slightly.","tokens":963,"name":"55.jsnp"}
{"score":"72","reasoning":"Code has clear purpose with Javadoc and early return for efficiency. Logic for loading bundles via default then custom classloaders is straightforward. Drawbacks include outdated raw Iterator usage without generics, nested try-catch blocks, long debug lines, and caching potentially null bundle. Minor indentation issues from snippet. Comprehensible but dated style reduces modern readability.","tokens":1168,"name":"7.jsnp"}
{"score":"85","reasoning":"Clear test method with descriptive comments explaining each revision. Consistent pattern of transactions, finds, and modifications makes it easy to follow the sequence of adds and removes. Repetition is expected in tests but slightly verbose. Assumes external definitions for c3_1, c3_2, and entity class. Good readability overall.","tokens":1247,"name":"188.jsnp"}
{"score":"72","reasoning":"Clear JUnit test structure with try-catch-finally for exception handling. Descriptive assert message and logical flow aid comprehension. However, deep nested method chaining like sessionImpl.getTransactionCoordinator().getJdbcCoordinator() hinders readability. Internal casting to SessionImplementor and magic string NON_EXISTENT reduce clarity. Suitable for experts but not beginners.","tokens":996,"name":"145.jsnp"}
{"score":"65","reasoning":"Code logic is clear, handling aggregation kinds correctly with proper null checks. However, deep nesting of if-else reduces readability. Verbose repeated calls to Model.getAggregationKind().getXXX() could be cached. Inconsistent line breaks and indentation add minor confusion. Suitable for experienced Java devs but improvable with flatter structure or switch.","tokens":1223,"name":"157.jsnp"}
{"score":"92","reasoning":"Well-structured if-else chain with clear precedence logic for selecting loaders. Descriptive comments explain each branch purpose, aiding comprehension. Method is concise yet handles multiple conditions effectively. Minor issues: long lines and casts slightly reduce perfect score, but overall highly readable for Java/Hibernate developers.","tokens":1155,"name":"107.jsnp"}
{"score":"98","reasoning":"Simple, clean constructor with descriptive method names that clearly indicate purpose. Proper indentation, single responsibility per line, and superclass call first. Javadoc is present and informative, minor grammar nitpick on article does not impact readability.","tokens":797,"name":"19.jsnp"}
{"score":"95","reasoning":"This JUnit test method is highly readable with a clear purpose: testing SQL TRIM function template rendering. It uses a consistent pattern across cases - set fragment, render, assert - covering variants like both, leading, trailing, and char specs. Repetition aids explicitness without confusion. Assumes class context but self-explanatory overall.","tokens":1298,"name":"26.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with logical flow: setup map, assert revisions 15-16, query deletion at 17. Clear assertions and Envers usage. Drawbacks: undeclared vars like ternaryMapId intEntity1, repeated getMap calls, magic numbers 15-17, long constructor lines, casting in query. Readable for Java Envers experts, less for novices.","tokens":1303,"name":"167.jsnp"}
{"score":"72","reasoning":"The code is a clear JUnit test method testing HQL parser with various query strings. Structure is simple and linear, aiding readability. However, long unwrapped strings make lines hard to scan, duplicate parse calls exist, minimal comments provide little context for each test case, and trailing commented code adds minor clutter. Overall comprehensible for experienced developers but could improve with string splitting or descriptive names.","tokens":1273,"name":"85.jsnp"}
{"score":"92","reasoning":"Clear Javadoc documentation explains purpose parameters and exceptions. Method follows standard Java serialization pattern with defaultReadObject followed by consistent reads of Paint objects via SerialUtilities. Repetitive structure is straightforward though verbose making it highly readable for experienced Java developers.","tokens":1165,"name":"3.jsnp"}
{"score":"88","reasoning":"Concise method with clear purpose in Hibernate lazy loading. Descriptive parameters, straightforward logic: sets value, updates snapshot if present, checks name match. Final modifiers aid readability. External arrays like lazyPropertyNumbers and types reduce standalone comprehension but typical in framework code. Minor comment grammar issue. High score for experts.","tokens":981,"name":"104.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive method name and assertion messages. Logical flow testing date arithmetic types. Minor repetition in translator creation and assumptions about Hibernate types slightly impact perfect score but highly readable for experienced Java developers.","tokens":1221,"name":"88.jsnp"}
{"score":"95","reasoning":"Well-documented Javadoc clearly describes method purpose, parameters, and return. Concise, linear body: creates context, iterates PersistentClasses calling helper method, handles superclasses, wraps up, returns MetamodelImpl. Descriptive names, standard Java idioms. High readability for Java/Hibernate context; minor deduction for domain-specific types assuming familiarity.","tokens":1087,"name":"126.jsnp"}
{"score":"95","reasoning":"Code is concise with descriptive method and variable names like shouldReturnOnlyTheNamedDataPoints and assignedStrings. Clear intent to test supplier returns exactly 4 named string values using standard JUnit assertEquals and assertThat. Easy to follow despite external helpers like getValueSources and signature. High readability for Java developers.","tokens":916,"name":"159.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test method with descriptive name and logical flow: setup reader, assert annotation presence/absence, then verify AttributeOverrides details comprehensively. Repetitive column assertions are thorough but slightly verbose. Clear variable names and assertions make it easy to follow for Java/JPA experts.","tokens":1335,"name":"177.jsnp"}
{"score":"82","reasoning":"The code is concise and follows standard Java event handling patterns with clear if-condition logic and meaningful variable names. Method chaining is readable. However, presence of commented-out lines and a comment about updating panes without corresponding code slightly reduces clarity and suggests incompleteness, making it less straightforward for quick comprehension.","tokens":941,"name":"11.jsnp"}
{"score":"72","reasoning":"The JUnit test method has an excessively long name that is hard to parse at a glance, impacting readability. The body is simple and linear with four clear method calls. A single comment clarifies the first call. Overall comprehensible for familiar developers but verbose naming reduces ease for newcomers.","tokens":977,"name":"187.jsnp"}
{"score":"85","reasoning":"Code is simple and straightforward with clear variable names and consistent patterns for calling methods on two listeners for two regions. Easy to comprehend purpose: resetting region usage state. Minor deductions for repetition that could use a loop or helper, lack of comments, and hardcoded class names instead of constants.","tokens":1046,"name":"190.jsnp"}
{"score":"88","reasoning":"Code is well-structured with clear logical flow: checks field count, instantiates test class, injects parameters via loop. Descriptive variable names and detailed exception messages aid comprehension. Minor deductions for long concatenated strings in exceptions and lengthy lines impacting readability.","tokens":1074,"name":"13.jsnp"}
{"score":"92","reasoning":"The code is a clear static initializer registering Java notation providers via a factory. It features good structure, consistent formatting, meaningful variable names like npf and name, and a helpful Javadoc comment. Repetitive addNotationProvider calls are straightforward. Minor deduction for the unused commented line inside the assignment, which slightly reduces cleanliness but does not hinder comprehension.","tokens":1104,"name":"5.jsnp"}
{"score":"72","reasoning":"The code demonstrates a clear test structure for Hibernate composite IDs: save, SQL query, and get operations. However, readability is hindered by inconsistent indentation, verbose repeated session/transaction handling, magic strings like c64 and games, suboptimal variable names such as getted and useForGet, a complex aliased SQL query, and a comment noting a limitation. Suitable for experienced Hibernate users but less accessible otherwise.","tokens":1446,"name":"72.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with descriptive names like noInheritanceEntityBinding and clear assertions for entity binding properties. Uses standard JUnit patterns effectively. Minor deductions for repetitive iterator checks, long chained method calls, and dense sequence of assertions which can feel tedious.","tokens":1312,"name":"180.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test for Hibernate HQL feature. Clear logical flow: data setup, query execution with assertion, and cleanup. Descriptive variable names like tiger, mother, zoo. Standard session management patterns. Single comment clarifies intent. Complex HQL query is central but comprehensible in context. SuppressWarnings appropriate. Highly readable for experienced Java developers.","tokens":1173,"name":"82.jsnp"}
{"score":"72","reasoning":"Code has useful Javadoc and clear intent to save or remove shortcuts based on changes from defaults. Logic is straightforward with a simple loop and conditional branches. However, very long lines with chained method calls reduce scannability, and reliance on external shortcutHash without local declaration adds minor confusion. Suitable for experienced Java developers but could benefit from line breaks and extracted helpers.","tokens":1091,"name":"51.jsnp"}
{"score":"78","reasoning":"The method has a clear Javadoc explaining JPA context and purpose. It uses a straightforward loop and sequential calls to descriptive helper methods like getFetchType and getColumn, aiding readability. However, it is lengthy with many similar operations, magic string usage, and dependency on undefined helpers like elementsForProperty and buildAttributeOverrides, assuming domain expertise which slightly hinders general comprehension.","tokens":1360,"name":"149.jsnp"}
{"score":"95","reasoning":"Well-documented Javadoc explains purpose clearly. Meaningful variable names like positive, negative, minimum, maximum aid comprehension. Straightforward nested loops over categories and series accumulate stacked values from base, handling nulls and signs correctly. Uses infinities for bounds properly. Logic is intuitive for stacked range calculation. Only minor informality in one inline note prevents perfect score.","tokens":1177,"name":"41.jsnp"}
{"score":"35","reasoning":"The test method has a clear purpose: verifying a specific Hibernate Envers column name. However, readability is poor due to excessive method chaining, deep nesting, lengthy fully-qualified class name, casting, and iterator.next() assumption. Line breaks mitigate slightly but it demands strong domain knowledge for easy comprehension.","tokens":1003,"name":"199.jsnp"}
{"score":"85","reasoning":"Well-structured Java method with clear Javadoc and inline comments explaining concurrency choices like readLock and CAS loops for min/max times. Efficient use of AtomicLongs. Loops are idiomatic but slightly tricky for beginners due to spin-wait pattern and reused variable old. Overall readable for experienced engineers.","tokens":1033,"name":"62.jsnp"}
{"score":"98","reasoning":"Clear JUnit test method with descriptive names like limit, offset, input, expected. Well-formatted multiline SQL strings. Straightforward logic: sets up input SQL with for update and with clauses, generates expected output with offset and limit, asserts equality. Purpose instantly comprehensible. Minor deduction for no additional comments.","tokens":985,"name":"24.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with descriptive name and assertion messages explaining expectations. Clear flow: setup configuration, build factory, verify tuplizers. Domain-specific Hibernate classes assume familiarity, but code is concise and follows conventions. Minor deduction for magic number in getGetter(0) and generic throws Exception.","tokens":988,"name":"178.jsnp"}
{"score":"92","reasoning":"The code is highly readable with clear comments labeling each revision, consistent transaction patterns (begin, persist, commit), and descriptive variable names like propertyEntityId. Structure is logical and repetitive in a beneficial way. Long fully-qualified class names in strings slightly hinder flow, but it remains easy to comprehend for Java and Hibernate users.","tokens":1242,"name":"189.jsnp"}
{"score":"82","reasoning":"Method is concise with clear single purpose. Good use of final variable and line breaks for long return statement enhance readability. Intent is evident from name and structure. However, heavy reliance on framework-specific types like QueryableCollection and casts assumes prior knowledge, slightly hindering general comprehension.","tokens":1058,"name":"148.jsnp"}
{"score":"92","reasoning":"Code is well-structured and readable. Clear purpose: validates Parameter annotation indices for bounds, uniqueness, and full coverage. Descriptive names like annotatedFieldsByParameter and usedIndices. Logical flow with super call, bounds check, usage counting via array, then error reporting. Concise loops, informative error messages. Minor density but easy to comprehend for Java developers.","tokens":1224,"name":"14.jsnp"}
{"score":"82","reasoning":"Well-structured conditional logic clearly determines if an entity is non-dirty using multiple strategies. Good use of early returns and type checks. However, dense Hibernate-specific APIs, long chained method calls, and magic method names like $$_hibernate_hasDirtyAttributes reduce general readability without domain knowledge.","tokens":1080,"name":"111.jsnp"}
{"score":"78","reasoning":"Well-structured Java method with clear initial validation, descriptive exceptions, and comprehensive switch handling for text events like CHARACTERS, CDATA, SPACE, and ENTITY_REFERENCE expansion. Good use of StringBuilder and ignores irrelevant events. However, logical flaws reduce comprehension: processes initial START_ELEMENT in loop causing immediate throw, no END_ELEMENT handling to exit element text properly, and END_DOCUMENT loop condition mismatches getElementText purpose.","tokens":2121,"name":"152.jsnp"}
{"score":"92","reasoning":"The code is concise and straightforward, creating an array of UML action methods with null separators likely for menus. Method names are descriptive, structure is clear and easy to follow. Deduction for lack of comments explaining nulls purpose and use of generic Object array instead of specific type.","tokens":1050,"name":"156.jsnp"}
{"score":"72","reasoning":"Code uses verbose anonymous inner classes for CriteriaExecutor and ResultChecker, common in legacy Hibernate tests but less readable than modern lambdas. Structure is logical with clear assertions and a comment on known issue. Assumes familiarity with Hibernate API, entities like Student, and variables like yogiExpected. Overall comprehensible for experts but dense for newcomers.","tokens":1275,"name":"97.jsnp"}
{"score":"88","reasoning":"Clear JUnit test with descriptive long method name explaining intent. Uses standard patterns: expectMessage for assertion, try-catch to suppress first exception, then triggers timeout on second call. Concise and logical flow, easy for Java developers familiar with JUnit. Minor deductions for external dependencies like thrown, TIMEOUT and broad throws Throwable.","tokens":943,"name":"160.jsnp"}
{"score":"35","reasoning":"Code is ANTLR-generated parser method with labeled do-while loop using magic numbers like _loop119 and _tokenSet_6, plus LA(1) lookahead. Structure is clear but cryptic without context, lacks comments, unnecessary braces. Indentation aids slightly, but low readability for general comprehension.","tokens":934,"name":"115.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with clear logical flow: setup entities, persist, retrieve, and assert relationships. Meaningful variable names and informative skip annotations enhance readability. Minor deductions for verbose multi-line annotations, hardcoded IDs, unnecessary println, and trim calls indicating potential data issues. Comprehensible for Java and Hibernate experts.","tokens":1206,"name":"138.jsnp"}
{"score":"95","reasoning":"Well-structured Java method with comprehensive Javadoc and inline comments explaining purpose, lazy event creation, and listener processing order. Descriptive parameter and variable names. Standard Swing listener list pattern is clear despite loop indexing from end. Efficient and easy to comprehend for Java developers.","tokens":1090,"name":"9.jsnp"}
{"score":"92","reasoning":"Code is well-structured JUnit test with clear comments explaining purpose. Verifier class uses simple DFS traversal via Stack to detect NOT-EXISTS AST pattern effectively. Variable names are mostly clear, logic straightforward. Minor deduction for naming Stack as queue, which is misleading. Easy to comprehend for Java developers familiar with ASTs.","tokens":1122,"name":"87.jsnp"}
{"score":"88","reasoning":"The method has clear purpose, logical flow, and descriptive names. Handles stack traces, interruptions, and conditional stuck thread logic effectively. Uses standard Java idioms like String.format and Arrays.asList. Minor deductions for magic strings, field dependencies (fTimeout etc.), and slightly verbose generics. Overall highly readable and comprehensible for experienced developers.","tokens":1039,"name":"125.jsnp"}
{"score":"98","reasoning":"The code is exceptionally readable and easy to comprehend. It features a clear Javadoc comment explaining the override purpose. The logic is simple and straightforward with two if statements checking for newline characters, setting boolean flags, and returning true or false. Proper indentation, short method length, and single responsibility enhance clarity. Minor deduction for assuming external variables hasLf and hasCr.","tokens":878,"name":"6.jsnp"}
{"score":"82","reasoning":"The code is a well-structured Java constructor for a Swing-based property panel. It uses consistent patterns for adding fields, separators, and actions with localized labels. Javadoc provides clear purpose. Variable names are mostly descriptive but some terse like a and resList. Framework dependencies like UML classes and Translator reduce ease for non-experts. Overall readable and comprehensible for Java Swing developers.","tokens":1157,"name":"158.jsnp"}
{"score":"65","reasoning":"Code intent is clear: handles ownedElement changes by removing nodes or edges on deletion. However, excessive repetition of similar if checks for types calling removeNode or removeEdge hurts readability. Repeated Model.getFacade calls and use of outdated Vector add clutter. Could benefit from refactoring into a type hierarchy check or map. Straightforward logic but verbose.","tokens":1200,"name":"119.jsnp"}
{"score":"95","reasoning":"The code is simple and clear: initializes a HashSet with predefined string constants for hints, adds them one by one, and returns an unmodifiable set. Descriptive method name, proper use of generics, standard Java idioms. Repetitive adds are straightforward but could be streamlined with an array. Excellent readability and comprehension.","tokens":939,"name":"16.jsnp"}
{"score":"78","reasoning":"The code has clear purpose via Javadoc and uses efficient StringBuilder. Logic is straightforward loop with conditional fragment building. However, dense variable initializations, long lines, nested ternaries, and magic numbers like size*100 hinder readability. Good for domain experts but less accessible to juniors.","tokens":1238,"name":"34.jsnp"}
{"score":"98","reasoning":"The code is a simple Java constructor with a clear Javadoc comment explaining its purpose. It calls super() then registers column types in a consistent, well-indented list. No complex logic, straightforward mappings, highly readable and easy to understand for any Java developer familiar with JDBC.","tokens":958,"name":"25.jsnp"}
{"score":"95","reasoning":"Well-documented with clear Javadoc. Simple, linear logic: fetch element, return null if absent or handle specific exceptions gracefully. Uses final keywords appropriately. Explicit if-else aids clarity. Minor deduction for slightly verbose structure, but highly readable for Java developers familiar with caching.","tokens":929,"name":"164.jsnp"}
{"score":"65","reasoning":"The code features a straightforward for loop with clear structure, proper indentation, and well-broken argument lines for the long method call. However, the extremely verbose and repetitive getter method names like getSubclassPropertyNameClosure make it hard to read and comprehend quickly without domain knowledge. Repeated getter calls inside the loop also suggest minor inefficiency impacting clarity.","tokens":1110,"name":"105.jsnp"}
{"score":"78","reasoning":"Well-structured JUnit test with clear setup, assertions, and logical progression. Descriptive variable names and standard testing patterns enhance readability. However, heavy reliance on Hibernate-specific classes like EntityPersister and CascadeStyleLoadPlanBuildingAssociationVisitationStrategy requires domain expertise, reducing general comprehension.","tokens":1111,"name":"142.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with descriptive name and inline comments guiding through test steps: baseline query, then enabling filters progressively. Clear session management, assertions, and logical flow. Minor deductions for magic numbers in asserts (2,1,0), hardcoded query and filter names assuming domain knowledge. Highly readable for Java/Hibernate developers.","tokens":1197,"name":"91.jsnp"}
{"score":"92","reasoning":"Code is concise, logical, and follows standard JAXB unmarshalling steps clearly. Variable names are mostly descriptive, with minor abbreviations like jc. Assumes JAXB familiarity but self-explanatory flow. No comments needed due to simplicity. High readability for experienced Java devs.","tokens":918,"name":"194.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear Javadoc comment explaining purpose. Logical flow: extract ResultSet, wrap if needed, handle limits, discover types, return. Meaningful names like rs, st, session. Proper exception handling with resource release. Uses final params correctly. Minor issues: long parameter list and Hibernate-specific dependencies reduce accessibility for non-experts.","tokens":1099,"name":"33.jsnp"}
{"score":"72","reasoning":"Code logic is clear and linear: handles double-click on two tables with selection checks and early returns. Sets targets appropriately. Drawbacks include non-descriptive names like sel and d, outdated Vector usage with elementAt, raw Object types lacking generics, no comments, and reliance on undeclared globals like LOG and TargetManager. Comprehensible for Java experts but less so for novices.","tokens":1150,"name":"10.jsnp"}
{"score":"68","reasoning":"The method has a clear logical structure using if-else chains to dispatch events based on type and listener instanceof checks, with safe casting. However, significant code duplication between ANY_EVENT and specific event branches reduces readability and increases maintenance burden. Repetitive patterns for module, notation, and generator events suggest need for refactoring, like polymorphism or a switch on event type, making comprehension moderate.","tokens":1345,"name":"43.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method for HiLo optimizer usage with two distinct scenarios explained by comments. Descriptive names, simple loops, and precise assertions enhance readability. Minor deductions for magic numbers like -1 and 10, and slightly long method that repeats patterns. Easy to follow for Java test code reviewers.","tokens":1295,"name":"56.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear Javadoc, generics, and nested try-finally for robust cleanup. Inline comments explain todo for double iteration and query cache logic. Variable names are descriptive. Slightly complex for non-Hibernate users due to domain specifics, but overall highly readable and comprehensible.","tokens":1295,"name":"110.jsnp"}
{"score":"62","reasoning":"Code employs deeply nested anonymous inner classes, increasing complexity and reducing readability. Assumes expertise in Infinispan, Hibernate, and JTA frameworks. Conditional logic is simple, but dense structure and lack of comments hinder quick comprehension for average readers.","tokens":1045,"name":"132.jsnp"}
{"score":"88","reasoning":"Well-structured method using reflection to create test instances with comprehensive try-catch blocks for various exceptions. Clear logical flow: retrieve constructor, instantiate based on parameters, handle TestCase naming. Descriptive variable names and specific error messages enhance readability. Minor deductions for reflection complexity and undefined helper methods like warning and exceptionToString.","tokens":1102,"name":"2.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear purpose in transaction management. Descriptive variable names like flush, isDriver, isInitiator aid comprehension. Logical flow: notifications, conditional flush with comment, completion call, close. Complex flush condition is readable despite nesting. Professional code, high readability for experienced engineers.","tokens":1126,"name":"184.jsnp"}
{"score":"98","reasoning":"The code is highly readable with clear Javadoc documentation, proper Override annotation, and a standard equals implementation. It uses simple, explicit if-checks for each field, making it easy to follow and understand. Minor repetition in comparisons does not detract from clarity. Overall, excellent comprehension for any developer.","tokens":1017,"name":"114.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test method with clear sequential flow: session setup, entity creation with descriptive variables, save, queries testing different scenarios, delete, and cleanup. Helpful TODO comment explains limitation. Minor deductions for suppressed warnings, domain-specific Hibernate assumptions, and whimsical magic strings like the loneliest number that require context.","tokens":1231,"name":"80.jsnp"}
{"score":"65","reasoning":"Clear test purpose with good structure, try-catch-finally, and comments. Uses anonymous inner class which is verbose. Long chained method calls and casts to internal Hibernate classes like SessionImplementor make it hard to follow without deep framework knowledge. Assumes external helper like releaseStatement.","tokens":1025,"name":"94.jsnp"}
{"score":"88","reasoning":"Method has clear purpose: save graphics with overwrite confirmation. Uses try-finally for safe resource handling. Descriptive params and vars. Swing dialog is standard but long line reduces readability slightly. Indentation minorly inconsistent in snippet. Straightforward logic, comprehensible for experienced Java devs.","tokens":1075,"name":"49.jsnp"}
{"score":"55","reasoning":"Code is repetitive with 11 nearly identical doTest calls varying only boolean arrays. Actual duplication of false false true array. Lacks loop or parameterization to generate combinations, making it tedious to comprehend full test coverage. Pattern is consistent and simple, but poor abstraction reduces readability.","tokens":1162,"name":"59.jsnp"}
{"score":"87","reasoning":"Well-structured JUnit test for Hibernate with detailed comments explaining the implicit join issue and expected behaviors. Descriptive variable names, logical flow: setup entities, run queries with checkCounts, cleanup. Assumes domain knowledge but easy to comprehend. Minor deductions for magic numbers in counts and long comments.","tokens":1269,"name":"78.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear method name, descriptive parameters, and structured loops over superclasses. Helper methods like getSuperClasses and addToAnnotationLists improve comprehension. Comment clarifies field sorting intent. Complex generics are standard for Java reflection but slightly dense. Suitable for experienced developers.","tokens":964,"name":"52.jsnp"}
{"score":"72","reasoning":"Code structure is simple with null check and try-catch ignoring errors, clear intent to release PreparedStatement. However, long chained method call with casting to SessionImplementor obscures readability, assuming internal Hibernate knowledge, making it less accessible to general readers.","tokens":892,"name":"95.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with descriptive parameter and variable names. Clear logic flow using early return and conditional sets. Section comment separates concerns effectively. TODO note adds context without confusion. Straightforward instanceof check and casting. Easy to comprehend for developers familiar with Hibernate, minor assumption on metadata availability.","tokens":1109,"name":"147.jsnp"}
{"score":"92","reasoning":"This JUnit test method features a clear descriptive name and explanatory comments highlighting the pathological use of keywords as identifiers. Each parse call is on a separate line for easy scanning, and the intentionally malformed queries are the tests focus, not obscuring the simple structure. Minor points off for one commented line and whimsical tone, but overall very readable and comprehensible.","tokens":1098,"name":"86.jsnp"}
{"score":"82","reasoning":"Well-documented with helpful Javadoc explaining purpose and caveats. Clear variable names and simple loop structure aid comprehension. Logic is straightforward: fetch ToDoItems for owner and self, paint icons sequentially. Deductions for code duplication in two nearly identical blocks, outdated Vector usage without generics, and magic number in iconY calculation.","tokens":1246,"name":"121.jsnp"}
{"score":"88","reasoning":"Well-structured Java unit test method with clear intent to verify lock behavior after registration and invalidation. Meaningful parameter names, proper try-finally for lock handling, and exception wrapping. Minor deductions for nested anonymous CacheManagerCallable, magic constant NAKED_PUT_INVALIDATION_PERIOD, and external dependencies assuming familiarity with codebase.","tokens":1100,"name":"173.jsnp"}
{"score":"35","reasoning":"Code has poor readability due to inconsistent spacing, indentation, and naming conventions (some fields with underscore prefix, others without). Extremely long chained return statement is hard to parse. Inconsistent null handling risks NPEs. Commented lines distract. Custom array comparisons vary in style. Overall, difficult to comprehend quickly despite clear intent to compare fields.","tokens":1770,"name":"74.jsnp"}
{"score":"85","reasoning":"Well-structured Java Swing constructor with clear sequential setup of table model, fonts, columns, and layout. Logical flow and descriptive variable names aid readability. Minor deductions for magic numbers in widths, repeated setAutoResizeMode call, and assuming undeclared table as field. Comprehensible for experienced developers.","tokens":1035,"name":"118.jsnp"}
{"score":"92","reasoning":"The code is a well-structured JUnit test method with detailed initial comments explaining the bug context and property definitions. It follows a consistent repetitive pattern of SyntaxChecker calls for HQL queries, which is straightforward and easy to scan. Descriptive method name, annotations, and uniform structure aid comprehension for Hibernate testers. Minor repetition is typical for such tests.","tokens":1317,"name":"79.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test for Hibernate refresh after direct SQL update. Clear flow: setup, update via doWork, refresh with lock modes, assertions, cleanup. Good use of dialect checks and skip annotation. Minor issues: anonymous inner class over lambda, hardcoded SQL string. Highly comprehensible for Java/Hibernate devs.","tokens":1056,"name":"69.jsnp"}
{"score":"95","reasoning":"Code is concise and well-structured with a clear Javadoc explaining purpose. Anonymous inner class cleanly overrides one method for testing concurrent addFirstListener behavior. Readable for Java developers familiar with JUnit. Assumes base class knowledge but snippet is self-explanatory overall.","tokens":927,"name":"53.jsnp"}
{"score":"92","reasoning":"The code is concise, well-indented, and uses a familiar hashCode pattern with null checks and prime multiplier. Logic is easy to follow despite minor asymmetry in PRIME multiplication only after name field, which could lead to suboptimal hashing but does not obscure readability or comprehension.","tokens":1402,"name":"141.jsnp"}
{"score":"88","reasoning":"Clear JUnit test method with descriptive variable names, meaningful assertions, and explanatory comments. Purpose is straightforward: verify stack trace contents post-timeout. Minor deduction for verbose names and manual loop inspection which could be streamlined, but overall highly readable for Java developers.","tokens":1070,"name":"161.jsnp"}
{"score":"98","reasoning":"Standard well-structured Java equals override. Follows best practices: early reference check, superclass equals, class equality, safe cast, null-safe field comparison with early returns. Clean indentation, concise logic, highly readable and comprehensible for any Java developer familiar with equals pattern.","tokens":1098,"name":"169.jsnp"}
{"score":"95","reasoning":"The code is highly readable and easy to comprehend. It follows a clear, consistent pattern of registering strategy implementors for three transaction factories using short names and full class names. Repetition is straightforward without complexity, and method naming is descriptive. Slight deduction for potential loop optimization to reduce duplication.","tokens":969,"name":"171.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive method name. Proper indentation and line breaks make nested method calls readable. Clear intent: asserts extracted mod properties match expected set for a specific class. High comprehension for familiar audience, slight deduction for external dependencies like TestTools and getCfg.","tokens":932,"name":"165.jsnp"}
{"score":"92","reasoning":"The code is a standard Java equals method using null-safe ternary comparisons for detailId and master fields. It follows common idioms, is concise and correct, making it highly readable for Java developers. Slight deduction for dense ternary lines and no comments which could aid beginners.","tokens":865,"name":"70.jsnp"}
{"score":"98","reasoning":"Highly readable Java constructor with clear Javadoc comment explaining purpose. Uses this() delegation to fuller constructor with well-named constants and inline comments clarifying boolean flags (properties, save, print, zoom, tooltips). Concise, follows best practices, easy to comprehend intent and behavior.","tokens":870,"name":"4.jsnp"}
{"score":"92","reasoning":"Code is well-structured with descriptive variable names showing parent-child hierarchy. Follows standard Hibernate test data setup: create and save children first, flush, then associate to parents and commit. Logical flow is easy to follow despite interleaved save order, likely for testing purposes. No comments but self-explanatory. High readability for experienced developers.","tokens":1361,"name":"76.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test for Hibernate EJB3NamingStrategy. Clear purpose: verifies table naming per JPA spec. Proper try-catch-finally for resource management. Assertions include detailed messages. Log statements aid debugging. Drawbacks: legacy Iterator usage, magic strings like A_ADDRESS, simplistic foundIt flag. Readable for Java/Hibernate experts, minor refactoring could enhance.","tokens":1238,"name":"137.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test method with descriptive name and inline comments explaining key behaviors like aggressive-release and batching. Clear flow: setup, action, assertion via try-catch-fail, teardown. Variable names are intuitive. Minor deductions for Hibernate-specific jargon and dialect workaround reducing general accessibility.","tokens":1054,"name":"75.jsnp"}
{"score":"88","reasoning":"Code is well-structured, follows Java conventions, and has clear logical flow: appends collection select fragment, handles many-to-many case, then calls super. Meaningful method names aid comprehension. Minor deductions for long chained calls like getCollectionReferenceAliases().getCollectionTableAlias() and dense framework-specific terms assuming Hibernate knowledge.","tokens":1069,"name":"182.jsnp"}
{"score":"72","reasoning":"Code follows standard test structure with setup, multiple HQL queries testing functions like lower, concat, sum, abs, and cleanup. Readability is good for Hibernate experts due to concise queries and session management. However, repetitive results assignments without assertions reduce comprehension of intent, lacks comments explaining each test case, and minor indentation issues make it less ideal for broader audiences.","tokens":1476,"name":"83.jsnp"}
{"score":"92","reasoning":"Code is concise and clear, with descriptive variable names like preCollectionRecreateListener that self-document purpose. Logical sequence of initialization followed by grouped registry registrations enhances readability. Minor repetition in setListeners calls is straightforward. Assumes Hibernate familiarity for casting, but overall highly comprehensible for target audience.","tokens":1011,"name":"139.jsnp"}
{"score":"45","reasoning":"The code follows a clear sequence of nulling references, clearing collections, merging entities, and deleting them in a Hibernate session, showing good logical structure for cleanup. However, cryptic single-letter variable names like b c d obscure entity relationships and purpose, lacking comments or context makes it hard to comprehend without domain knowledge.","tokens":1130,"name":"200.jsnp"}
{"score":"92","reasoning":"The code is a concise JUnit test method testing listener invocation during failures. It uses standard JUnitCore, RunListener with anonymous inner class, and clear assertions. Descriptive name aids understanding. Slightly verbose exception handling and undefined context like fMax and TwoTests deduct minor points, but highly readable for Java developers familiar with JUnit.","tokens":1062,"name":"124.jsnp"}
{"score":"65","reasoning":"Code correctly converts long to big-endian byte array but uses unnecessarily complex shift patterns like left shift followed by right shift 56 instead of direct right shifts e.g. \u003e\u003e48 for bytes1. This obscures intent. Repetitive unrolled assignments lack loop abstraction increasing verbosity. Javadoc is clear method name good but no inline comments. Readable for experts moderate for others.","tokens":2162,"name":"113.jsnp"}
{"score":"82","reasoning":"Method has clear intent: excludes EMBEDDABLE_SUPERCLASS NONE and EMBEDDABLE types with optional logging then validates ENTITY strictly. Enums improve clarity. Inline comments explain conditions well. Nested if and long exception message slightly impact readability but overall easy to comprehend for Java developers.","tokens":1251,"name":"29.jsnp"}
{"score":"85","reasoning":"Well-structured JUnit test with detailed JPA spec comment providing context. Clear variable names and standard Hibernate session/transaction pattern. Assertion verifies complex bidirectional relationship chain effectively. Long method name and chained getter in assert slightly reduce readability but are purposeful. Suitable for experienced Java/Hibernate developers.","tokens":1342,"name":"134.jsnp"}
{"score":"82","reasoning":"The constructor initializes three lists using a consistent ternary operator pattern for null-safe defensive copying from readerCollector getters, defaulting to empty lists. Code is clear and idiomatic Java, with descriptive names aiding comprehension. Minor issues: repetitive structure could benefit from a helper method, and long lines may wrap poorly. Suitable for experienced developers.","tokens":1057,"name":"196.jsnp"}
{"score":"98","reasoning":"Well-documented with comprehensive Javadoc explaining purpose, parameters, return, and exceptions. Clear, concise logic using simple if-else chain with descriptive conditions and method calls. TODO note adds context without hindering comprehension. Professional naming and structure make it highly readable and easy to follow.","tokens":917,"name":"32.jsnp"}
{"score":"92","reasoning":"Well-structured JUnit test with descriptive method name, clear property configuration for entity and collection regions, logical sequence of factory creation, region building, and assertions. Proper resource management via try-finally. Assertions are precise and self-explanatory. Minor deductions for terse variable name p and reliance on Infinispan/Hibernate domain knowledge, but overall highly readable and comprehensible.","tokens":1294,"name":"130.jsnp"}
{"score":"85","reasoning":"Clear JUnit test method testing JPA query cache hint mappings to Hibernate cache modes. Logical sequence of set hint and assert steps. Repetitive pattern could benefit from refactoring into a loop or helper for conciseness. Casting to internal Hibernate classes assumes familiarity. No comments on enum mappings. Highly readable for JPA/Hibernate experts.","tokens":1426,"name":"162.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear variable names like orderRoot and customerSubquery, logical step-by-step construction of JPA CriteriaQuery, and a precise comment on the correlated subquery. Standard patterns enhance comprehension for Java JPA users, minimal complexity.","tokens":1099,"name":"163.jsnp"}
{"score":"72","reasoning":"The code is logically structured with a clear purpose explained in Javadoc, handling direct lookup and interface matching with caching. However, it uses outdated Enumeration instead of modern iterators, has informal comments like Now lets search, minor doc typos noone exist, and inconsistent spacing. Comprehensible for Java experts but less so for beginners due to old style.","tokens":1130,"name":"44.jsnp"}
{"score":"95","reasoning":"Well-structured JUnit test method with clear setup insert query assert and teardown phases. Self-explanatory names like human nickName and logical flow. Standard Hibernate session usage. Easy to comprehend for Java developers familiar with testing and ORM. Minor repetition in session open close but idiomatic for tests.","tokens":1021,"name":"77.jsnp"}
{"score":"42","reasoning":"Deeply nested if-else chains obscure control flow. Heavy dependence on external Model facade and helpers requires framework knowledge. Unclear logic in null handling and visibility check. TODO comment signals unresolved issues. Tacked-on layer iteration seems unrelated and inefficient. Decent variable names but overall hard to comprehend quickly.","tokens":1276,"name":"155.jsnp"}
{"score":"82","reasoning":"Code is logically clear with a simple if-check and sequential set population using addAll. Repetitive Model.getFacade calls make it verbose and slightly harder to scan. Lacks generics typical in modern Java, and returns null instead of empty set. Readable for those familiar with the modeling facade API.","tokens":1058,"name":"123.jsnp"}
{"score":"92","reasoning":"Code is highly readable: clear method purpose, well-commented switch cases with specific PostgreSQL error codes, consistent use of extractUsingTemplate pattern, and graceful exception handling. Easy to follow logic. Minor issues: magic numbers could be named constants, TODO comment indicates incompleteness.","tokens":1021,"name":"22.jsnp"}
{"score":"82","reasoning":"Code is short, concise, and follows good Java conventions with proper indentation and line breaks for readability. Single responsibility makes it easy to comprehend. However, verbose class names like FetchStyleLoadPlanBuildingAssociationVisitationStrategy hinder quick understanding without Hibernate domain knowledge.","tokens":1019,"name":"143.jsnp"}
{"score":"92","reasoning":"Well-structured Java method with clear Javadoc outlining three steps. Descriptive variable names like persistenceContext, collectionEntry. Logical flow: clear maps, loop over entries safely with concurrentEntries, handle dereferenced vs loaded collections. Commented-out iter.remove explained inline. Minor density in loop but easy to follow for experienced Java devs. High readability.","tokens":1179,"name":"66.jsnp"}
{"score":"82","reasoning":"The code is a well-structured Hibernate JUnit test with clear session management and dialect-specific SQL query handling for TimesTen. Standard patterns aid comprehension for experts. Minor deductions for long unwrapped SQL lines, magic strings like TA and from A, and lack of explanatory comments. Overall readable and logical.","tokens":1386,"name":"71.jsnp"}
{"score":"88","reasoning":"Well-structured Java method with clear variable names like fieldAccessMap and propertyAccessMap. Helpful comments reference JPA 2 spec for context. Early continue improves flow, if-else logic is straightforward, debug logs are descriptive. Minor duplication in two similar loops slightly reduces score, but overall highly readable and comprehensible for experienced developers.","tokens":2016,"name":"27.jsnp"}
{"score":"88","reasoning":"The code is a concise JUnit test with clear intent: verify transaction states before and after begin, then open a session with autoJoinTransactions disabled and invoke getFlushMode. Structure is logical and assertions are straightforward. Minor deduction for repeated verbose TransactionManager calls which could be refactored to a local variable for improved readability.","tokens":1057,"name":"128.jsnp"}
{"score":"92","reasoning":"Concise and well-structured Java override using anonymous inner class for threaded test execution. Clear try-finally ensures cleanup via runFinished. Explicit this reference is good practice. Commented super call provides essential context on VA/Java limitation without major disruption, aiding comprehension for experienced developers.","tokens":942,"name":"1.jsnp"}
{"score":"92","reasoning":"Well-documented Javadoc explains purpose parameters and return value clearly. Logical flow from checks to building singular or plural attributes. Descriptive names like ownerType property attributeContext. Generics handled properly despite unchecked suppression. Trace logging enhances traceability. Minor complexity in casting and domain-specific types but overall highly readable for experienced Java developers.","tokens":1221,"name":"84.jsnp"}
{"score":"72","reasoning":"Code has clear intent with structured if-else blocks handling naming strategy application. Variable names are descriptive. However, nested conditions reduce readability, redundant normalization calls in one branch, and chained assignments make it slightly harder to follow. Comment adds minor clarity but logic could be refactored for better flow.","tokens":1064,"name":"30.jsnp"}
{"score":"98","reasoning":"Highly readable Java serialization method with clear Javadoc explaining purpose and exceptions. Straightforward structure: default write followed by consistent utility calls for shapes, paints, and strokes. Repetitive pattern aids comprehension without redundancy issues. Professional and easy to understand for experienced developers.","tokens":931,"name":"38.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit-style test with clear variable names like c2 and info, descriptive method name, and explicit exception expectation via fail and catch. Proper use of try-catch-finally for resource management. Minor deductions for nested try blocks and domain-specific Hibernate assumptions requiring context knowledge.","tokens":974,"name":"129.jsnp"}
{"score":"92","reasoning":"Simple debug method with clear print labels for SQL and suffixes comparison. Straightforward logic using println and StringHelper.join. Easy to comprehend purpose. Minor deductions for long suffix line and multiple println calls which could be optimized with StringBuilder.","tokens":974,"name":"144.jsnp"}
{"score":"98","reasoning":"The code is highly readable with clear Javadoc documentation explaining purpose and parameters. Follows standard Java equals pattern: identity check, instanceof, key comparisons, then nested loops for value equality with proper null handling. Concise, logical flow, good indentation, and intuitive variable names enhance comprehension for any Java developer.","tokens":1113,"name":"40.jsnp"}
{"score":"88","reasoning":"Well-structured JUnit test with sequential actions and assertions clearly verifying transaction states before and after operations. Logical flow is straightforward and easy to follow for those familiar with Hibernate JTA. Minor deductions for verbose casts like SessionImplementor and repetitive assertions, plus reliance on internal APIs.","tokens":1202,"name":"127.jsnp"}
{"score":"92","reasoning":"Code is highly readable: clear Javadoc, simple if-null initialization, consistent naming, straightforward logic. Purpose instantly clear - populates static Vector with KnowledgeTypeNodes. Minor deductions for legacy Vector use over List/ArrayList and repetitive addElement calls which could use array init for brevity. Overall very easy to comprehend.","tokens":1025,"name":"45.jsnp"}
{"score":"78","reasoning":"Code has clear sequential flow handling mouse events, tooltips, and manager calls. Intent is comprehensible with descriptive method names. Minor issues: repeated getJComponent calls could be optimized, nested ifs slightly increase complexity, commented lines add minor confusion without context, and globals reduce self-containment. Overall readable for Java developers familiar with GUI patterns.","tokens":1018,"name":"122.jsnp"}
{"score":"68","reasoning":"The code is functional for parsing JUnit command-line options, handling --filter and -- terminators clearly. However, readability suffers from side effects on external variables like filter and parserErrors, manual index manipulation with ++i, nested ifs, and undefined helpers like copyArray and createSuiteDescription. Assumes context knowledge, making it moderately comprehensible for experienced Java developers but improvable with extracted methods and parameter passing.","tokens":1257,"name":"15.jsnp"}
{"score":"68","reasoning":"Compact ANTLR-generated Java lexer method for matching a single hex digit. Switch statement clearly handles 0-9, A-F, a-f ranges with matchRange calls, throwing exception on invalid char. Logic is straightforward and correct. However, cryptic variable names like _ttype, _token, dense formatting, and lack of comments reduce readability for non-ANTLR experts. Assumes familiarity with ANTLR conventions like LA(1) and text buffer.","tokens":1353,"name":"117.jsnp"}
{"score":"78","reasoning":"Code follows standard Java conventions with clear method structure and logical if-else flow for handling implicit index columns. Descriptive names like indexColumn and valueHolder aid readability. However, dense chaining of method calls, domain-specific Hibernate classes (e.g., PropertyHolderBuilder, SimpleValueBinder), magic strings, and assumptions of internal knowledge make it less accessible to non-experts. Minor variable reuse (list to coll) slightly detracts.","tokens":1288,"name":"109.jsnp"}
{"score":"65","reasoning":"Code has clear linear flow: checks if port is ClassifierRole, gets association ends, iterates to collect associations. However, uses outdated Vector with addElement, poor variable names (cr, aer, iter), and relies on domain-specific Model facade methods without explanation. Inline comment highlights wastefulness but does not improve. Moderate readability for framework experts, lower for others.","tokens":1051,"name":"120.jsnp"}
{"score":"72","reasoning":"Code is structured logically with clear iteration and conditional processing of values. However, it uses outdated Iterator instead of for-each loop, relies on undocumented Model facade and magic strings, and assumes knowledge of instance fields like _scratchBindings and _strBuf, reducing general readability.","tokens":1055,"name":"8.jsnp"}
{"score":"88","reasoning":"Method name clearly indicates purpose. Logic is straightforward: copies annotation values, flags presence of schema and catalog, returns original if both defined, else adds missing defaults from provided object using utilities. Well-indented, descriptive variables, no complex constructs. Minor improvements like generics diamond possible, but overall very readable and easy to comprehend.","tokens":1150,"name":"195.jsnp"}
{"score":"78","reasoning":"Method structure is clear with try-catch for error handling and validation check. Purpose to get SQL type code is straightforward. Issues: repeated getSqlTypeCode call inefficient, typo in exception message SQLType codes does not match, undeclared name variable assumes class field, relies on external getters like getValue getType getTypeIndex. Readable for those familiar with Hibernate context.","tokens":1137,"name":"37.jsnp"}
{"score":"92","reasoning":"Well-structured method with clear if-else chain handling different Test subtypes using instanceof and casting, common in Java. Descriptive variable names like tc and ts. Logical recursion for suites and decorators. Minimal comment aids default case. Easy to comprehend for Java developers familiar with JUnit, though instanceof reduces modernity slightly.","tokens":1055,"name":"54.jsnp"}
{"score":"82","reasoning":"Well-structured JUnit test for Hibernate natural ID caching behavior. Clear method name and logical flow: setup, insert/update, flush/commit, reload, assert cache hit. Comments explain key actions. Minor deductions for non-descriptive variable name it, typos like excpect instead of expect, and placeholder entity Another. Easy to comprehend for Java/Hibernate experts.","tokens":1164,"name":"179.jsnp"}
{"score":"72","reasoning":"The code is a clear JUnit test method verifying revision counts for entities using repetitive assertEquals calls with Arrays.asList. Structure is consistent and intent is straightforward for those familiar with the auditing framework. However, excessively long class names like ChildIndexedListJoinColumnBidirectionalRefIngEntity hinder readability and comprehension. Assumes IDs like ing1_id are defined elsewhere. Formatting is adequate but verbose.","tokens":1311,"name":"185.jsnp"}
{"score":"68","reasoning":"Code intent is clear: parse file into sections using getSectId. Structure is logical with inSection flag. However, non-idiomatic while loop risks issues, string concat in loop inefficient for large files, last section not stored, terse vars like f fr mAry, no try-with-resources, assumes undefined LINE_SEPARATOR LOG mAry getSectId. Readable for experienced devs but needs improvements.","tokens":1436,"name":"48.jsnp"}
{"score":"85","reasoning":"Clear if-else chain handles specific collection properties with consistent checks, exceptions, and returns using constants. Logic is straightforward and domain-specific. Minor repetition in column name retrieval and length checks makes it slightly verbose but still easy to comprehend for experienced developers.","tokens":1311,"name":"108.jsnp"}
{"score":"88","reasoning":"Clear JUnit test for HiLo ID generator with structured sections using long comment lines for separation. Descriptive comments explain initial state and historical behavior. Repetitive generate-assert blocks effectively demonstrate sequential values from 1 to 5 matching sequence. Minor deductions for repeated code without loop and type casts like SessionImpl and Long, but highly readable and easy to follow.","tokens":1330,"name":"17.jsnp"}
{"score":"70","reasoning":"Code structure is clear, uses final locals properly, SwingUtilities.invokeLater for thread safety, and comment explains concurrent region logic. However, magic strings with \u003d\u003d comparison (should use equals), TODO shows uncertainty, unchecked Collection cast, and assumes non-empty after check slightly reduce readability and reliability.","tokens":1396,"name":"154.jsnp"}
{"score":"92","reasoning":"Code employs fluent StringBuilder chaining with line breaks for each append, improving readability. Explicit this. qualifiers and getExecutionAvgTime call add clarity. Logical field order. Output lacks spaces after commas but does not hinder code comprehension. Concise and idiomatic Java.","tokens":1249,"name":"63.jsnp"}
{"score":"82","reasoning":"Well-structured method with clear loops handling bidirectional references and fetches separately. Descriptive names like bidirectionalEntityReference and entityReferenceInitializer improve readability. Single comment helps. Recursive calls and instanceof checks are standard but assume domain knowledge of ORM fetches. Parameter usage suggests polymorphism adding slight complexity. Clean indentation and consistent style make it comprehensible for experienced Java developers.","tokens":1401,"name":"197.jsnp"}
