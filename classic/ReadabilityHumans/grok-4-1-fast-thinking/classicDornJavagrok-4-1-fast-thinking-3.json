{"score":"45","reasoning":"The code employs an outdated while-switch-label idiom simulating goto statements, which significantly reduces readability and is not idiomatic modern Java. The polling loop with manual timeout using seconds counter and try-catch is verbose and prone to confusion. Selenium interactions are straightforward, but the overall structure feels legacy and hard to comprehend quickly.","tokens":926,"name":"102.jsnp"}
{"score":"82","reasoning":"Well-structured Java class with standard package imports and javadoc. Clear use of constants for paths and files. Proper synchronization via AEMonitor. Method logic is straightforward for checking failed installs. Good variable naming. Minor deductions for informal comment style and abrupt incomplete snippet end affecting full comprehension.","tokens":1117,"name":"151.jsnp"}
{"score":"92","reasoning":"Clean Java code snippet with straightforward methods for deleting and retrieving PollsQuestion entities. Delegates clearly to persistence layer using descriptive names like findByGroupId and countByGroupId. Standard exception handling and overloading. Easy to comprehend for Java developers, though snippet starts abruptly mid-method. Minor formatting quirks do not hinder readability.","tokens":1012,"name":"153.jsnp"}
{"score":"88","reasoning":"Well-structured Java test methods using JUnit and Liferay persistence APIs. Clear method names, logical assertions, and standard patterns enhance readability. Descriptive variable usage and proper exception handling. Slight deductions for framework-specific dependencies like DynamicQuery and external helpers such as nextLong, requiring some domain knowledge for full comprehension.","tokens":1169,"name":"204.jsnp"}
{"score":"92","reasoning":"The code snippet is a clean Java test class with standard imports, proper Javadoc author tag, and a straightforward method extending BaseTestCase. It follows Selenium conventions, uses clear naming, and has good formatting. Easy to read and understand, though incomplete.","tokens":897,"name":"191.jsnp"}
{"score":"98","reasoning":"Standard Java getter and setter methods for dependency injection. Clear Javadoc comments describe purpose and parameters accurately. Consistent naming conventions and simple structure make it highly readable and easy to comprehend. Repetitive pattern aids quick understanding. Minor deduction for leading comment fragment.","tokens":1026,"name":"136.jsnp"}
{"score":"75","reasoning":"Short Java code snippet featuring a constructor with commented assignment making it empty and a clear getIcon method using plugin resources. Formatting is good with proper indentation, but unused parameter and commented line reduce full comprehension slightly.","tokens":898,"name":"181.jsnp"}
{"score":"65","reasoning":"The code snippet is concise and shows a clear intent to wait for a sections visibility using Selenium with a timeout fail. However, readability is hindered by poor indentation, an empty catch block that swallows exceptions without logging, and a generic XPath selector that lacks specificity. These issues make it less robust and harder to debug, reducing overall comprehension ease.","tokens":884,"name":"192.jsnp"}
{"score":"75","reasoning":"Code overrides Swing methods for listener management and custom sizing. Structure is logical and concise, with proper null checks and super calls. However, inconsistent indentation, abrupt start with undefined variables like _app and _listener, and missing context lower readability for newcomers.","tokens":1044,"name":"170.jsnp"}
{"score":"82","reasoning":"The code features clear method names, consistent structure, and straightforward logic for cluster link checks and logging. Repetitive null/enabled checks across methods reduce readability slightly and suggest refactoring into a helper. Assumed static fields like _clusterLink and _log are intuitive in context. Overall easy to comprehend despite minor duplication.","tokens":1144,"name":"116.jsnp"}
{"score":"82","reasoning":"Well-structured Java code with descriptive variable names like tablesSQL and indexesSQL, proper try-catch handling, and clear method flow for DB updates and upgrades. Logging is used effectively. Minor deductions for Liferay-specific dependencies requiring framework knowledge, abrupt snippet start, and odd duplicate log in catch e, e.","tokens":1232,"name":"103.jsnp"}
{"score":"75","reasoning":"The code defines two Java interface methods: setGadgetKey and getServiceName. It is generally readable with clear signatures and one Javadoc comment explaining getServiceName. Strengths include standard interface syntax and annotation use. Issues: stray closing comment marker at start, typo in comment (o auth should be OAuth), missing Javadoc for setGadgetKey, and inconsistent indentation. Still easy to understand overall purpose.","tokens":967,"name":"168.jsnp"}
{"score":"98","reasoning":"The snippet contains only clean, well-formatted Java import statements from Liferay framework and standard libraries. They are consistently structured, sorted logically, and contain no syntax errors or redundancies, ensuring maximum readability and comprehension for any Java developer.","tokens":988,"name":"208.jsnp"}
{"score":"72","reasoning":"The code follows standard Selenium test structure with clear class and method names, package imports, and Javadoc. It uses a polling loop to wait for an element, which is common but clunky with Thread.sleep and empty catch block, indicating suboptimal practices. Readability is good for Selenium users but less intuitive for novices due to hardcoded timeout and busy-waiting. Incomplete snippet slightly impacts full comprehension.","tokens":1096,"name":"212.jsnp"}
{"score":"82","reasoning":"Code is mostly readable with clear logic flow using early returns and descriptive variable names like liveGroup and liveLayoutSet. Proper exception handling in try-catch blocks. Minor issues: unnecessary null initialization for liveLayoutSet since always assigned, abrupt snippet end, and context-dependent calls like getGroup assume external knowledge. Overall easy to comprehend for experienced Java developers.","tokens":1193,"name":"101.jsnp"}
{"score":"92","reasoning":"The code snippet features three highly similar static methods that wrap PortalServiceUtil calls in try-catch blocks, logging exceptions and rethrowing as RemoteException. The consistent, boilerplate pattern is straightforward and easy to comprehend instantly, despite repetition that could be refactored. Minor redundancy in log.error(e, e) but no complexity or obfuscation.","tokens":1072,"name":"140.jsnp"}
{"score":"65","reasoning":"Code snippet appears incomplete, starting mid-statement with unbalanced parentheses. Indentation is inconsistent and line breaks awkward, making it harder to parse. Logic is straightforward: checks for context key and safely converts string to long for setting class PK using constants and GetterUtil. Familiarity with framework helps, but overall readability suffers from fragmentation and formatting.","tokens":1038,"name":"133.jsnp"}
{"score":"45","reasoning":"Code shows repetitive busy-wait loops with Thread.sleep and empty catch blocks swallowing exceptions, which hinders debugging. Uses outdated Selenium RC API with hardcoded locators and magic numbers. Intent is clear for logout flow but lacks modularity, comments, and best practices, reducing maintainability and readability.","tokens":1014,"name":"146.jsnp"}
{"score":"95","reasoning":"The code features straightforward getter methods for class fields and properly overridden hashCode and equals methods with Javadoc comments. Consistent naming with underscore prefixes, clear structure, and standard Java conventions make it highly readable and easy to comprehend. Minor note on hashCode not fully mirroring equals fields, but does not hinder understanding.","tokens":1251,"name":"150.jsnp"}
{"score":"42","reasoning":"Repetitive Selenium commands for clicks waits and module loads make it verbose. Long XPath selectors are brittle and hard to parse. Variable names like suborganization2Present lack clarity. Uses labels and continue for flow control which is confusing. No comments or abstraction functions. Flow is traceable but maintenance is difficult.","tokens":1447,"name":"152.jsnp"}
{"score":"90","reasoning":"Well-structured Java class with clear imports from Squirrel SQL framework. Uses standard patterns like serialVersionUID, StringManager for i18n, and inner interface for localized strings. Naming is consistent and professional. Constructor is simple. Easy to comprehend purpose as a refactoring action setup. Slight deduction for abrupt end of snippet.","tokens":1240,"name":"172.jsnp"}
{"score":"65","reasoning":"Code has clear nested if-else structure and consistent variable naming like posBetter and negBetter. However, undefined BETTER_THAN macro confuses readers, magic numbers like 0.2f and 0.4f lack explanation, and many undeclared variables assume prior context. No comments reduce standalone comprehension, but logic flow is followable for domain experts.","tokens":1334,"name":"112.jsnp"}
{"score":"28","reasoning":"Code uses outdated Selenium RC API with magic locators like _15_rowIds and hardcoded XPaths, making it hard to follow without context. Poor variable names like webContent1Present lack descriptiveness. Repeated calls to loadRequiredJavaScriptModules and waitForPageToLoad without abstraction. Labels and continue statements imply loop but snippet is incomplete, reducing clarity. No comments exacerbate issues.","tokens":1211,"name":"193.jsnp"}
{"score":"78","reasoning":"Code follows standard Java class structure with clear constructors and methods. getColor logic is straightforward with caching. Positives include Javadoc and simple flow. Deductions for raw Map types lacking generics, static shared cache potentially confusing, swallowed exceptions without logging, commented-out code, and minor indentation inconsistencies.","tokens":1235,"name":"166.jsnp"}
{"score":"82","reasoning":"Code is structured with clear constructors, setters, and getters. Javadoc is mostly descriptive but misses param documentation for aTableName in main constructor. Naming uses outdated a-prefix for params. Fields are properly set. Indentation and logic are straightforward, aiding comprehension despite minor doc gaps.","tokens":1451,"name":"221.jsnp"}
{"score":"92","reasoning":"Code follows standard Liferay portlet conventions with clear variable names and simple logic for fetching rules and groups then setting request attributes. Straightforward and easy to follow despite being a snippet. Minor issues: starts mid-statement lacks comments and error handling but does not hinder comprehension for experienced Java developers.","tokens":1152,"name":"186.jsnp"}
{"score":"85","reasoning":"Well-structured Java code with clear method names, defensive null checks, and appropriate exceptions. Overloaded setEvent method enhances usability. Logic is straightforward and easy to follow for developers familiar with Portlet API. Minor issues: incomplete snippet start, long parameter list in updatePortletMode call, and assumes domain knowledge.","tokens":1157,"name":"131.jsnp"}
{"score":"62","reasoning":"The code is a linear Selenium automation script with sequential clicks waits and checks making it somewhat easy to follow for familiar users. However it uses deprecated selenium methods brittle XPath locators magic numbers like 30000 and 90 undefined variables like label and is abruptly incomplete hurting comprehension and maintainability.","tokens":1082,"name":"157.jsnp"}
{"score":"72","reasoning":"Code follows logical flow for building plugin config model adding parameters groups and listeners. Meaningful method and most var names aid comprehension. Comments clarify intent. However short vars like lp dm am and magic strings hurt readability. Old Java style lacks generics. Snippet starts abruptly as fragment reducing context.","tokens":1542,"name":"106.jsnp"}
{"score":"95","reasoning":"Code is concise, follows Java conventions with clear naming and structure. Constructor initializes properly via super call. Execute method is simple, saving old value before setting new one. Easy to understand intent as a command pattern implementation. Slight deduction for missing field declarations and comments in snippet.","tokens":841,"name":"104.jsnp"}
{"score":"80","reasoning":"Code is well-indented with clear variable names and logical flow: extract parameter, get fields map, update file entry. Multi-line calls aid readability. However, the updateFileEntry method has 13 parameters, creating a long list that hinders comprehension and maintenance. Suitable for framework experts but could improve with a builder pattern or DTO.","tokens":1048,"name":"135.jsnp"}
{"score":"92","reasoning":"The code uses a clear, repetitive pattern of getter-setter calls, each on a separate line, making field assignments easy to scan and understand. The resetOriginalValues and return are logical conclusions. compareTo is simple, comparing names first and returning zero if equal. Boilerplate but explicit and readable, no complex logic.","tokens":1048,"name":"183.jsnp"}
{"score":"65","reasoning":"Method signatures are clear with descriptive names and Javadoc tags for params and returns. However, inconsistent indentation with mixed tabs and spaces, incomplete or empty Javadoc bodies, inline comment not in standard Javadoc format, and minor cutoff in first method reduce readability and ease of comprehension.","tokens":1100,"name":"201.jsnp"}
{"score":"78","reasoning":"Well-structured Java Selenium test case with clear package class and method names following conventions. Javadoc comment present. Logic for page load and element wait is straightforward using a timeout loop. Minor deduction for verbose busy-wait with Thread.sleep instead of more elegant WebDriverWait. Readable for QA engineers familiar with Selenium.","tokens":984,"name":"209.jsnp"}
{"score":"42","reasoning":"Code uses legacy Selenium RC style with verbose RuntimeVariables.replace calls, brittle XPath locators, and inefficient polling loop via Thread.sleep with magic numbers like 90 and 1000. Unusual case labels suggest goto-like control flow, reducing clarity. Assertions are clear, but overall lacks modern WebDriverWaits and readability suffers from long lines and hardcoded values.","tokens":1274,"name":"107.jsnp"}
{"score":"92","reasoning":"The code is a clean Java service implementation extending a base class, with clear method names like addEmailAddress, deleteEmailAddress, and getEmailAddress. It consistently performs permission checks before operations, follows enterprise patterns, and uses standard exception handling. Readability is high for Java developers familiar with Liferay, though framework dependencies and lack of inline comments slightly reduce general accessibility.","tokens":1253,"name":"175.jsnp"}
{"score":"65","reasoning":"The code is a straightforward Selenium test script for UI automation in a document library. It follows a linear sequence of clicks waits and assertions making the flow easy to follow. However repetitive patterns like waitForPageToLoad and loadRequiredJavaScriptModules reduce conciseness. XPath selectors are verbose and brittle hindering quick comprehension. The polling loop is clear but uses manual timeout and exception swallowing which feels outdated. Suitable for familiar developers but lacks abstraction and comments.","tokens":1340,"name":"198.jsnp"}
{"score":"25","reasoning":"The snippet has low readability: multiple unexplained closing braces suggest incompleteness, empty catch block ignores exceptions badly, hardcoded Thread.sleep delays execution unreliably, brittle XPath in selenium.clickAt lacks comments or variables, overall lacks context and best practices making comprehension difficult.","tokens":918,"name":"174.jsnp"}
{"score":"72","reasoning":"Code is generally readable with clear intent in conditionally populating SchemaLoadInfo based on schema details. Variable names are descriptive. Issues include inconsistent indentation starting with stray continue block, magic constants like SCHEMA_LOADING_ID_DONT_LOAD lacking explanation, redundant else for loadProcedures false, and repetitive addStringArrays calls. Comprehensible for experienced Java devs but could be refactored for better DRY principle and clarity.","tokens":1113,"name":"187.jsnp"}
{"score":"65","reasoning":"Code follows standard Selenium test structure for Liferay with clear imports and method naming. However, repetitive polling loops with magic numbers like 90 seconds and hardcoded Thread.sleep calls reduce readability. Lacks inline comments explaining actions and is abruptly incomplete, making comprehension moderate for familiar developers.","tokens":1227,"name":"145.jsnp"}
{"score":"92","reasoning":"The code is a simple JUnit test suite class with clear purpose from the name. It follows standard static suite method pattern, uses descriptive variable and class names, has proper indentation and author javadoc. Highly readable for Java developers familiar with testing. Deduction for incompleteness as method and class lack closing braces.","tokens":993,"name":"176.jsnp"}
{"score":"85","reasoning":"The snippet features a well-structured Javadoc header with title, description, copyright, author info, and LGPL license details using proper HTML tags. Two import statements are clear and standard. Minor issues include a copy-paste error Foobar instead of sqsc-isqlj and the snippet being incomplete with no class body, but overall highly readable and easy to comprehend.","tokens":1229,"name":"190.jsnp"}
{"score":"92","reasoning":"The code snippet defines a JUnit test suite class with a static suite method that adds four test classes clearly. It starts with a javadoc author comment. Structure is simple and standard, making it highly readable and easy to comprehend despite being incomplete without closing braces.","tokens":942,"name":"199.jsnp"}
{"score":"100","reasoning":"The code defines a simple Java class with two public static final int constants using clear, descriptive names like ADD_KB_ARTICLE and ADD_KB_COMMENT. It includes standard Javadoc author tags. Structure is minimal, follows Java conventions perfectly, with no redundancy or complexity, making it exceptionally readable and comprehensible even for beginners.","tokens":816,"name":"189.jsnp"}
{"score":"68","reasoning":"Code follows a clear linear flow for UI automation using Selenium RC style commands. Actions like clicks typing and waits are explicit and easy to follow. Repetition of waitForPageToLoad and loadRequiredJavaScriptModules reduces readability. XPath selectors are brittle. Polling loop with try-catch is functional but inefficient and not idiomatic lacking explicit waits or comments.","tokens":1273,"name":"167.jsnp"}
{"score":"92","reasoning":"Code is concise, well-structured JUnit test suite extending BaseTestSuite. Clear class and method names, proper static suite method adding other suites. Includes author Javadoc. Highly readable and easy to comprehend despite being an incomplete snippet.","tokens":901,"name":"207.jsnp"}
{"score":"65","reasoning":"Code intent is clear: modifies plist files using regex to insert array values if absent. Methods are well-named and separated. Javadoc helps. However, poor formatting with inconsistent indentation and spacing reduces readability. Snippet is incomplete, starts mid-method, abrupt end. Commented debug lines distract. Regex usage comprehensible but fragile. Overall moderate ease of understanding for experienced Java devs.","tokens":1164,"name":"177.jsnp"}
{"score":"25","reasoning":"The code snippet exhibits poor readability due to inconsistent indentation, a stray method call getLeecherCount without context or declaration, and an awkwardly line-split public method declaration. The Javadoc is clear and helpful, but the overall formatting and incompleteness make it hard to comprehend quickly.","tokens":1047,"name":"126.jsnp"}
{"score":"92","reasoning":"The code is a clean well-structured Java test method in a JUnit-style framework with descriptive variable names clear assertions and logical flow testing monthly recurrence by day. Imports and helper methods like getRecurrence getCalendar and assertRecurrenceEquals are standard for test cases. Minor deduction for undefined constants like FRIDAY FEBRUARY and magic numbers requiring context from superclass.","tokens":1188,"name":"159.jsnp"}
{"score":"62","reasoning":"Code shows proper try-catch-finally for cleanup but has empty catch blocks swallowing exceptions, hindering debugging. Nested ifs and Liferay-specific classes like LiferayFileVersion assume domain knowledge. Underscore-prefixed private methods are consistent yet non-standard. Snippet starts mid-condition, reducing context. Readable for experienced Java devs but not intuitive for others.","tokens":1224,"name":"180.jsnp"}
{"score":"95","reasoning":"The code consists of a clear, linear sequence of setter calls on a layoutRevision object, copying values from an old revision and setting new ones. Variable names are descriptive and intuitive. Consistent indentation, minimal conditional logic, and no complex computations enhance readability and comprehension. Minor deduction for long lines and assumed context of variables.","tokens":1039,"name":"148.jsnp"}
{"score":"70","reasoning":"Code is a partial Java bean for Deploy with array fields for archiveFiles and options. Verbose fully qualified type names reduce readability. Missing archiveFiles field declaration and setOptions method make it incomplete. Standard getters/setters including indexed accessors are clear and consistent. Structure is straightforward but lacks imports and polish.","tokens":1248,"name":"188.jsnp"}
{"score":"68","reasoning":"Code performs clear Selenium actions: click link, wait for load, load JS, check visibility, set label. Intent is easy to follow for Selenium users. However, awkward multi-line arguments in clickAt and isVisible hurt readability. Magic numbers like 30000 and label\u003d3 lack explanation. Unicode escape is minor issue. Overall decent but formatting and context could improve.","tokens":992,"name":"149.jsnp"}
{"score":"78","reasoning":"The code follows standard Java ORM patterns with clear try-catch-finally structure for session management and query execution. Flow is logical: build SQL, query list with pagination, sort if needed, cache results. However, it relies on undefined external variables and framework utilities like QueryUtil, reducing standalone readability. No comments and generic exception handling slightly hinder comprehension. Indentation is mostly consistent but snippet feels incomplete.","tokens":1305,"name":"202.jsnp"}
{"score":"35","reasoning":"Code snippet shows a polling loop waiting for a UI element using brittle hardcoded XPath selector which is long and fragile. Magic numbers like 90 seconds, 1000ms sleep, li[6] reduce readability. Lacks variables for selectors, comments, or abstraction. Abrupt start after replace call and ends mid-switch case. Comprehensible for Selenium experts but poor overall ease of understanding.","tokens":1168,"name":"215.jsnp"}
{"score":"72","reasoning":"Code presents JUnit tests for table model methods with clear structure, loops, assertions, and exception handling. Purpose is straightforward. However, inconsistent indentation, excessive leading spaces, and abrupt start with uncontextualized return statements and braces hinder readability and flow.","tokens":1119,"name":"178.jsnp"}
{"score":"88","reasoning":"Clean Java code with proper generics bounded by Plugin. First method has straightforward iteration logic checking plugin settings for activity and permissions before adding to visible list. Descriptive method names and standard utility usage. Second method signature clear but body missing. Highly readable for experienced Java developers despite framework assumptions.","tokens":1036,"name":"119.jsnp"}
{"score":"42","reasoning":"Code uses outdated Selenium RC API with deprecated methods like isVisible and clickAt. Hardcoded locators including Unicode character add confusion. Busy-wait loop with Thread.sleep and empty catch block is poor practice. Label-based control flow lacks context. Intent is understandable but brittle, unmaintainable, and lacks comments or constants, hindering comprehension.","tokens":1078,"name":"217.jsnp"}
{"score":"25","reasoning":"Code employs busy-wait infinite loops with manual 90-second timeouts instead of standard WebDriverWait, suppressing exceptions in empty catch blocks, relying on brittle hardcoded XPaths, duplicating similar loops, and using outdated Selenium RC methods. Poor variable names like second and absence of comments reduce readability and maintainability significantly.","tokens":1015,"name":"113.jsnp"}
{"score":"98","reasoning":"The code snippet features two concise Java methods that delegate to a local service with clear, descriptive names matching their purpose. Parameters and return types are straightforward, using fully qualified names for precision. Standard exception handling is present. No complex logic, making it extremely readable and easy to understand for any Java developer.","tokens":832,"name":"214.jsnp"}
{"score":"62","reasoning":"Code logic is clear: removes double quotes from library_path and trailing File.separator chars, tracking changes with boolean. However, inefficient string concatenation in loop with temp +\u003d c leads to poor performance for long strings. Inconsistent indentation and spacing reduce readability. Simple but unpolished style suitable for basic understanding.","tokens":1057,"name":"115.jsnp"}
{"score":"95","reasoning":"The code snippet is a standard Java interface declaration with comprehensive header comments including copyright license and Javadoc. Structure is clean and follows conventions perfectly. Empty interface body is trivial to comprehend. Slight deduction for lengthy license text which adds verbosity but does not hinder readability.","tokens":1008,"name":"160.jsnp"}
{"score":"82","reasoning":"Code shows clear structure with try-catch blocks handling specific exceptions like PrincipalException and NoSuchRoleException, adding session errors and forwarding appropriately. Logic flows logically from action processing to rendering. Minor issues include framework-specific APIs requiring Liferay knowledge and slightly long parameter lists, but indentation and naming aid comprehension for experienced Java developers.","tokens":1181,"name":"111.jsnp"}
{"score":"45","reasoning":"Code exhibits poor readability due to inconsistent indentation, irregular spacing around parameters, and uneven line breaks in method signatures. Logic is simple and straightforward with empty method bodies or notSupported calls, aiding comprehension of stub implementation. Overall formatting issues significantly hinder ease of reading.","tokens":1042,"name":"138.jsnp"}
{"score":"45","reasoning":"Code is linear and follows a clear wait-click-assert pattern using Selenium, making intent somewhat understandable. However, infinite loops with magic numbers (90s timeout, 1000ms sleep), silent exception swallowing, brittle locators (link text, XPath with IDs), hardcoded strings, and repetition without abstraction hinder readability and maintainability.","tokens":1116,"name":"220.jsnp"}
{"score":"95","reasoning":"Code is clean, well-structured Java class with proper imports, license header, and clear method overrides. Simple logic in getElements using storage to add document tree. Follows conventions, easy to comprehend purpose for SharePoint uncheckout. Minor deduction for undefined METHOD_NAME constant in snippet.","tokens":1139,"name":"125.jsnp"}
{"score":"92","reasoning":"The snippet contains three simple Java getter method declarations with clear, descriptive names that make their purpose immediately obvious. Standard syntax is used correctly. Minor deduction for non-standard line breaks after return types, which slightly impacts visual readability but does not hinder comprehension.","tokens":1049,"name":"158.jsnp"}
{"score":"72","reasoning":"Simple Java interface methods with standard getter setter pattern and isNew. Readability reduced by typos in Javadoc (class p k instead of classPK), missing Javadoc for first and last methods, and inconsistent indentation in comments. Purpose is clear despite flaws.","tokens":929,"name":"141.jsnp"}
{"score":"88","reasoning":"Code is clear and straightforward, populating cache model fields from getters. Null-safe date handling with getTime or Long.MIN_VALUE is consistent. Name normalization for empty strings is explicit. Minor repetition in date blocks could be refactored for better DRY principle, but indentation and logic flow enhance comprehension.","tokens":950,"name":"142.jsnp"}
{"score":"92","reasoning":"This Java interface snippet for MAC operations is highly readable with comprehensive Javadoc comments explaining parameters, returns, and exceptions clearly. Method names are descriptive and follow standard conventions. Minor deductions for typo in doFinal comment (statge instead of stage), abrupt start with */, and slight formatting inconsistencies in indentation.","tokens":1221,"name":"184.jsnp"}
{"score":"62","reasoning":"The code follows a clear sequence of Selenium test actions like waiting, clicking, and typing, making it somewhat comprehensible for familiar users. However, long brittle XPath selectors, repetitive polling loops, empty catch blocks ignoring exceptions, hardcoded file paths, and lack of comments hinder readability and maintainability.","tokens":1291,"name":"173.jsnp"}
{"score":"85","reasoning":"Well-structured Java Selenium test method with clear purpose of waiting for a UI element. Follows standard conventions, readable indentation, and self-explanatory logic. Polling loop is functional but verbose busy-wait style reduces modernity. Easy comprehension for Selenium users despite incompleteness.","tokens":1102,"name":"203.jsnp"}
{"score":"25","reasoning":"Code snippet is fragmented and incomplete, ending abruptly without full method or class context. Inconsistent indentation and missing surrounding structure hinder comprehension. Recognizable patterns like singleton instance usage and observer update exist, but lack of declarations and abrupt cuts make it difficult to follow overall logic and purpose.","tokens":934,"name":"132.jsnp"}
{"score":"70","reasoning":"The code is a linear Selenium test script using polling loops for waits, which is clear but verbose and duplicated. Locators are descriptive with text and XPath. Issues include empty catch blocks hiding errors, hardcoded timeouts and sleeps, and outdated Selenium RC API. Readable for experienced users but lacks modern practices like WebDriverWait.","tokens":1176,"name":"110.jsnp"}
{"score":"100","reasoning":"This is a perfect example of a standard Java setter method. It includes a clear, concise Javadoc comment describing its purpose, uses descriptive parameter naming matching the field, and performs a simple, direct assignment. No unnecessary complexity, follows Java conventions precisely, making it exceptionally readable and comprehensible to any developer.","tokens":754,"name":"161.jsnp"}
{"score":"25","reasoning":"Code snippet shows poor readability due to label-based control flow with continue statements mimicking goto, making flow hard to trace. Empty try-catch blocks ignore errors unsafely. Hardcoded Thread.sleep and brittle XPath selectors are fragile. Incomplete structure and abrupt case handling add confusion. Suitable only for those familiar with old Selenium RC style.","tokens":1049,"name":"121.jsnp"}
{"score":"65","reasoning":"The code snippet is short and demonstrates a clear polling loop intent to wait for a section element visibility using Selenium. Structure is simple with try-catch and sleep. However, the broad XPath selector lacks specificity, empty catch block swallows exceptions without logging, and Thread.sleep indicates inefficient busy-waiting, slightly hindering comprehension and best practices adherence.","tokens":1110,"name":"105.jsnp"}
{"score":"42","reasoning":"The code is a Selenium automation script for UI testing, using standard methods like clickAt, type, and assertEquals. However, heavy reliance on brittle, verbose XPath selectors hinders readability. Polling loops with magic numbers (90 seconds, 1000ms sleep) are repetitive and inefficient compared to WebDriverWait. No comments, indistinct variable usage, and RuntimeVariables add complexity. Functional but hard to comprehend and maintain.","tokens":1303,"name":"194.jsnp"}
{"score":"98","reasoning":"The code snippet features a clean Java constructor that delegates to the superclass and a straightforward getter method returning a constant ICMP header size of 8 bytes. It uses consistent indentation, clear naming, and has no complex logic, making it highly readable and easy to comprehend despite the minor stray comment closer at the start.","tokens":914,"name":"213.jsnp"}
{"score":"25","reasoning":"Incomplete code snippet cuts off mid-loop, making it hard to comprehend full intent. Basic structure uses old Selenium style with busy-wait timeout, which is inefficient and unclear without context. Clear class and method names, but no comments or logic beyond setup provide little value for readability.","tokens":977,"name":"114.jsnp"}
{"score":"88","reasoning":"Code is straightforward Java class implementing a preferences panel wrapper. Clear structure, simple constructor, null checks, and delegate methods. Appropriate comments and Javadoc. Minor deductions for underscore-prefixed fields (non-standard in modern Java), incomplete snippet, and missing setter for hint. Highly readable overall.","tokens":1206,"name":"147.jsnp"}
{"score":"42","reasoning":"Inconsistent indentation with mixed tabs and spaces hinders readability. Nested if-else chains for quote and escape handling are convoluted without comments or clear variable names. Operator precedence in conditions is correct but dense. Excessive whitespace and abrupt end reduce overall comprehension. Logic is functional but hard to parse quickly.","tokens":1105,"name":"164.jsnp"}
{"score":"60","reasoning":"The snippet uses standard Java syntax with proper synchronization block and if-else structure, making it syntactically readable. Indentation is mostly consistent. However, it is incomplete, lacking method signature, variable declarations, and full context, which hinders full comprehension. Logic seems odd: unregisters defaultObjectName only if cache miss, but removes cache entry on hit without unregistering, suggesting potential bug or truncation.","tokens":1306,"name":"156.jsnp"}
{"score":"98","reasoning":"This is a concise Java exception class extending PortalException. It includes a proper import, author Javadoc, and a standard no-arg constructor calling super(). Code follows Java conventions perfectly, with clear structure and no complexity. Highly readable and comprehensible for any Java developer, minor deduction for lack of additional details.","tokens":734,"name":"182.jsnp"}
{"score":"45","reasoning":"Code uses manual polling loops with infinite for statements, empty catch blocks swallowing exceptions, hardcoded sleeps and timeouts, and magic numbers. This makes it brittle and hard to maintain. Selenium action sequence is linear and understandable, but outdated practices lower readability for contemporary developers.","tokens":1268,"name":"210.jsnp"}
{"score":"35","reasoning":"The snippet shows incomplete Java method signatures likely from an interface. First declaration is malformed missing method name and return type. Second has proper Javadoc but awkward line breaks indentation and spacing. Syntax issues and poor formatting hinder readability and comprehension.","tokens":1073,"name":"118.jsnp"}
{"score":"35","reasoning":"The code snippet has poor readability due to inconsistent indentation, starting with a stray closing brace. The abstract encode method is straightforward but lacks context. The toString method uses an undefined string variable, unclear Hex.encode usage, and awkward string construction. Overall, formatting issues and missing context hinder comprehension.","tokens":989,"name":"169.jsnp"}
{"score":"95","reasoning":"Code is concise Java loop converting KaleoTimer models to KaleoTimerSoap using toSoapModel method, adding to list, then returning array. Uses standard enhanced for loop and toArray idiom. Highly readable and comprehensible for Java developers. Slight deduction for snippet incompleteness and abrupt constructor at end.","tokens":869,"name":"171.jsnp"}
{"score":"95","reasoning":"Clean Java interface with standard header, package, imports, and descriptive method names following conventions. Purpose clear from Javadoc and methods: provides session and object info for DB diff. Highly readable and comprehensible, minor deduction for sparse per-method Javadocs.","tokens":1139,"name":"200.jsnp"}
{"score":"72","reasoning":"Code is consistent boilerplate for Liferay CLP proxy methods with repetitive exception handling blocks. Readable for framework experts due to standard pattern, but verbose long class names, concatenation, and context dependency hinder general comprehension. Minor indentation issues in snippet.","tokens":1118,"name":"165.jsnp"}
{"score":"82","reasoning":"The code presents a standard Selenium test case for waiting on an element visibility using a polling loop with timeout handling and exception suppression. Structure is logical: page open, JS load, wait loop. Imports and class setup are clear. However, legacy Selenium RC style (selenium.open, isVisible) and hardcoded values reduce modernity. Incomplete snippet limits full evaluation but core logic is readable for experienced developers.","tokens":1023,"name":"219.jsnp"}
{"score":"100","reasoning":"The code consists of straightforward, repetitive method calls adding test classes to a test suite. Each line follows the same clear pattern with descriptive class names indicating test purposes. No complexity, excellent formatting, and immediately comprehensible even for beginners.","tokens":972,"name":"155.jsnp"}
{"score":"65","reasoning":"The code snippet shows a polling loop for a Selenium element using try-catch and sleep. Structure is simple and intent clear, but empty catch block silently ignores exceptions, which is poor practice and obscures errors. Hardcoded selector and sleep time reduce flexibility. Indentation is mostly consistent, aiding basic comprehension.","tokens":861,"name":"218.jsnp"}
{"score":"92","reasoning":"Clean Java interface with standard getter and setter methods for entity properties. Consistent naming conventions and proper Javadoc documentation on most methods providing clear descriptions and param returns. Minor deductions for missing Javadoc on setCompanyId and inconsistent exception declaration on getUserUuid. Overall highly readable and easy to comprehend.","tokens":941,"name":"130.jsnp"}
{"score":"25","reasoning":"Code fragment waits for Selenium iframe visibility. Poor indentation and formatting make it hard to parse. Hardcoded brittle XPath selector lacks abstraction. Empty catch block swallows exceptions silently, hiding issues. Fixed Thread.sleep is unreliable for waits. Intent is basic but code is fragile, unmaintainable, and follows poor practices.","tokens":923,"name":"124.jsnp"}
{"score":"72","reasoning":"The code uses Lifetrays service tunnel pattern with structured MethodKey and MethodHandler invocation plus proper exception handling and logging. Readability is good for framework experts due to consistency but hindered by repetitive boilerplate long parameter lists magic strings and undefined static fields like ParameterTypes4 and 5 making it less accessible to general readers.","tokens":1206,"name":"162.jsnp"}
{"score":"85","reasoning":"Code is straightforward Java with clear variable names and simple validation logic using if-else checks. Easy to comprehend the intent: validate required email subject and body fields, adding session errors if missing. Consistent indentation and structure. However, high duplication between the two nearly identical methods hurts readability and maintainability; refactoring into one reusable method would improve it.","tokens":1182,"name":"206.jsnp"}
{"score":"72","reasoning":"Code follows Java conventions with clear structure, proper constructor, exception handling, logging, and i18n support. Method logic is straightforward. However, logger and StringManager are initialized with DeleteAliasAction.class in AliasAction class, creating inconsistency and confusion. Error key also references DeleteAliasAction, reducing comprehension.","tokens":1180,"name":"137.jsnp"}
{"score":"10","reasoning":"The snippet is severely incomplete, showing only multiple closing braces without context or opening structures, followed by the partial beginning of a Java method. Indentation is inconsistent and excessive whitespace adds confusion. No meaningful logic or structure is comprehensible, making readability extremely poor.","tokens":779,"name":"117.jsnp"}
{"score":"92","reasoning":"The code is concise and clear Swing Java snippet creating a JPanel with BorderLayout for name input. Descriptive variable names like pnlName, lblName, txtName. Proper layout usage: label west, field center. i18n comment adds value. Assumes external variables like s_stringMgr and pnlEdit, minor indentation quirks, but highly readable for Java devs.","tokens":940,"name":"196.jsnp"}
{"score":"35","reasoning":"Code snippet has poor readability due to inconsistent indentation, empty catch block suppressing errors without handling, hardcoded locator string and sleep duration. Intent as polling loop for element visibility is guessable but lacks comments and context, making comprehension difficult.","tokens":921,"name":"143.jsnp"}
{"score":"35","reasoning":"Unconventional while-switch-label control flow is confusing and non-standard. Busy-wait polling loop with empty try-catch ignores errors poorly. Magic numbers like 90 and 30000 lack explanation. Repeated function calls and hardcoded selectors. Old deprecated Selenium API. Abruptly incomplete snippet hinders full understanding. Low readability for most developers.","tokens":1241,"name":"205.jsnp"}
{"score":"92","reasoning":"Simple, straightforward Java POJO implementing Serializable with clear getters, setters for exception and result, and hasError method. Standard structure enhances readability. Minor deductions for non-standard underscore field naming, verbose hasError logic that could be return _exception !\u003d null, and fields not declared in snippet but obviously private. Easy to comprehend overall.","tokens":1264,"name":"163.jsnp"}
{"score":"98","reasoning":"The snippet is a clean Java file header with copyright license package declaration and organized imports. It adheres to standard Java conventions proper formatting and no syntax issues. Extremely readable and comprehensible as it contains no complex logic just preparatory elements.","tokens":1170,"name":"134.jsnp"}
{"score":"92","reasoning":"Clean Java interface snippet using Sapphire framework. Imports are properly organized alphabetically by package. Includes standard Javadoc with author. Annotation and extends clause are clear and conventional. Highly readable and easy to comprehend, minor deduction for abrupt incompleteness without body or closing brace.","tokens":887,"name":"179.jsnp"}
{"score":"90","reasoning":"Simple wrapper class using delegation pattern. Constructor initializes fields clearly. Methods are concise, delegating to wrapped token or handling null reset in setAuthToken. Underscore field naming is dated but consistent. Easy to comprehend purpose despite missing field declarations in snippet. High readability for experienced Java developers.","tokens":1157,"name":"139.jsnp"}
{"score":"82","reasoning":"The code is a straightforward Java main method for testing a Swing UI panel. Structure is clear with standard JFrame setup, good use of final for frame, and logical flow. Positives include descriptive class name and simple logic. Deductions for incomplete Javadoc comment, potential missing import for SQLAliasConnectionProperties, unnecessary empty lines, hard-coded frame size, and abrupt snippet end without closing braces, slightly impacting comprehension.","tokens":1223,"name":"123.jsnp"}
{"score":"98","reasoning":"Clean Java interface with proper package declaration, imports, comprehensive Javadoc comments including authors and method descriptions. Clear method signatures, follows conventions perfectly. Minor omission of Javadoc for getName method prevents perfect score. Highly readable and easy to comprehend.","tokens":897,"name":"216.jsnp"}
{"score":"70","reasoning":"This Java interface snippet features consistent method signatures for bookmarks operations, with clear naming and logical grouping. Transactional annotations are uniformly applied. Readability is good for Liferay developers due to standardization, but verbosity from fully qualified types, long parameter lists, and repeated throws clauses hinders quick scanning for others. No implementation clutter aids comprehension.","tokens":1357,"name":"144.jsnp"}
{"score":"98","reasoning":"Code is exceptionally readable: clear package imports, concise Javadoc for class and methods, straightforward static methods with simple delegation to X962NamedCurves. Logical flow, consistent naming, no complexity or redundancy. Easily comprehensible for any Java developer familiar with crypto libs. Slight deduction for legacy Enumeration usage.","tokens":1064,"name":"122.jsnp"}
{"score":"82","reasoning":"Code features standard Java getters, setters, and toString methods using clear naming conventions. High readability from simple structure and truncation logic in toString. Minor deductions for missing labels in toString concatenation like cn without equals, empty javadoc in sendAZID, and snippet incompleteness. Overall easy to comprehend for experienced developers.","tokens":1081,"name":"108.jsnp"}
{"score":"95","reasoning":"The code is very concise, readable, and easy to comprehend. It performs a simple null check before calling punch method. Variable names are descriptive. Straightforward logic flow. Minor issues: unnecessary parentheses around returns and slightly inconsistent indentation with extra spaces.","tokens":843,"name":"185.jsnp"}
{"score":"75","reasoning":"The code shows consistent updatePortletPermissions calls with portlet IDs class names and permission arrays making patterns easy to follow. Standard Java syntax and structure aid readability. However hardcoded strings magic numbers lack of comments and abrupt incomplete getLayout method with database setup reduce overall comprehension for newcomers.","tokens":1245,"name":"127.jsnp"}
{"score":"25","reasoning":"The code snippet is fragmented and lacks context, starting abruptly with an element ID. Cryptic names like _2_announcementsTypetestEmailCheckbox hinder understanding. Logic checks testEmailChecked to skip a Selenium click, but undeclared variables like label and selenium reduce clarity. Poor readability due to obfuscation and incompleteness.","tokens":994,"name":"129.jsnp"}
{"score":"92","reasoning":"The snippet features a clear else-if branch for enum value matching using equals, returning the constant or throwing a precise IllegalArgumentException. It ends with a simple getter for the private field. Code follows Java conventions, is concise, self-explanatory, and easy to follow despite being a fragment of a larger method.","tokens":979,"name":"109.jsnp"}
{"score":"85","reasoning":"Code snippet is minimalistic with clear package, import, and class name. Field names are descriptive and self-explanatory: points array and boolean flag. Proper Java syntax and indentation. Deductions for incomplete class (no methods or constructors), lack of access modifiers on fields, and no comments or initialization, slightly impacting full comprehension.","tokens":1013,"name":"128.jsnp"}
{"score":"68","reasoning":"Java method declarations in an interface snippet. Clear signatures for getURLExport and getUrlTitle, but poor indentation, fragmented start of another method, and minor naming inconsistency (URL vs Url casing). Throws Exception is broad. Readable for Java experts, but formatting hinders ease of comprehension.","tokens":1050,"name":"195.jsnp"}
{"score":"68","reasoning":"Code follows standard Java conventions with clear method structures and use of common libraries like Matcher and HashMap. However, readability is hindered by a spelling error in _proccessAttributes, inconsistent naming with underscores, undefined constants like _EVENT_AFTER_REGEX and _DYNAMIC_ATTRIBUTES, abrupt incomplete ending mid-statement, and partially unused variables like afterEventOptionsMap, making full comprehension challenging.","tokens":1434,"name":"211.jsnp"}
{"score":"85","reasoning":"Code presents clear JUnit-style test methods for persistence CRUD operations with descriptive names and proper assertions. Easy to follow intent. Minor issues: testUpdateNew is too minimal, testUpdateExisting incomplete, depends on undefined helpers like nextLong and randomString. Highly readable for Java developers familiar with testing frameworks.","tokens":1154,"name":"120.jsnp"}
{"score":"85","reasoning":"Code is clear and functional, using StringBundler correctly with exact capacity 17 for efficient string building in toString method. toEntityModel sets fields consistently, handles nulls for strings explicitly which is readable. Verbose null checks and repetitive appends slightly reduce conciseness, but overall easy to comprehend with good naming and structure.","tokens":1411,"name":"197.jsnp"}
{"score":"92","reasoning":"The code is well-structured with clear variable names and logical flow for retrieving locale-based language values in JSF context. Proper null checks for key and locale fallback. Debug logging is informative though missing closing brace in format string. Unsupported methods clearly throw exceptions. Easy to comprehend for Java web developers.","tokens":1623,"name":"154.jsnp"}
