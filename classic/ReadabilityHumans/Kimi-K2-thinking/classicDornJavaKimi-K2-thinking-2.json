{"score":"90","reasoning":"Clean and well-organized import block with logical grouping. Liferay imports precede Java core imports following standard conventions. Class names are descriptive and self-explanatory, clearly indicating logging, property management, and utility purposes. No complexity or ambiguity present. Minor improvement could be alphabetical sorting within groups.","tokens":1081,"name":"208.jsnp"}
{"score":"68","reasoning":"Clear naming for class and method follows test conventions. Lacks explanatory comments, uses hardcoded URL and generic Exception. Incomplete snippet limits evaluation. Simple structure but needs more context and best practices for better readability.","tokens":1215,"name":"191.jsnp"}
{"score":"55","reasoning":"Code snippet is incomplete and lacks context making it hard to follow. Inconsistent formatting with abrupt method endings and misplaced braces. Missing exception messages reduces debuggability. No comments or documentation. Positive aspects include clear method names and reasonable validation logic but code duplication exists. Overall comprehension is hindered by fragmentation.","tokens":1419,"name":"131.jsnp"}
{"score":"25","reasoning":"Code suffers from severe readability issues. Empty catch block silently suppresses all exceptions making error handling opaque. Inconsistent indentation obscures control flow structure. Magic number 1000 lacks context. Hardcoded XPath is brittle and unclear. Awkward line break in method call. No comments or explanatory context. Overall structure is confusing and maintenance would be difficult.","tokens":1280,"name":"174.jsnp"}
{"score":"70","reasoning":"The code snippet is brief and focused, making it easy to understand at a glance. The constructor contains commented-out code which is confusing and suggests incomplete implementation. The getIcon method is straightforward with clear purpose. Minor formatting inconsistency in the return statement. Lack of documentation is acceptable given simplicity. Overall readable but the dead code comment is a significant distraction.","tokens":1299,"name":"181.jsnp"}
{"score":"35","reasoning":"Code snippet lacks context making full comprehension difficult. Contains empty catch block which is a critical anti-pattern that silently suppresses exceptions harming debuggability. Generic XPath for section element lacks specificity. Indentation appears inconsistent. While the basic polling logic is recognizable the implementation has serious readability and maintainability issues.","tokens":1417,"name":"192.jsnp"}
{"score":"55","reasoning":"Undefined BETTER_THAN macro obscures core comparison logic. Variables dif and bias lack context or initialization. Cryptic bias update formulas have no explanatory comments. posBetter and negBetter flags purpose is unclear without broader context. Simple structure but requires significant external knowledge to comprehend. No inline documentation.","tokens":1648,"name":"112.jsnp"}
{"score":"65","reasoning":"Code shows unconventional formatting with line breaks in class and method declarations reducing readability. Uses wildcard imports and inconsistent spacing alignment. Variable names are generally clear and logic is straightforward. Legacy style with underscores in static monitor name. Comment is helpful but overly emphatic. Overall structure is understandable but formatting issues hinder quick comprehension.","tokens":1736,"name":"151.jsnp"}
{"score":"78","reasoning":"Code demonstrates clear variable naming and consistent structure. Uses standard patterns like factory methods and utility classes effectively. Logging checks are proper but add verbosity. Main readability issues are deeply nested if statements in upgradeProcess method and incomplete snippet context. Overall well organized for domain specific code with good separation of concerns.","tokens":1811,"name":"103.jsnp"}
{"score":"72","reasoning":"Simple getter methods are readable with clear naming. Inconsistent brace formatting and missing context reduce clarity. The equals method lacks braces on if statements which hurts readability. hashCode follows standard pattern but uses unexplained magic numbers. Overall structure is straightforward but formatting issues and incomplete view limit comprehension.","tokens":1722,"name":"150.jsnp"}
{"score":"60","reasoning":"Clear naming and structure but outdated Selenium patterns reduce readability. Manual wait loop with magic numbers 90 and 1000 is inferior to explicit waits. Empty catch block is an anti-pattern that hides errors. Hardcoded locators and broad Exception declaration decrease maintainability. Logic is understandable but implementation creates unnecessary complexity.","tokens":1754,"name":"212.jsnp"}
{"score":"58","reasoning":"Snippet begins mid-statement with inconsistent indentation impairing readability. Variable naming is clear and constants are properly utilized but formatting issues persist particularly in serveResource method signature. Magic strings used without explanation. Lack of comments and context reduces comprehension. Overall structure follows portlet patterns but visual organization needs improvement.","tokens":1824,"name":"186.jsnp"}
{"score":"58","reasoning":"Incomplete first line reduces context. Deep nested method calls with stacked closing parentheses hinder readability. Casting and multi-line structure are awkward. However, constants and descriptive method names provide clarity. Logic is simple but execution is convoluted. Refactoring into intermediate variables would improve comprehension significantly.","tokens":1671,"name":"133.jsnp"}
{"score":"55","reasoning":"Moderate readability with clear naming and conditional structure. Significant issues: overly broad exception handling hides errors, potential null pointer risks, incomplete final method missing return. Confusing error strategy returns default 0 for any failure. Logic flow is understandable but lacks robustness and clarity for edge cases.","tokens":1917,"name":"101.jsnp"}
{"score":"88","reasoning":"Code demonstrates excellent readability with clear method names consistent with Java conventions. Each method is concise and focused on a single responsibility. Uses descriptive parameter names and standard patterns like enhanced for-loops. Exception handling is consistent. Minor deduction for incomplete first method signature in snippet and boilerplate nature typical of framework code. Overall structure is clean and easily comprehensible.","tokens":1854,"name":"153.jsnp"}
{"score":"65","reasoning":"Code suffers from raw Map type without generics, commented-out logging clutter, unclear magic number -1, inefficient containsKey+get usage, vague parameter name sID, and empty javadoc. While class structure is understandable, these anti-patterns significantly reduce readability and maintainability.","tokens":2092,"name":"166.jsnp"}
{"score":"45","reasoning":"Code suffers from severe indentation inconsistencies and mixed whitespace usage. Missing Javadoc and contextual information for private fields. Incomplete snippet reduces comprehension. Logic flow is confusing with misplaced revalidate() calls and conditional super method invocations. Despite correct method signatures, formatting issues significantly hinder readability.","tokens":1979,"name":"170.jsnp"}
{"score":"35","reasoning":"Missing loop declaration creates incomplete context. Empty catch blocks hide exceptions. Magic numbers lack explanation. Uses deprecated Selenium RC API with polling sleeps instead of explicit waits. No comments or constants for locators. Unconventional infinite loop pattern. Poor error handling and maintainability.","tokens":2082,"name":"146.jsnp"}
{"score":"42","reasoning":"Code suffers from poor readability due to raw types without generics requiring explicit casts, cryptic variable names like dm/am/lp, and confusing reuse of parameter_group ArrayList. Magic strings are used directly instead of constants. The method mixes UI creation, listener setup, and state management without clear separation. Comments are minimal and vague. Overall structure is functional but maintenance would be difficult.","tokens":2587,"name":"106.jsnp"}
{"score":"65","reasoning":"Code has partial Javadoc for the main constructor but lacks explanation for the default constructor passing five nulls. Parameter naming is inconsistent. Javadoc is incomplete - parameters \u0027md\u0027 and \u0027aTableName\u0027 lack proper documentation. Fields are referenced but not declared, requiring external context. While getter/setter methods are documented, overall comprehension is hindered by missing context about the parent class and the cryptic null constructor.","tokens":2455,"name":"221.jsnp"}
{"score":"90","reasoning":"Code shows excellent readability with clear naming, proper static finals, and concise comments. The private static i18n interface for localized strings is well-structured. Class hierarchy is explicit and constructor is simple. Clean focused structure makes it easy to comprehend for Java developers familiar with internationalization patterns.","tokens":1373,"name":"172.jsnp"}
{"score":"35","reasoning":"Code suffers from severe readability issues: syntax errors, magic strings and numbers, poor variable naming, confusing control flow with labels, code duplication, and lack of context. The use of brittle XPath selectors and complex regex patterns further hinders comprehension. No comments explain the test purpose.","tokens":1499,"name":"193.jsnp"}
{"score":"90","reasoning":"Clean Java interface methods with descriptive names following standard conventions. getServiceName includes clear Javadoc and proper annotation. setGadgetKey missing documentation is the only minor issue. Code is immediately understandable to any Java developer with no complexity or ambiguity.","tokens":1313,"name":"168.jsnp"}
{"score":"95","reasoning":"Code shows excellent readability with clear naming, consistent Javadoc, and simple implementations. Minor formatting inconsistency in one setter is negligible. The repetitive pattern is predictable and easy to understand.","tokens":1597,"name":"136.jsnp"}
{"score":"40","reasoning":"The code demonstrates poor readability due to repetitive patterns, hardcoded XPath locators, magic numbers, and an empty catch block that suppresses exceptions. The long procedural structure lacks abstraction, making it difficult to understand the test\u0027s intent. The hardcoded file path and duplicated wait calls indicate a lack of maintainability. Overall, it resembles an auto-generated script without proper refactoring.","tokens":1766,"name":"198.jsnp"}
{"score":"92","reasoning":"Clear and concise test suite structure following standard JUnit patterns. Descriptive class and method names effectively communicate purpose. Simple aggregation of test suites with straightforward logic. Minimal but sufficient documentation. Code is incomplete but what is present demonstrates excellent readability and would be easily understood by developers of any level.","tokens":1144,"name":"176.jsnp"}
{"score":"78","reasoning":"Code demonstrates good structure with descriptive method and variable names. Test purposes are clear through naming conventions. However heavy reliance on framework-specific utilities (DynamicQueryFactoryUtil, ProjectionFactoryUtil) and undefined helper methods (nextLong, randomString) requires substantial domain knowledge. The casting to ModelImpl and cache logic adds complexity. Overall readable for framework-experienced developers but opaque for others.","tokens":1681,"name":"204.jsnp"}
{"score":"72","reasoning":"Code shows clear variable naming and logical structure but suffers from a 13-parameter method call reducing readability. The null parameter is ambiguous and short variable name \u0027is\u0027 lacks clarity. While formatted well and following Liferay patterns, the long parameter list is a significant readability concern that could be improved with a builder or parameter object pattern.","tokens":1358,"name":"135.jsnp"}
{"score":"88","reasoning":"Clean well-structured Liferay service implementation with descriptive method names and consistent permission-checking pattern. Methods are concise and follow clear CRUD logic. Minor deductions for unused import and lack of method-level documentation. Code is highly readable for developers familiar with the framework.","tokens":1587,"name":"175.jsnp"}
{"score":"70","reasoning":"Repetitive exception handling boilerplate across three methods. Each delegates to PortalServiceUtil, catches Exception, logs with confusing _log.error(e, e) syntax, and re-throws as RemoteException. Inconsistent naming in testCounterIncrement_Rollback() hurts readability. While the pattern is clear and methods are short, the duplication and unclear logging parameter reduce comprehension. Cross-cutting concern should be abstracted.","tokens":2106,"name":"140.jsnp"}
{"score":"50","reasoning":"Code suffers from severe duplication of null/enabled checks across methods violating DRY principle. Inconsistent return values (null vs emptyList) reduce predictability. The repeated logging pattern increases cognitive load. While method names are clear and formatting is adequate the maintenance burden and incomplete final method significantly impact readability.","tokens":2210,"name":"116.jsnp"}
{"score":"62","reasoning":"The code suffers from excessive repetitive setter calls lacking abstraction, making it tedious to read despite clear naming. The compareTo method is overly verbose with redundant variables and returns. While individual lines are simple, the overall pattern hinders quick comprehension and suggests poor design. The boilerplate nature increases maintenance burden and error risk.","tokens":1613,"name":"183.jsnp"}
{"score":"60","reasoning":"Code uses overly verbose fully qualified class names reducing readability. Inconsistent API with indexed getters/setters only for archiveFiles. Missing Javadoc for constructors and indexed methods. Basic POJO structure is clear but these issues significantly hinder comprehension.","tokens":1637,"name":"188.jsnp"}
{"score":"35","reasoning":"Code suffers from severe repetition violating DRY principles. Contains magic strings and numbers hardcoded throughout. Uses outdated anti-pattern for waiting with silent exception swallowing and magic timeout values. No abstraction layer or Page Objects. Locators are cryptic XPath expressions. While linear flow is simple to follow, maintenance would be extremely difficult. Poor variable naming and structure.","tokens":1900,"name":"167.jsnp"}
{"score":"55","reasoning":"Code uses verbose naming but suffers from poor readability. Contains magic numbers (90, 1000), empty catch block silently ignoring exceptions, and a convoluted manual wait loop instead of proper Selenium waits. The \u00273\u0027 in naming is ambiguous. Lacks inline comments explaining the polling logic.","tokens":1346,"name":"209.jsnp"}
{"score":"25","reasoning":"Code contains extensive magic values complex XPath locators manual polling loop with empty catch block confusing switchcase with labelcontinue control flow no abstraction outdated Selenium RC API inconsistent formatting and swallowed exceptions severely hinder comprehension","tokens":1924,"name":"107.jsnp"}
{"score":"88","reasoning":"Excellent descriptive naming for class, methods, and parameters clearly indicates Command pattern usage. Logic is simple and focused. Deducted points for inconsistent spacing around parentheses, missing field declarations for full context, and lack of explicit visibility modifiers. Overall straightforward and easy to follow for intermediate Java developers.","tokens":1358,"name":"104.jsnp"}
{"score":"35","reasoning":"Code shows severe repetition patterns, brittle XPath locators with auto-generated IDs, magic numbers, unclear control flow via label variable, and incomplete loop structure. Uses deprecated Selenium RC API without abstraction layer. While sequentially traceable, the lack of comments and poor maintainability make comprehension difficult.","tokens":2055,"name":"157.jsnp"}
{"score":"35","reasoning":"Code snippet shows poor formatting with inconsistent indentation and split method declaration. The floating getLeecherCount() line lacks context and proper signature. Javadoc comment is incomplete with empty return tag. While method name is descriptive, non-standard structure and missing elements significantly hinder readability.","tokens":1283,"name":"126.jsnp"}
{"score":"48","reasoning":"Code snippet lacks surrounding context making flow unclear. Uses inverted logic with verbose constants reducing readability. Inefficient array initialization and repeated code patterns show poor structure. Non-standard naming convention with underscore prefix. Unnecessary else block could be simplified. Missing comments and documentation. Overall logic is understandable but implementation has multiple readability anti-patterns that hinder comprehension.","tokens":1459,"name":"187.jsnp"}
{"score":"68","reasoning":"Code snippet contains only Javadoc header and two import statements. The header follows standard format but is overly verbose with excessive HTML tags and line breaks. Contains a copy-paste error referencing Foobar instead of sqsc-isqlj which reduces clarity. No actual implementation code present to evaluate for comprehension. Overall structure is conventional but cluttered making it moderately readable.","tokens":1379,"name":"190.jsnp"}
{"score":"65","reasoning":"The code demonstrates inconsistent naming conventions mixing camelCase and snake_case, poorly maintained Javadoc templates, and unusual vertical alignment. While method overloading is appropriate and return types are specific, the numeric suffixes in method names and the initial code fragment reduce clarity. The inline comments are helpful but sparse.","tokens":1390,"name":"201.jsnp"}
{"score":"30","reasoning":"Code suffers from major readability issues: empty catch blocks silently ignore exceptions, duplicate loops violate DRY principle, magic numbers (90, 1000, 30000, 5000) lack context, brittle XPath locators with magic index li[10] are hard to maintain, Thread.sleep calls create flaky tests, no inline comments explain intent, and hardcoded strings reduce flexibility. Overall structure is functional but difficult to comprehend and maintain.","tokens":1871,"name":"145.jsnp"}
{"score":"20","reasoning":"Code has severe readability issues with magic strings and numbers cryptic XPath locators poor variable naming unclear control flow mixing continue with case labels heavy duplication missing context and no comments. The brittle state machine pattern is very difficult to comprehend and maintain.","tokens":2890,"name":"152.jsnp"}
{"score":"72","reasoning":"The test structure is logical with clear calendar creation and assertion patterns. However, readability suffers from magic numbers (3, 1) in getRecurrence() whose meaning is unclear without context. Heavy reliance on inherited constants (FRIDAY, FEBRUARY, dtStart) from parent class requires external knowledge. Method name assertRecurrenceEquals is slightly ambiguous. Overall decent but needs better self-documentation.","tokens":1463,"name":"159.jsnp"}
{"score":"30","reasoning":"Archaic label-switch pattern creates confusing goto-like control flow. Empty catch block hides exceptions. Magic numbers 90 and 1000 lack context. Hardcoded strings and poor variable naming reduce clarity. No inline comments. Uses outdated Selenium RC API. Properly indented but requires domain knowledge.","tokens":2812,"name":"102.jsnp"}
{"score":"50","reasoning":"Code snippet lacks context starting and ending abruptly. Naming is inconsistent with cryptic variable q. Logic for orderByComparator is confusing due to unclear false parameter. Finally block mixes resource cleanup with caching logic and appears incomplete. While try-catch-finally structure is proper, overall readability suffers from dense formatting and framework-specific patterns that are not self-explanatory. Requires deep Liferay knowledge to comprehend fully.","tokens":1722,"name":"202.jsnp"}
{"score":"88","reasoning":"Clear JUnit test suite aggregation with descriptive naming. Class name indicates purpose, method follows conventions. Simple structure with good indentation. Minimal documentation but sufficient for test code. Empty line after declaration is minor style issue. Code appears truncated but visible portion is highly readable and easy to comprehend.","tokens":1477,"name":"207.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability through its simple structure and clear naming conventions. It follows standard JUnit patterns with descriptive test class names that indicate their purpose. The suite method is straightforward, creating a TestSuite and adding tests in logical order setup to teardown. Minimal complexity and consistent formatting make it immediately comprehensible to any Java developer familiar with unit testing frameworks.","tokens":1180,"name":"199.jsnp"}
{"score":"40","reasoning":"Inconsistent indentation and awkward line breaks hinder visual flow. Magic numbers, hardcoded strings, and incomplete if-block reduce clarity. Deprecated Selenium RC API usage and unclear label variable suggest outdated patterns. While basic logic is traceable, poor formatting and lack of modern practices significantly impact readability.","tokens":1186,"name":"149.jsnp"}
{"score":"50","reasoning":"Code suffers from poor formatting with awkward line breaks in method signatures, vague variable names like find/match/value, magic strings for XML tags, commented-out debug code, and is an incomplete snippet. Regex patterns are complex without sufficient explanation. Javadoc exists but is minimal. Overall structure is understandable but requires significant effort to comprehend due to these issues.","tokens":1911,"name":"177.jsnp"}
{"score":"40","reasoning":"Incomplete code snippet missing method signature and closing braces. Logic is counter-intuitive: null cache entry triggers MBean unregistration while non-null removes from cache only. Variable names use outdated underscore prefix. No comments explain intent. Synchronization is clear but overall purpose is obscure without context. The reversed conditional logic significantly hampers comprehension.","tokens":1206,"name":"156.jsnp"}
{"score":"65","reasoning":"Code demonstrates clear test intent with descriptive naming but suffers from poor practices. Empty catch block silently suppresses exceptions, magic numbers lack context, and Thread.sleep creates brittle timing. The polling loop is functional but unconventional. While understandable for Selenium veterans, these anti-patterns reduce maintainability and could obscure failure causes, making it moderately difficult to comprehend for general developers.","tokens":1177,"name":"203.jsnp"}
{"score":"65","reasoning":"Unconventional line breaks separating return types from method names reduce readability despite clear naming. This violates Java formatting standards creating unnecessary cognitive load. Method names are descriptive and consistent but formatting choice hampers quick comprehension. Simple structure aids understanding yet non-standard style distracts experienced developers.","tokens":1061,"name":"158.jsnp"}
{"score":"87","reasoning":"Clear naming conventions with descriptive constant names following Java standards. Simple structure makes it immediately understandable. Minor deductions for missing class-level documentation, lack of private constructor for utility class, and unexplained numeric gaps between values. Overall highly readable for any Java developer.","tokens":1515,"name":"189.jsnp"}
{"score":"45","reasoning":"Code suffers from severe inconsistent indentation making structure hard to follow. Missing context at start. Tests use outdated exception handling patterns and awkward string concatenation. While core logic is simple, poor formatting significantly hinders readability. Variable names are clear but overall presentation needs major improvement.","tokens":1464,"name":"178.jsnp"}
{"score":"40","reasoning":"Code snippet lacks context starting mid-condition with incomplete method signature. Contains multiple empty catch blocks silently ignoring exceptions. Complex nested logic for file retrieval with poor variable naming like uoe nsfee. Unclear resource management and magic boolean values reduce comprehension. Overall structure is fragmented making flow difficult to follow.","tokens":1688,"name":"180.jsnp"}
{"score":"78","reasoning":"The code demonstrates clear naming conventions and a consistent setter pattern that makes intent obvious. Logical grouping of related properties enhances comprehension. However repetitive boilerplate structure and inconsistent line breaks slightly reduce readability. The simple conditional block for iconImage is well handled. Overall straightforward and maintainable despite verbosity typical of Java entity configuration.","tokens":1601,"name":"148.jsnp"}
{"score":"30","reasoning":"Missing context makes label continue case flow confusing. Magic strings and numbers everywhere. Empty catch block is bad practice. Uses outdated Selenium RC with primitive waits. Poor formatting and no comments make maintenance difficult.","tokens":1946,"name":"217.jsnp"}
{"score":"45","reasoning":"Code suffers from inconsistent formatting with tabs in variable declarations, poor naming (temp, c), inefficient string concatenation in loop, magic characters, awkwardly placed comments, and undefined variable changed. While the logic is eventually understandable, these issues significantly hinder readability and maintainability. Modern Java practices like StringBuilder are ignored.","tokens":1236,"name":"115.jsnp"}
{"score":"35","reasoning":"Code uses outdated Selenium RC patterns with multiple readability issues: magic numbers (90, 1000, 30000), empty catch block swallowing exceptions, duplicate timeout loops, hardcoded XPaths, and Thread.sleep for waits. Inconsistent API usage and lack of comments make intent unclear. Functional but maintains poorly.","tokens":1393,"name":"220.jsnp"}
{"score":"50","reasoning":"Code uses generic Exception catching with instanceof checks, which is poor practice. It throws exceptions for control flow (NoSuchRoleException based on role name checks), making logic harder to follow. Inconsistent error handling between methods (setForward vs return mapping.findForward). Contains magic strings and lacks context at snippet start. Deep nesting and missing comments reduce clarity. While functional, these anti-patterns significantly hinder readability and maintainability.","tokens":1627,"name":"111.jsnp"}
{"score":"25","reasoning":"Contains syntax error, magic numbers everywhere, empty catch blocks hiding exceptions, duplicated brittle XPath, poor infinite loop structure, hardcoded timeouts, inconsistent formatting, and deprecated Selenium RC API. No comments or meaningful variables. Extremely difficult to understand intent and maintain. Severe anti-patterns drastically reduce readability.","tokens":1856,"name":"215.jsnp"}
{"score":"35","reasoning":"The code demonstrates poor readability due to an empty catch block swallowing exceptions, a magic number for sleep duration, and unclear loop context. The broad Exception handling hides potential errors, making debugging difficult. Raw XPath strings and inconsistent formatting further reduce comprehension. While the polling intent is discernible, the implementation uses anti-patterns that severely impact maintainability.","tokens":1134,"name":"105.jsnp"}
{"score":"88","reasoning":"Clear Javadoc explains purpose for registering UI elements with datasource. Package name follows logical hierarchy. Interface name is reasonably descriptive though slightly ambiguous. Standard GPL license header is verbose but legally necessary. Code follows Java conventions. Snippet is incomplete but shows good documentation practices. Overall high readability for a simple interface declaration.","tokens":1287,"name":"160.jsnp"}
{"score":"35","reasoning":"Code snippet shows severe formatting issues with broken method signatures and inconsistent style. First method is incomplete missing return type and name. Mix of empty implementations and notSupported calls without context reduces clarity. Parameter names are abbreviated. No comments explain design decisions. While method names are descriptive overall structure is confusing and appears to be either poorly extracted or incomplete stub implementation making it difficult to comprehend.","tokens":1329,"name":"138.jsnp"}
{"score":"68","reasoning":"Simple interface methods with clear Java naming conventions. Javadoc is poorly written using unnatural class p k spacing and redundant descriptions. Lacks context about expando row meaning. Despite documentation issues the method signatures remain straightforward for basic comprehension.","tokens":1265,"name":"141.jsnp"}
{"score":"65","reasoning":"Code fragment shows poor formatting with awkward line breaks splitting method signature across lines. First line lacks context being just a parameter tail. Javadoc is clear and method naming is descriptive but unconventional style hinders quick comprehension. Readable enough to understand intent but violates standard Java conventions significantly.","tokens":809,"name":"118.jsnp"}
{"score":"30","reasoning":"Excessive inconsistent whitespace and poor indentation hinder visual flow. Complex boolean logic suffers from unclear operator precedence. Variable names like \u0027bit\u0027 are vague. Fragment lacks context and comments. Escape state handling appears contradictory. Overall structure is confusing and error-prone.","tokens":1420,"name":"164.jsnp"}
{"score":"82","reasoning":"Java MAC interface with clear method naming and standard crypto API structure. Javadoc comments explain purpose well despite minor typos like statge and awkward in in phrase. Inconsistent indentation and use of older @exception tags reduce readability slightly. Overall well-designed interface that is easy to comprehend for target audience.","tokens":1688,"name":"184.jsnp"}
{"score":"35","reasoning":"Poor readability due to cryptic \u00271\u0027 in naming, outdated manual timeout loop with magic number 90, and incomplete structure. Uses verbose Selenium RC pattern instead of modern explicit waits. Lacks comments explaining the complex loop logic. Method calls are clear but overall comprehension is hindered by anti-patterns.","tokens":1301,"name":"114.jsnp"}
{"score":"20","reasoning":"Code contains major anti-patterns: empty catch block silently swallows exceptions, magic numbers and cryptic XPath strings reduce clarity, infinite loops with break conditions are harder to follow than explicit waits. Duplicated timeout logic and lack of abstraction make maintenance difficult. No comments explain intent. Modern Selenium offers better patterns like WebDriverWait. Overall structure is procedural and fragile.","tokens":1811,"name":"113.jsnp"}
{"score":"35","reasoning":"Code suffers from major readability issues: empty exception handling, magic numbers/strings, duplicate polling loops, hard-coded platform-specific paths, and overly long XPath expressions. No comments or abstraction make intent unclear. The structure is brittle and difficult to maintain, representing a common anti-pattern in recorded but unrefactored Selenium tests.","tokens":1901,"name":"173.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear naming and clean structure. Generic types enhance clarity and type safety. Logic is straightforward to follow with proper indentation and spacing. Code is largely self-documenting though inline comments could benefit junior developers. Static service locator pattern is typical for this framework architecture.","tokens":2278,"name":"119.jsnp"}
{"score":"95","reasoning":"The code demonstrates excellent readability with clear method names following Java conventions. The copy constructor and simple getter are immediately understandable. Methods are concise and focused. The constant return value 8 is appropriate for ICMP header length context. No unnecessary complexity or cognitive overhead. Minor improvement could be extracting the magic number to a named constant, but overall comprehension is near perfect.","tokens":1628,"name":"213.jsnp"}
{"score":"30","reasoning":"Code uses brittle XPath locators with positional indices making element identification unclear. Contains poor wait patterns with Thread.sleep loops and empty exception handlers. Lacks abstraction, has magic strings/numbers, and uses outdated Selenium RC style. Long lines and concatenated strings reduce clarity. Overall structure is procedural but maintenance is extremely difficult.","tokens":2018,"name":"194.jsnp"}
{"score":"35","reasoning":"Code shows poor readability due to duplicated timeout loops with magic numbers 90, 1000, 30000, empty catch blocks that swallow exceptions, hardcoded locators, and deprecated Selenium RC API. The infinite loop syntax is unconventional and unclear. No encapsulation or comments exist. While sequentially logical, maintenance is hard due to DRY violations and hidden failures. Modern WebDriver waits would improve clarity significantly.","tokens":1931,"name":"110.jsnp"}
{"score":"92","reasoning":"Standard Java setter with clear naming convention. Javadoc exists but is redundant, merely restating method signature. Parameter line break is unnecessary for such a short signature. Overall structure is simple and immediately understandable to any Java developer, following established patterns with proper indentation.","tokens":1279,"name":"161.jsnp"}
{"score":"45","reasoning":"Code snippet lacks context from leading brace. Variable name string is too generic. Inconsistent formatting reduces readability. Hex.encode is non-standard requiring external knowledge. String constructor lacks charset specification. Abstract method declaration is clear but overall comprehension suffers from poor naming and missing context.","tokens":1439,"name":"169.jsnp"}
{"score":"45","reasoning":"The code suffers from poor readability due to magic numbers (90, 1000, 30000, 5000) without explanation, empty catch blocks that hide errors, duplicated wait loops that should be refactored, hardcoded UI locators, and inappropriate Thread.sleep usage. These anti-patterns make maintenance difficult and obscure the test\u0027s intent despite its simple sequential structure.","tokens":1875,"name":"210.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear descriptive naming simple structure and minimal method complexity. Code is well-formatted using proper generics. Methods are short and self-explanatory. Minor deduction for undefined parent class constant _METHOD_NAME and absence of method documentation. Overall very easy to comprehend within its Sharepoint integration framework context.","tokens":2621,"name":"125.jsnp"}
{"score":"90","reasoning":"Simple custom exception class with clear naming and standard structure. Minimal code complexity ensures high readability. Missing closing brace appears to be snippet truncation. Lacks additional constructors and detailed documentation but serves its purpose effectively.","tokens":1001,"name":"182.jsnp"}
{"score":"88","reasoning":"Code demonstrates clear delegation pattern with descriptive method names. Fully qualified class names reduce readability slightly. Parameter names are intuitive. Lack of Javadoc comments is a minor drawback but method signatures are self-explanatory. Overall structure is clean and follows Java conventions.","tokens":2350,"name":"214.jsnp"}
{"score":"55","reasoning":"Code suffers from poor exception handling with empty catch block silently swallowing errors. Contains magic numbers 90 and 1000 and hardcoded XPath string without constants or comments making maintenance difficult. Loop structure is unclear without explanation. While naming is decent and structure is simple these anti-patterns significantly hinder readability and debugging.","tokens":1420,"name":"219.jsnp"}
{"score":"65","reasoning":"Code uses outdated underscore naming convention reducing modern readability. Unused _myscrolledPanel field creates confusion. Simple structure and short methods aid comprehension. Missing Override annotations and incomplete javadoc comments. Inconsistent naming pattern. Null initialization is redundant. Overall understandable but shows legacy style issues and minor inconsistencies that hinder clarity.","tokens":2381,"name":"147.jsnp"}
{"score":"25","reasoning":"Code snippet lacks context being a fragment of a larger switch statement. Contains empty exception handling which swallows errors silently. Uses hardcoded XPaths with magic indices and timeout values making it brittle. Implements poor control flow with label-based state management and Thread.sleep. No comments explain intent. Overall structure is difficult to follow and maintain.","tokens":2312,"name":"121.jsnp"}
{"score":"65","reasoning":"Code has clear structure and descriptive method names but suffers from copy-paste errors. Logger and StringManager incorrectly reference DeleteAliasAction.class instead of AliasAction.class creating confusion. The i18n key also uses wrong class name. These inconsistencies reduce maintainability despite simple overall design.","tokens":1191,"name":"137.jsnp"}
{"score":"68","reasoning":"Code snippet shows simple iteration logic converting models to SOAP format. However it lacks method signature and variable declarations limiting context. The empty constructor with inline braces reduces readability. Overall structure is incomplete making full comprehension difficult despite clear core logic.","tokens":1268,"name":"171.jsnp"}
{"score":"40","reasoning":"The code suffers from poor readability due to repetitive exception handling logic, non-standard naming conventions with underscores, and heavy reliance on Liferay-specific proxy patterns requiring deep framework knowledge. Fully qualified class names create verbosity while magic method key numbers obscure intent. The exception handling is convoluted with misleading error messages. Although methods are short and consistently structured, significant domain expertise is needed to comprehend the transaction test scenarios.","tokens":1893,"name":"165.jsnp"}
{"score":"25","reasoning":"Code fragment shows poor readability due to empty catch block swallowing all exceptions, cryptic magic XPath string without explanation, inconsistent indentation, hardcoded Thread.sleep, and lack of context. These anti-patterns make debugging difficult and intent unclear. The code violates basic exception handling principles and modern Selenium best practices, severely impacting comprehension.","tokens":1360,"name":"124.jsnp"}
{"score":"96","reasoning":"The interface demonstrates excellent readability with clear, self-documenting method names following Java conventions. Methods are logically grouped by functionality source vs destination sessions. The design is simple and focused with no unnecessary complexity. Documentation is minimal but adequate the class-level Javadoc provides context and method names are explicit enough to require little explanation. Minor improvement could include more detailed method-level documentation for completeness.","tokens":1568,"name":"200.jsnp"}
{"score":"83","reasoning":"Clear variable names and straightforward logic make this easy to comprehend. The repetitive date handling pattern is a minor maintainability concern. Null/empty string check is overly verbose. The apparent typo in passwordPolicyPolicyCacheModel.name is distracting. Overall structure is simple and readable but would benefit from refactoring to reduce duplication.","tokens":2762,"name":"142.jsnp"}
{"score":"78","reasoning":"Java Swing code creating a labeled text field panel. Uses clear BorderLayout structure with descriptive Hungarian notation variable names. Internationalization comment is functional but cryptic. Main readability issue is external dependencies: txtName, s_stringMgr and pnlEdit are not locally declared requiring context lookup. Overall straightforward flow but dated conventions and external references reduce comprehension.","tokens":1076,"name":"196.jsnp"}
{"score":"35","reasoning":"Code snippet shows poor readability due to empty catch block swallowing exceptions silently, missing loop context making break statement unclear, magic number 1000 without explanation, and uses deprecated Selenium locator syntax. The polling pattern is understandable but implemented with bad practices that hinder debugging and maintenance. Overall structure is incomplete and error handling is inadequate.","tokens":1177,"name":"218.jsnp"}
{"score":"88","reasoning":"The code demonstrates good readability with clear method naming conventions and comprehensive Javadoc documentation for most methods. The parameter and return descriptions are explicit. However the setCompanyId method lacks Javadoc comments creating inconsistency. The interface structure is straightforward and easy to understand despite this single oversight.","tokens":1176,"name":"130.jsnp"}
{"score":"35","reasoning":"Code snippet is incomplete and lacks context. Non-standard underscore naming conventions violate Java style guidelines. Poor indentation makes block structure unclear. Missing class definition and method signatures prevent understanding of overall design. Simple individual statements are readable but the fragmentary nature severely impacts comprehension. No comments or documentation provided.","tokens":2917,"name":"132.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability with clear naming conventions and simple structure. The ProxyResponse class is a straightforward data carrier with intuitive getter/setter methods. The hasError() method is slightly verbose using explicit if-else instead of a direct return statement, but this is a minor issue. Overall, the code is well-organized, follows JavaBean patterns, and is immediately comprehensible to any Java developer.","tokens":1327,"name":"163.jsnp"}
{"score":"50","reasoning":"The code suffers from excessive fully qualified class names creating verbose lines, nested try-catch blocks that complicate flow, and cryptic parameter type array references. While variable names are clear and the pattern is consistent, the Liferay-specific remote invocation pattern requires domain knowledge. The lack of comments and reliance on magic numbers for parameter types further reduces comprehension for maintainers unfamiliar with this architecture.","tokens":1363,"name":"162.jsnp"}
{"score":"85","reasoning":"Clear method names and variables make logic easy to follow. However, significant code duplication reduces maintainability. The if-else if structure halts validation after first error, which may be unclear. Minor formatting variance. Readable but needs refactoring.","tokens":1785,"name":"206.jsnp"}
{"score":"30","reasoning":"Code suffers from inconsistent indentation making control flow unclear. Empty catch block silently suppresses exceptions which is poor practice. Magic number 1000 lacks context. String literal split awkwardly across lines. Overall structure suggests polling pattern but implementation is confusing and lacks comments. Requires significant cleanup for maintainability.","tokens":1125,"name":"143.jsnp"}
{"score":"65","reasoning":"The code follows a standard test pattern but suffers from incomplete methods testUpdateNew does nothing meaningful and testUpdateExisting is cut off. Repetitive setter calls reduce readability. Heavy reliance on undefined helper methods nextLong randomString etc. makes comprehension harder without context. Naming is mostly clear but testUpdateNew is misleading. Overall structure is understandable but lacks self-contained clarity.","tokens":1194,"name":"120.jsnp"}
{"score":"25","reasoning":"Code employs goto-like while-switch-label anti-pattern severely obscuring control flow. Contains magic values, empty exception handling, duplicated calls, and cryptic infinite loop timeout. No comments or meaningful abstraction. Mixes low-level Selenium operations directly with test logic making intent unclear. Very difficult to understand or maintain.","tokens":1982,"name":"205.jsnp"}
{"score":"60","reasoning":"Excessive indentation suggests problematic deep nesting. Method signature uses non-standard line breaks reducing scanability. Mixed naming conventions (snake_case peer_ip) violate Java standards. While method and parameter names are semantically clear the formatting inconsistencies significantly hinder readability.","tokens":1254,"name":"117.jsnp"}
{"score":"65","reasoning":"Clear Swing test structure with good variable names but suffers from missing import for SQLAliasConnectionProperties, minimal Javadoc, excessive whitespace, and odd method ordering. Core logic is understandable but compilation errors and lack of context reduce comprehension.","tokens":1566,"name":"123.jsnp"}
{"score":"70","reasoning":"Code fragment shows simple conditional logic and standard getter. Lacks full context making comprehension incomplete. Uses unconventional underscore prefix for _value field. Exception handling is clear but basic. Overall structure is straightforward but would benefit from better naming conventions and surrounding context for full understanding.","tokens":994,"name":"109.jsnp"}
{"score":"70","reasoning":"Snippet demonstrates excellent header readability with organized imports and clear package structure. However, it contains only copyright, package, and imports - no class definition or implementation code. This severe incompleteness prevents evaluating actual logic readability, method design, or architectural patterns. Score reflects high quality for visible portion but cannot assess full code comprehension without substantive content.","tokens":2078,"name":"134.jsnp"}
{"score":"82","reasoning":"Clean wrapper pattern with clear delegation logic. Method names are descriptive and implementation is concise. Major readability issue is missing field declarations requiring inference. Minor issues include no comments and inconsistent parameter line breaks. Null reset behavior in setAuthToken is straightforward. Overall easily comprehensible for pattern-aware developers.","tokens":1807,"name":"139.jsnp"}
{"score":"75","reasoning":"Clean Java syntax following standard conventions. Annotations are descriptive but require Eclipse Sapphire knowledge. Minimal Javadoc only shows author. Incomplete snippet limits assessment. Good naming clarity but lacks context for general developers.","tokens":1181,"name":"179.jsnp"}
{"score":"35","reasoning":"Code snippet shows repetitive permission updates with magic numbers and strings lacking context. Inconsistent formatting and missing comments reduce readability. The incomplete fragment structure and abrupt ending with unrelated database code make comprehension difficult. While method names are clear, the overall structure needs refactoring and documentation.","tokens":1667,"name":"127.jsnp"}
{"score":"68","reasoning":"Clear structure and mostly good Javadoc, but uses raw Map type without generics which severely impacts type safety and comprehension. Inconsistent documentation (getName() lacks Javadoc). Simple interface but shows dated practices like \u0027I\u0027 prefix. Overall understandable but has notable flaws preventing higher score.","tokens":1282,"name":"216.jsnp"}
{"score":"95","reasoning":"Excellent readability with clear method signatures, descriptive parameter names, and consistent patterns. Minor naming inconsistency between URL/Url conventions is negligible. The snippet is concise and immediately comprehensible.","tokens":942,"name":"195.jsnp"}
{"score":"50","reasoning":"Simple structure with clear package and class names but severely lacks documentation encapsulation and context. The incomplete nature makes comprehension difficult despite basic readability.","tokens":1833,"name":"128.jsnp"}
{"score":"75","reasoning":"Clear method names and consistent structure but verbose fully qualified names reduce readability. Overloaded methods are well organized. Transactional annotations are consistently applied. Exception handling is uniform. Standard enterprise Java interface with moderate readability for its domain.","tokens":2101,"name":"144.jsnp"}
{"score":"75","reasoning":"Repetitive test suite registration with consistent method calls. Naming is partially descriptive but MB abbreviation and inconsistent number letter pattern reduce clarity. Simple sequential structure violates DRY principle. No comments explain organization or dependencies. Functional but tedious to maintain. Moderate readability that could improve via loops or configuration.","tokens":2518,"name":"155.jsnp"}
{"score":"65","reasoning":"The code uses verbose repetitive patterns reducing readability. String building manually appends fields instead of modern approaches like String.format(). Null checks are duplicated. While naming is clear and logic simple, boilerplate obscures intent. The hardcoded StringBundler capacity is fragile and maintenance-prone.","tokens":1513,"name":"197.jsnp"}
{"score":"15","reasoning":"Snippet begins with invalid syntax from a truncated line causing immediate confusion. Uses magic number 6 and cryptic repeated string identifiers. Poor formatting includes irregular indentation and unnecessary blank lines. Control flow with continue lacks context. No comments or meaningful names make comprehension extremely difficult.","tokens":1701,"name":"129.jsnp"}
{"score":"88","reasoning":"Clean well documented utility class with clear method names and logical structure. Minor readability issues include legacy Enumeration type usage slightly abbreviated variable name ecP and unconventional parameter formatting. Javadoc comments are thorough and helpful. Overall logic is straightforward and easy to comprehend for developers familiar with elliptic curve cryptography.","tokens":1628,"name":"122.jsnp"}
{"score":"68","reasoning":"Code has simple structure and clear control flow but suffers from unconventional return syntax with parentheses, unexplained null parameters, magic string Tunnel, and unnecessary whitespace. Variable naming is decent but the punch method\u0027s intent is unclear without domain knowledge. Overall moderately readable but could be improved with constants and better formatting.","tokens":1170,"name":"185.jsnp"}
{"score":"50","reasoning":"Code suffers from inconsistent naming conventions including Hungarian notation lSequenceNo and mixed ID/Id usage. Contains undocumented magic number 32767. Typo in PlaformMessage. Method sendAZID lacks clear purpose. Missing context for fields like parameters contentNetworkID. Javadoc is incomplete. While methods are short and focused these issues significantly hinder readability.","tokens":1776,"name":"108.jsnp"}
{"score":"80","reasoning":"Well-structured code with clear variable names and logical flow. The get method handles null keys gracefully and uses standard locale resolution pattern. Debug logging provides useful diagnostics. Minor issues: debug message has mismatched brace and potential NPE if FacesContext is null. isEmpty and keySet clearly indicate unsupported operations. Overall easy to comprehend for Java developers.","tokens":2150,"name":"154.jsnp"}
{"score":"55","reasoning":"Underscore prefixes on private methods violate Java conventions. Critical misspelling of _proccessAttributes causes confusion. Misleading variable name optionsJSON adds ambiguity as it is a HashMap not JSON. Use of raw type Collections.EMPTY_LIST is poor practice. Logic in _isValidAttribute uses double negation reducing clarity. Methods are reasonably sized and variable names are mostly descriptive but these issues significantly impact comprehension.","tokens":3402,"name":"211.jsnp"}
