{"score":"92","reasoning":"Clean import block following Java conventions with logical grouping of Liferay portal kernel utilities and standard Java collections. Alphabetically ordered within groups, descriptive class names, and clear separation between third-party and core Java packages. High readability but limited scope prevents perfect score.","tokens":1094,"name":"208.jsnp"}
{"score":"62","reasoning":"Code shows basic test structure with clear naming conventions. Lacks completeness making full assessment difficult. Contains magic string URL, minimal documentation, and no visible assertions. Class visibility modifier omitted. Understandable for domain experts but needs comments, constants for URLs, and complete implementation. Overall moderate readability with significant improvement potential.","tokens":1139,"name":"191.jsnp"}
{"score":"72","reasoning":"Code demonstrates consistent formatting and clear method naming with proper null validation. However, the snippet is incomplete with missing braces, lacks comments, and requires external context about portlet APIs. Dependencies like EventImpl, QName, and PortalUtil are not self-explanatory, reducing comprehension for unfamiliar readers.","tokens":1319,"name":"131.jsnp"}
{"score":"35","reasoning":"Code suffers from inconsistent indentation mixing tabs and spaces, misaligned statements, and poor formatting. Contains questionable practices like layout changes in paintComponent and inconsistent revalidate calls. Lacks comments, context, and uses non-standard underscore naming. Overall structure makes maintenance difficult.","tokens":1394,"name":"170.jsnp"}
{"score":"65","reasoning":"Code snippet lacks context with incomplete first line and abrupt ending. Inconsistent indentation hampers visual flow. However variable names are descriptive and constants are used appropriately. Heavy reliance on static utility classes is typical for the framework but obscures dependencies. Overall structure follows standard portlet patterns but needs better formatting and completion for full comprehension.","tokens":1506,"name":"186.jsnp"}
{"score":"55","reasoning":"Fragmented first line reduces comprehension. The if-block has excessive method call nesting and inline casting that hinders readability. Good constant usage and clear naming are positives but dont offset structural issues. Extracting variables would improve clarity significantly.","tokens":1368,"name":"133.jsnp"}
{"score":"15","reasoning":"Empty catch block silently swallows all exceptions making debugging impossible and flow unclear. Poor indentation obscures structure. Magic number 1000 lacks context. Hardcoded XPath is brittle. Awkward line break in method call. No comments. Critical anti-patterns severely damage readability and maintainability.","tokens":1379,"name":"174.jsnp"}
{"score":"58","reasoning":"Code uses BETTER_THAN macro hiding comparison logic reducing clarity. Variables posBetter negBetter and dif are undefined in scope. Magic numbers 0.2f and 0.4f lack context. Bias update formulas are cryptic without domain knowledge. Structure is clear but reliance on external definitions and macro hurts self-contained readability. Variable names are mostly descriptive.","tokens":1551,"name":"112.jsnp"}
{"score":"68","reasoning":"Code has descriptive naming and clear intent but suffers from inconsistent indentation and formatting issues. The snippet starts and ends mid-block reducing comprehension. Nested conditionals could be flattened. Heavy static utility usage is idiomatic for Liferay but impacts testability. Overall structure is understandable despite these flaws.","tokens":1836,"name":"103.jsnp"}
{"score":"40","reasoning":"Code uses raw types ArrayList and List without generics reducing type safety and readability. Variable names are inconsistent and unclear dm am lp. Mixed concerns in single method creating UI parameters listeners and state management. Code duplication in adding elements to multiple collections. Uses outdated anonymous inner class syntax. Indentation is inconsistent. Some helpful comments exist but overall structure is poor.","tokens":1982,"name":"106.jsnp"}
{"score":"70","reasoning":"Code has clear variable names and logical flow but suffers from unconventional formatting with line breaks in class/method declarations. Wildcard imports hide dependencies. Old-fashioned naming like class_mon reduces clarity. Overall structure is understandable but style choices detract from immediate comprehension.","tokens":1803,"name":"151.jsnp"}
{"score":"25","reasoning":"Code has critical readability flaws. Empty catch block silently suppresses exceptions making debugging extremely difficult. Lacks context about loop structure and timeout mechanism. Generic XPath locator provides no semantic meaning. No comments explain intent. Fragile structure violates test automation and error handling best practices.","tokens":1547,"name":"192.jsnp"}
{"score":"75","reasoning":"Standard Java getters and equals/hashCode implementations. Simple structure with familiar patterns and Javadoc annotations. Inconsistent brace formatting, braceless if statements, unexplained magic numbers, and outdated underscore prefixes reduce clarity. Readable for experienced developers but stylistic inconsistencies prevent higher score.","tokens":1783,"name":"150.jsnp"}
{"score":"62","reasoning":"Descriptive naming but poor readability due to non-idiomatic polling loop with magic numbers 90 and 1000, empty catch block ignoring exceptions, and no comments explaining wait strategy. Infinite for loop syntax confuses junior developers. Modern WebDriverWait would improve clarity. Functional but needs domain knowledge to comprehend.","tokens":1782,"name":"212.jsnp"}
{"score":"65","reasoning":"Code has partial Javadoc for the main constructor but the default constructor with five nulls lacks explanation. Parameter naming uses outdated \u0027a\u0027 prefix. The md parameter is undocumented. Getter/setter Javadoc is minimal and redundant. Inconsistent indentation hurts readability. Overall structure is understandable but requires parent class context and has documentation gaps.","tokens":1958,"name":"221.jsnp"}
{"score":"65","reasoning":"Raw type Map reduces type safety. Unclear variable name sID. Commented-out code and unexplained magic number -1. Inefficient containsKey-then-get pattern. Incomplete Javadoc. Class structure is clear and caching intent understandable but overall readability is hampered by these issues requiring moderate effort to comprehend.","tokens":2003,"name":"166.jsnp"}
{"score":"40","reasoning":"Poor readability due to generic exception handling swallowing errors, potential NullPointerException risks, incomplete method signatures, and inconsistent structure. Lazy initialization is not thread-safe and error handling leaves objects in uncertain states. Variable names are descriptive but control flow is confusing with early returns, making maintenance difficult.","tokens":1989,"name":"101.jsnp"}
{"score":"30","reasoning":"Incomplete snippet missing loop declaration creates context confusion. Empty catch blocks swallow exceptions severely hindering debugging. Magic numbers lack explanation. Uses deprecated Selenium RC API with inefficient Thread.sleep polling instead of modern explicit waits. Hard-coded strings and inconsistent locators reduce maintainability. Repetitive structure with unclear timeout handling makes flow difficult to comprehend.","tokens":2059,"name":"146.jsnp"}
{"score":"45","reasoning":"Code shows repetitive exception handling pattern violating DRY principle. Inconsistent formatting and non-standard naming with underscores reduce readability. Logging syntax _log.error(e, e) is ambiguous and likely incorrect. Exception handling loses stack trace by only passing e.getMessage(). Simple structure but poor implementation practices make it hard to maintain and understand.","tokens":1295,"name":"140.jsnp"}
{"score":"80","reasoning":"Code demonstrates clear naming conventions and concise logic. Methods are well-structured and purposeful. However, the first method lacks a signature, hindering immediate comprehension. Minor formatting inconsistency in the for-loop. Overall, highly readable despite the incomplete snippet.","tokens":2182,"name":"153.jsnp"}
{"score":"62","reasoning":"Constructor with commented unused parameter creates confusion. getIcon method uses nonstandard formatting with line break before closing parenthesis. Class and method names are clear. Hardcoded strings and missing context limit full comprehension. Simple logic aids understanding but code quality issues reduce readability.","tokens":2093,"name":"181.jsnp"}
{"score":"75","reasoning":"Clear class name and simple structure. Uses an unconventional interface pattern for i18n strings which may confuse developers unfamiliar with this idiom. Interface name violates Java naming conventions. Static variable prefix is dated Hungarian notation. However constants are well-named and code is well-organized overall making it reasonably readable for framework users.","tokens":1391,"name":"172.jsnp"}
{"score":"88","reasoning":"Java method signatures are clear with descriptive names following conventions. Javadoc exists for getter but is missing for setter reducing completeness. Minor documentation typo. Code is minimal and easily comprehensible for developers familiar with Java annotations and interface patterns.","tokens":1154,"name":"168.jsnp"}
{"score":"88","reasoning":"Clean JUnit test suite structure with descriptive naming. Code follows standard patterns and is immediately understandable. Minor deductions for incomplete snippet and minimal documentation. Method clearly aggregates LoginTests and TagsTestPlan into a test suite. Well-formatted with proper indentation. The class name is lengthy but informative. Overall excellent readability for a test harness class.","tokens":998,"name":"176.jsnp"}
{"score":"15","reasoning":"Contains syntax errors and confusing goto-like control flow with label/case statements. Excessive magic strings, XPath expressions and poor naming make it hard to follow. Duplicated code patterns and complex regex assertion reduce clarity. Structure is incomplete and unmaintainable.","tokens":1701,"name":"193.jsnp"}
{"score":"95","reasoning":"Standard JavaBean methods with clear naming and consistent structure. Javadoc comments are helpful if repetitive. Formatting is clean despite minor line-wrap variation. Trivial implementation ensures immediate comprehension. Excellent readability.","tokens":1531,"name":"136.jsnp"}
{"score":"38","reasoning":"Code suffers from severe repetition violating DRY principle with multiple identical patterns. Contains magic strings hardcoded locators platform specific paths and numeric timeouts. Uses brittle Thread.sleep loop with empty exception handler. No abstraction helper methods or comments. Long lines reduce scanability. While functional it requires significant effort to understand and maintain making it poor for collaborative development.","tokens":1972,"name":"198.jsnp"}
{"score":"65","reasoning":"Variable names are descriptive and structure is logical but updateFileEntry call with 14 parameters severely impacts readability. The null parameter and ambiguous short variable is are unclear without method signature context. While formatting attempts to improve clarity the parameter overload remains a significant barrier. Framework familiarity helps but does not justify the complexity.","tokens":1502,"name":"135.jsnp"}
{"score":"35","reasoning":"Code uses outdated Selenium RC API with brittle XPath locators and magic numbers. Poor formatting inconsistent indentation and incomplete structures make it hard to follow. The label and continue pattern is anti-pattern. No comments explain intent. Hardcoded waits and mysterious helper functions reduce clarity. Functional but severely lacking in maintainability and comprehension.","tokens":1679,"name":"157.jsnp"}
{"score":"65","reasoning":"Code shows repetitive setter calls violating DRY principle making it verbose and hard to maintain. The compareTo method is unnecessarily verbose with redundant variable assignment and only compares names which may be incomplete. Clear naming is overshadowed by poor structural patterns.","tokens":1414,"name":"183.jsnp"}
{"score":"40","reasoning":"Code suffers from severe repetition with hardcoded locators and magic numbers. Empty catch block swallows exceptions. No abstraction or comments make maintenance difficult. Sequential flow is clear but verbose. Follows outdated Selenium RC patterns instead of modern Page Object Model.","tokens":1587,"name":"167.jsnp"}
{"score":"88","reasoning":"Excellent descriptive naming for class, method, and parameters clearly indicates Command pattern purpose. Logic is simple and straightforward. Deducts points for missing field declarations (oldServerManagerContextPath, serverManagerContextPath) requiring external context, minor spacing inconsistencies around parentheses, and lack of comments. Overall highly readable with minimal cognitive load.","tokens":1180,"name":"104.jsnp"}
{"score":"55","reasoning":"The code suffers from severe duplication of nullcheck and logging logic across methods reducing readability. Inconsistent return values null vs emptyList for same condition is confusing. The incomplete last method hampers full evaluation. However method names are clear and individual method logic is simple. The repeated pattern makes maintenance harder and obscures the actual business logic.","tokens":2213,"name":"116.jsnp"}
{"score":"20","reasoning":"Code snippet lacks context showing switch statement structure. Uses cryptic variable names like suborganization2Present and magic numbers for labels. Heavy reliance on fragile XPath expressions and hardcoded element IDs. Contains duplicated patterns of selenium operations without abstraction. Control flow with continue and case labels is unclear. No comments explain intent. Overall poor readability and maintainability.","tokens":2156,"name":"152.jsnp"}
{"score":"35","reasoning":"Uses archaic goto-like while-switch-label pattern making flow control extremely hard to follow. Contains empty catch block that hides errors, magic numbers without naming, and Thread.sleep for waits. No separation of concerns between Selenium operations and test logic. Poor readability and maintainability by modern Java standards.","tokens":2144,"name":"102.jsnp"}
{"score":"75","reasoning":"The code demonstrates decent readability with descriptive method and variable names following standard Java conventions. However excessive blank lines in addRatingsEntry method reduce density and clarity. The conditional early return in testResetOriginalValues is questionable test design. Framework specific APIs require external knowledge but are used consistently. Overall structure is logical for test code despite minor formatting issues.","tokens":2174,"name":"204.jsnp"}
{"score":"50","reasoning":"Poor readability due to antiquated polling loop, silent exception swallowing, magic numbers, and verbose package naming. Descriptive class/method names are overshadowed by outdated patterns. The infinite for loop with manual timeout is confusing versus modern explicit waits, making maintenance difficult.","tokens":1461,"name":"209.jsnp"}
{"score":"30","reasoning":"Malformed method declaration missing return type and access modifier. Inconsistent formatting with irregular indentation. Javadoc comment is incomplete missing return description. Method signature split across lines reduces readability. First method lacks any documentation. Overall poor structure and clarity.","tokens":1279,"name":"126.jsnp"}
{"score":"88","reasoning":"Clear method names and consistent structure make this highly readable. Each method follows a predictable pattern: permission check then operation. Good separation of concerns and clean formatting. Minor deductions for Liferay-specific className/classPK pattern requiring domain knowledge, unused List import, and lack of method-level documentation.","tokens":2106,"name":"175.jsnp"}
{"score":"58","reasoning":"Code suffers from verbose fully-qualified names lacking imports. Inconsistent API design provides indexed accessors only for archiveFiles, not options, creating confusion. Missing Javadoc for non-standard get/set methods reduces clarity. Overall structure is basic but these issues hinder readability and maintainability.","tokens":1814,"name":"188.jsnp"}
{"score":"35","reasoning":"The code contains major readability anti-patterns: magic numbers without context, brittle XPath locators, empty catch blocks that hide failures, duplicated code blocks, and unexplained Thread.sleep usage. No comments explain the test intent. While the basic Selenium structure is present, these issues severely hinder comprehension and maintainability.","tokens":1754,"name":"145.jsnp"}
{"score":"40","reasoning":"Inconsistent formatting with misaligned parameters and mixed naming conventions (camelCase vs snake_case). Poor Javadoc with empty parameter tags and misplaced inline comments. Cryptic method names with numeric suffix reduce clarity. Basic structure is understandable but maintenance would be difficult due to these issues.","tokens":1473,"name":"201.jsnp"}
{"score":"35","reasoning":"Outdated Selenium RC API with hardcoded magic values complex XPaths and empty catch blocks. Uses inefficient Thread.sleep polling and confusing switch-case label control flow. Inconsistent formatting and lack of context severely hinder readability. Anti-patterns throughout make maintenance difficult.","tokens":2205,"name":"107.jsnp"}
{"score":"58","reasoning":"Code lacks surrounding context making flow unclear. Inconsistent formatting with missing spaces around operators. Redundant else block sets default boolean value. Inefficient array manipulation via repeated addStringArrays calls starting from empty array. Magic constants used without explanation. No comments explaining business logic. Variable names are descriptive but overall structure is hard to follow due to these issues.","tokens":1663,"name":"187.jsnp"}
{"score":"60","reasoning":"The code shows clear import statements but suffers from overly verbose Javadoc with unnecessary HTML tags and confusing placeholder text Foobar that contradicts the actual project name. The license text is excessively long for a code snippet, making quick comprehension difficult. While the structure follows Java conventions, the bloat and inconsistency reduce readability significantly.","tokens":1651,"name":"190.jsnp"}
{"score":"58","reasoning":"Code snippet shows typical Liferay persistence layer patterns with inconsistent formatting and incomplete context. Variable naming is misleading where sql holds JPQL and names like q and list are overly terse. Verbose casting and unclear boolean parameters reduce clarity. Try-catch-finally structure is sound but the abrupt ending breaks comprehension. Readable for Liferay developers but challenging for others due to framework-specific conventions and missing context.","tokens":1654,"name":"202.jsnp"}
{"score":"88","reasoning":"Clean JUnit test suite structure with descriptive naming. Method clearly aggregates setup, test and teardown classes in logical order. Follows standard patterns making intent obvious. Minor deductions for incomplete snippet missing return statement and slightly verbose class name. Overall highly readable with self-documenting code.","tokens":1063,"name":"199.jsnp"}
{"score":"88","reasoning":"Clean constants class with descriptive UPPER_SNAKE_CASE names and good formatting. Lacks class-level documentation explaining purpose. Incomplete snippet missing closing brace. Simple structure makes it highly readable despite minor gaps.","tokens":1129,"name":"189.jsnp"}
{"score":"82","reasoning":"Clean JUnit test suite structure with clear naming conventions. Code is easy to comprehend but incomplete missing closing braces. Lacks explanatory comments about the relationship between PortletTestPlan and UnitTestPlan. Minimalist implementation provides limited context for full understanding.","tokens":1490,"name":"207.jsnp"}
{"score":"30","reasoning":"Code lacks context missing switch statement or loop label. Uses magic numbers and strings including cryptic ID _125_status. Contains empty catch block swallowing exceptions. Implements manual timeout loop with Thread.sleep instead of proper waits. Variable names are generic. Relies on deprecated Selenium RC API. Control flow with continue and case label is confusing without surrounding structure. Overall poor readability and maintainability.","tokens":1484,"name":"217.jsnp"}
{"score":"50","reasoning":"Code shows inconsistent formatting with awkward line breaks in method signatures. Variable names like find, match, and value are vague. Regex patterns are complex and lack clear documentation. Commented-out System.out.println statements reduce clarity. The snippet ends abruptly with incomplete getFileContent method. While methods are small and some javadoc exists, overall readability suffers from poor naming conventions, magic strings, and unconventional formatting choices.","tokens":1758,"name":"177.jsnp"}
{"score":"70","reasoning":"The code has clear structure and descriptive variable names following a clean test pattern. However, the recurrence parameters (FRIDAY, 3, 1) are opaque without context or comments, and the method name is generic. Heavy reliance on inherited methods/constants from the parent class reduces standalone comprehension. Calendar time values lack explanatory context. Overall readable for familiar developers but cryptic for newcomers.","tokens":1825,"name":"159.jsnp"}
{"score":"30","reasoning":"Very poor indentation and formatting with awkward line breaks. Contains magic numbers and duplicate strings. Unicode character is unclear. Incomplete logic with mysterious label assignment. Method names lack clarity. Fragmented structure makes comprehension difficult.","tokens":1335,"name":"149.jsnp"}
{"score":"45","reasoning":"Non-standard line breaks between return types and method names violate Java conventions. While method names are clear, the unusual formatting reduces scanability and increases cognitive load by forcing readers to mentally connect separated elements. This anti-pattern makes code harder to parse quickly and would confuse developers expecting standard formatting. Simple but significant readability issue.","tokens":1089,"name":"158.jsnp"}
{"score":"35","reasoning":"Code snippet lacks context starting mid-condition. Contains empty catch blocks swallowing exceptions which hinders debugging. Nested try-catch blocks and complex logic flow reduce clarity. Missing try-with-resources for InputStream. Magic boolean parameters lack explanation. Inconsistent indentation makes structure hard to follow. Overall poor error handling and fragmented structure significantly impact readability.","tokens":1663,"name":"180.jsnp"}
{"score":"35","reasoning":"Severe indentation inconsistencies with mixed tabs and spaces. Incomplete context missing method signature. Poor formatting of multi-line string concatenation. Inconsistent brace placement. While test names are descriptive and logic is simple, the formatting issues significantly hinder readability. Lack of documentation and trailing whitespace further reduce clarity.","tokens":1440,"name":"178.jsnp"}
{"score":"40","reasoning":"Code uses outdated Selenium patterns with a confusing infinite loop and manual counter for timeout logic. The empty catch block silently suppresses exceptions, hiding potential failures. Magic number 90 lacks context. While class/method names are clear, the implementation is hard to follow and maintain. Modern explicit waits would be far more readable and reliable.","tokens":1339,"name":"203.jsnp"}
{"score":"35","reasoning":"Code contains multiple readability issues: magic numbers without context, duplicated brittle XPath expressions, empty exception handling that hides errors, unconventional infinite loop with break, inconsistent indentation, and unclear RuntimeVariables usage. The sleep-based waiting approach is inefficient. While the basic intent can be discerned, these anti-patterns make maintenance difficult and the flow hard to follow. Lacks comments and proper structure.","tokens":1649,"name":"215.jsnp"}
{"score":"25","reasoning":"Poor readability due to empty catch block swallowing exceptions silently, generic XPath locator, magic number sleep value, and missing loop context. Uses Thread.sleep instead of proper Selenium waits. Inconsistent indentation reduces clarity. Overall structure makes debugging difficult and intent unclear.","tokens":1091,"name":"105.jsnp"}
{"score":"40","reasoning":"Code uses non-idiomatic infinite polling loops with magic numbers (90, 1000, 30000) for timeouts. Empty catch block hides exceptions. Hardcoded locators and duplicate patterns reduce maintainability. Lacks comments and uses outdated Selenium RC style waits, making intent unclear despite simple structure.","tokens":1482,"name":"220.jsnp"}
{"score":"58","reasoning":"Code shows inconsistent exception handling using instanceof checks on generic Exception instead of multiple catch blocks. Contains duplicated error handling logic across methods and uses exceptions for control flow. Lacks context as snippet starts mid-try-block. Magic strings and nested conditionals reduce clarity. While functional, these patterns decrease maintainability and readability significantly.","tokens":1653,"name":"111.jsnp"}
{"score":"88","reasoning":"Clear naming and consistent setter pattern make this easy to understand. Logical property grouping enhances readability. Minor deductions for repetitive boilerplate and occasional awkward line breaks but overall structure is straightforward. The simple conditional block is clear and well placed.","tokens":1845,"name":"148.jsnp"}
{"score":"30","reasoning":"Code is incomplete: missing method signature and closing braces. Logic is counterintuitive - unregistering different MBean when cached object is null. Inconsistent naming convention with underscores. Lacks context for proper comprehension.","tokens":1722,"name":"156.jsnp"}
{"score":"30","reasoning":"Code exhibits severe formatting issues with inconsistent line breaks and indentation. First method appears malformed missing name and return type. Empty method bodies lack explanatory comments. notSupported() calls provide no context. While method names are descriptive, overall structure is confusing and difficult to comprehend without additional documentation.","tokens":1352,"name":"138.jsnp"}
{"score":"72","reasoning":"Clear package structure and basic Javadoc provide context. Standard Java syntax is readable. However, verbose GPL header adds noise, interface name DownloadTypeIncomplete is somewhat ambiguous, and documentation is minimal leaving usage unclear. Overall decent but could be improved with better naming and more detailed comments.","tokens":1514,"name":"160.jsnp"}
{"score":"75","reasoning":"Clear method naming and parameter names make logic easy to follow. Good use of generics and consistent formatting. However, minimal Javadoc lacks method description and parameter details. The incomplete second method reduces overall comprehension. Service locator pattern introduces implicit dependencies. Code is readable but needs better documentation and completion.","tokens":1722,"name":"119.jsnp"}
{"score":"35","reasoning":"The snippet is incomplete and lacks context, making full comprehension difficult. It uses non-standard underscore prefixes for identifiers. The code starts mid-block and ends abruptly, showing method fragments only. While the visible logic is simple, readability suffers from missing structure, documentation, and non-adherence to Java naming conventions. Inconsistent indentation further reduces clarity.","tokens":1193,"name":"132.jsnp"}
{"score":"70","reasoning":"Simple interface methods with standard naming. Poor Javadoc quality (\u0027class p k\u0027 is awkward) and inconsistent documentation (only setter documented). PK abbreviation is common but unexplained. Clear structure but documentation flaws hinder comprehension for unfamiliar developers.","tokens":1506,"name":"141.jsnp"}
{"score":"88","reasoning":"Code demonstrates good readability with clear variable naming and consistent null-handling patterns for date conversion. Logical blocks are well-separated. Minor verbosity in string empty-check logic slightly reduces conciseness. Overall structure is straightforward and easy to comprehend, following common Java boilerplate patterns for model population. No complex logic or nested structures impede understanding.","tokens":1362,"name":"142.jsnp"}
{"score":"88","reasoning":"Well-documented Java interface with clear method signatures following standard cryptographic API patterns. Descriptive naming and comprehensive Javadoc comments explain purpose parameters and exceptions effectively. Minor readability deductions for inconsistent indentation a typo statge instead of stage and missing parameter description in one method. Overall highly comprehensible for developers familiar with crypto libraries.","tokens":1663,"name":"184.jsnp"}
{"score":"45","reasoning":"Class and method names contain cryptic 1 suffix. Uses manual timeout loop with magic number 90 instead of modern explicit waits. No constants or comments explain purpose. Incomplete snippet lacks context. Selenium commands are clear but overall structure follows outdated anti-pattern. Naming inconsistency and lack of abstraction reduce comprehension for maintainers.","tokens":1197,"name":"114.jsnp"}
{"score":"45","reasoning":"Code uses repetitive wait loops with magic numbers 90 and 1000 empty catch blocks hide exceptions hardcoded XPath locators reduce maintainability Thread.sleep usage is brittle no abstraction or comments make intent unclear sequence is linear but anti-patterns significantly hinder readability","tokens":1599,"name":"110.jsnp"}
{"score":"70","reasoning":"Code has clear Javadoc and descriptive naming but suffers from unconventional formatting. The split method signature across lines and inconsistent indentation reduce quick comprehension. The initial fragment lacks context, creating confusion. Overall structure is understandable but requires mental reconstruction.","tokens":996,"name":"118.jsnp"}
{"score":"35","reasoning":"Code exhibits poor readability due to silent exception swallowing via empty catch block magic numbers hardcoded XPaths and inconsistent formatting. The timeout loop pattern is nonstandard and duplicated. While functional intent can be discerned by experienced Selenium developers the code lacks clarity maintainability and modern best practices.","tokens":1966,"name":"113.jsnp"}
{"score":"65","reasoning":"The code uses outdated Hungarian notation with underscore prefixes reducing modern readability. Naming is inconsistent with unused _myscrolledPanel field. Methods are simple and focused but empty methods have redundant comments. Missing setter for _hint and incomplete interface implementation. Overall structure is clear but style issues and inconsistencies hinder comprehension.","tokens":1545,"name":"147.jsnp"}
{"score":"40","reasoning":"Poor formatting with inconsistent indentation and spacing. Variable naming violates Java conventions using snake_case and vague names like temp. Inefficient string concatenation in loop shows outdated practices. Logic is simple but obscured by style issues. The trailing separator comment is helpful but awkwardly placed. Incomplete final if statement adds confusion. Overall readability is significantly compromised by style violations and anti-patterns.","tokens":2590,"name":"115.jsnp"}
{"score":"35","reasoning":"Code snippet lacks context starting and ending abruptly. Contains empty catch block swallowing exceptions, magic numbers, hardcoded XPath strings, and confusing control flow with label/continue in switch-case. Poor variable naming and no comments make maintenance difficult. Appears auto-generated with poor readability practices.","tokens":1485,"name":"121.jsnp"}
{"score":"90","reasoning":"Code demonstrates high readability with clear naming conventions and focused method implementations. The class structure is simple and follows standard patterns. Methods are short and self-explanatory, though minimal documentation and reliance on parent class constants slightly reduce immediate comprehension. Overall flow is straightforward and easy to follow.","tokens":2437,"name":"125.jsnp"}
{"score":"55","reasoning":"Fragment lacks context: closing brace at start, undefined variable string and class Hex hinder understanding. Method signatures are clear but toString implementation is ambiguous. Inconsistent formatting. Missing dependencies and incomplete structure significantly reduce readability.","tokens":1244,"name":"169.jsnp"}
{"score":"35","reasoning":"Poor formatting with excessive inconsistent whitespace. Critical operator precedence bug in boolean condition makes logic unclear. Vague variable names like \u0027bit\u0027 and lack of comments hinder comprehension. Fragmented context and complex nested structure reduce readability significantly.","tokens":1921,"name":"164.jsnp"}
{"score":"92","reasoning":"Excellent readability with descriptive method names following Java conventions. Copy constructor and simple constant-returning getter are immediately understandable. The magic number 8 could be a named constant, but the method\u0027s clear intent minimizes confusion. Clean structure, minimal complexity, and self-documenting code make it highly comprehensible.","tokens":1661,"name":"213.jsnp"}
{"score":"35","reasoning":"Code has major readability flaws: syntax error on first line, repetitive magic XPaths and IDs, duplicated polling loops with empty exception handling, hard-coded platform paths, no comments or abstraction. The structure is brittle and requires deep domain knowledge to comprehend. Empty catch blocks hide potential failures making debugging difficult.","tokens":2201,"name":"173.jsnp"}
{"score":"85","reasoning":"Exception class is simple and follows Java conventions clearly. The explicit no-arg constructor is redundant but harmless. Javadoc is minimal but present. Structure is clean and immediately understandable for any Java developer, though functionality is very basic.","tokens":848,"name":"182.jsnp"}
{"score":"95","reasoning":"Clear method and parameter names follow Java conventions. Proper Javadoc documentation present. Simple one-line implementation is immediately understandable. Minor deduction for unconventional parameter line break and slightly redundant Javadoc, but overall excellent readability.","tokens":1179,"name":"161.jsnp"}
{"score":"90","reasoning":"Code demonstrates high readability with clear method names and parameters. Simple delegation pattern is easy to comprehend. Fully qualified class names add verbosity but do not obscure intent. Lacks import statements which would improve conciseness. Overall structure is clean and follows Java conventions.","tokens":2485,"name":"214.jsnp"}
{"score":"40","reasoning":"Code contains empty catch blocks that swallow exceptions making debugging difficult. Heavy use of magic numbers for timeouts and sleeps reduces readability. Duplicated loop logic violates DRY principle. Hardcoded element locators scattered throughout. No abstraction or comments to explain intent. Mixed wait strategies create confusion. While basic test flow is discernible, poor practices significantly hinder comprehension and maintainability.","tokens":1844,"name":"210.jsnp"}
{"score":"72","reasoning":"The code fragment shows clear variable naming and a straightforward for-each loop. However it lacks context making full comprehension difficult. The array conversion is verbose using pre-Java 11 syntax. The empty constructor appears disconnected without surrounding class structure. Overall logic is simple but the snippet is incomplete which hampers readability.","tokens":1127,"name":"171.jsnp"}
{"score":"95","reasoning":"The interface demonstrates excellent readability with clear descriptive method names following Java conventions. The structure is simple and logical grouping of related methods enhances comprehension. Minor deductions for redundant public modifiers and minimal class-level Javadoc. Overall highly understandable for any Java developer.","tokens":1397,"name":"200.jsnp"}
{"score":"20","reasoning":"Code suffers from severe readability issues: cryptic XPath selectors with absolute positions, duplicated wait loops, empty exception handlers, magic numbers, hardcoded test data, no comments or abstraction, and inconsistent formatting. First line has syntax error. Requires deep domain knowledge to understand intent. Extremely brittle and unmaintainable.","tokens":2925,"name":"194.jsnp"}
{"score":"38","reasoning":"Poor readability due to non-standard method naming with underscores, duplicated exception handling logic, lack of comments, verbose fully qualified names, and unclear purpose of proxy classes. The incomplete snippet and inconsistent return handling further reduce comprehension. Code structure is repetitive and could be refactored for clarity.","tokens":1924,"name":"165.jsnp"}
{"score":"30","reasoning":"Code contains severe anti-patterns that harm readability. Empty catch block silently swallows all exceptions making debugging impossible. Uses magic string and magic number without constants. Catches generic Exception instead of specific types. Lacks logging and comments. Loop context is missing from snippet. Intent appears to be polling for element presence but implementation obscures this purpose and hides errors.","tokens":1280,"name":"218.jsnp"}
{"score":"40","reasoning":"Poor readability due to silent exception swallowing, magic numbers 90 and 1000, unclear infinite loop structure, hardcoded XPath, and lack of comments. These anti-patterns hinder comprehension despite simple structure.","tokens":1733,"name":"219.jsnp"}
{"score":"25","reasoning":"Code lacks full context showing try loop structure. Empty catch block silently swallows all exceptions making debugging impossible. Magic XPath string with cryptic ID and unexplained sleep value. Inconsistent formatting. No comments clarifying polling intent. Poor readability and severe maintainability issues.","tokens":1562,"name":"124.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability with clear class and method naming following JavaBean conventions. The logic is simple and straightforward. Minor deductions for verbose hasError() implementation that could be more concise and missing field declarations in the snippet. Overall structure is clean and easily comprehensible for any Java developer.","tokens":1249,"name":"163.jsnp"}
{"score":"88","reasoning":"Code demonstrates excellent readability with clear naming conventions and comprehensive Javadoc for most methods. Standard gettersetter patterns are followed consistently. The primary deduction stems from the missing Javadoc comment on setCompanyId method creating inconsistency. Overall structure is simple and wellorganized making comprehension straightforward for Java developers.","tokens":1265,"name":"130.jsnp"}
{"score":"90","reasoning":"Clear and simple GUI construction code with descriptive variable names using Hungarian notation. The i18n comment is helpful for maintenance though specialized. Minor formatting inconsistencies slightly reduce readability. Overall intent is immediately obvious and code flow is linear and easy to follow.","tokens":1221,"name":"196.jsnp"}
{"score":"80","reasoning":"The code snippet demonstrates good Java conventions with well-organized and sorted imports. Package and class names are descriptive but verbose, typical of enterprise Java. The deep package hierarchy and lengthy class names slightly reduce quick-scan readability, though they provide clear context. The copyright header is standard but adds noise. Overall structure is clean and follows best practices.","tokens":1621,"name":"134.jsnp"}
{"score":"85","reasoning":"Excellent readability with descriptive method and variable names. Each method follows a clear consistent pattern making logic easy to understand. Code is well indented and concise. Minor deduction for duplication between methods which could be refactored into a helper method, and for inconsistent line breaking in SessionErrors.add calls. Overall structure is sound and comprehension is immediate.","tokens":1757,"name":"206.jsnp"}
{"score":"90","reasoning":"Code demonstrates excellent readability through clear wrapper pattern implementation. Method delegation is straightforward with descriptive naming. The setAuthToken null-handling logic is simple and intuitive. Minor deductions for unconventional underscore prefix in field names and incomplete snippet context. Overall structure is clean, concise, and easily comprehensible.","tokens":1547,"name":"139.jsnp"}
{"score":"20","reasoning":"Code uses anti-pattern while-switch-label control flow making execution path unclear. Contains numerous magic strings and numbers without constants. Poor exception handling with empty catch block. No comments or documentation. Duplicated code for loading modules and waiting. Uses outdated Selenium RC API. No abstraction layer or page objects. Overall structure is confusing and maintenance would be extremely difficult.","tokens":1954,"name":"205.jsnp"}
{"score":"50","reasoning":"The code suffers from excessive verbosity with fully qualified class names and a complex reflection-based invocation pattern that requires Liferay framework knowledge. Nested try-catch blocks add cognitive load. While naming is descriptive and structure consistent, the boilerplate-heavy design significantly hinders quick comprehension for those unfamiliar with this architecture.","tokens":1771,"name":"162.jsnp"}
{"score":"70","reasoning":"Clear repetitive structure makes it easy to follow but reveals code duplication. Test names are mostly intuitive except for numbered variants like AddMBMessage1Tag1Test which lack clarity. Could be improved with a loop and better naming conventions. Moderate readability overall.","tokens":1904,"name":"155.jsnp"}
{"score":"35","reasoning":"Unconventional formatting with return type on separate line and excessive tab spacing. Inconsistent naming: snake_case peer_ip violates Java conventions. Method name isBuddy suggests boolean but returns int. Deep nesting visible in closing braces indicates complexity. Style is outdated and inconsistent with modern practices significantly hindering quick comprehension.","tokens":1198,"name":"117.jsnp"}
{"score":"68","reasoning":"Code shows basic JUnit test structure with clear method names. testUpdateNew is misleading and incomplete. testUpdateExisting has excessive repetitive setter calls reducing readability. Uses helpful abstraction methods like nextLong and randomString. Incomplete method body harms comprehension. Overall follows AAA pattern but verbosity and naming issues lower readability.","tokens":1313,"name":"120.jsnp"}
{"score":"70","reasoning":"Code fragment shows clear logic for value matching and exception handling. Method naming is standard. However, incomplete context reduces comprehension - the full enum/class structure is missing. The underscore prefix in _value is dated Java style. Overall structure is simple but would benefit from seeing the complete method for full understanding.","tokens":1021,"name":"109.jsnp"}
{"score":"65","reasoning":"Code contains a critical copy-paste error using DeleteAliasAction.class instead of AliasAction.class for logger and string manager which is confusing. Variable naming is inconsistent and unclear tw abbreviation hurts comprehension. Method logic is simple and error handling is adequate. Overall structure is clear but these issues significantly reduce readability.","tokens":2501,"name":"137.jsnp"}
{"score":"88","reasoning":"Clean Java syntax with well-organized imports and clear naming conventions. Interface declaration is straightforward. Minor deductions for incompleteness and framework-specific annotations requiring external knowledge.","tokens":1100,"name":"179.jsnp"}
{"score":"75","reasoning":"Simple test UI with clear structure and descriptive naming. Missing import for SQLAliasConnectionProperties is the main readability issue. Excessive whitespace and minimal javadoc are minor concerns. Logic flow is easy to follow for any Swing developer.","tokens":1951,"name":"123.jsnp"}
{"score":"60","reasoning":"Simple class with clear naming but lacks essential readability features. No Javadoc comments, missing encapsulation with package private fields, non standard indentation, and no constructor. While purpose is understandable from names, it violates Java best practices and requires external context. Incomplete data structure needing significant improvements.","tokens":1633,"name":"128.jsnp"}
{"score":"75","reasoning":"Clear naming and consistent structure make intentions obvious. Fully qualified class names create verbosity reducing scanability but ensure clarity. Transactional annotations properly applied. Enterprise Java style prioritizing explicitness. Lacks imports but remains comprehensible for target developers.","tokens":1751,"name":"144.jsnp"}
{"score":"58","reasoning":"Code is functional but overly verbose. String building uses repetitive append calls that hinder readability. Entity conversion has inconsistent null handling. Lacks modern Java features like String.format or Objects.requireNonNullElse. Clear variable names help but overall structure is mechanical and harder to maintain than necessary.","tokens":1301,"name":"197.jsnp"}
{"score":"72","reasoning":"The code has a critical typo in method name _proccessAttributes causing confusion. Uses outdated Collections.EMPTY_LIST instead of parameterized emptyList(). The _isValidAttribute method has convoluted logic with unnecessary list reassignment. The final method is incomplete, preventing full flow assessment. While method extraction is good, these issues hinder readability and maintainability.","tokens":2111,"name":"211.jsnp"}
{"score":"72","reasoning":"Java code with clear logic but nonstandard return syntax using parentheses. Contains ambiguous null parameters in punch method call and unnecessary whitespace. Variable names are descriptive and structure is simple, but style inconsistencies reduce readability for experienced Java developers.","tokens":1023,"name":"185.jsnp"}
{"score":"30","reasoning":"Code snippet has incomplete first line causing syntax confusion. Uses magic number 6 without explanation. Contains continue statement without visible loop context. Locator string is cryptic and auto-generated. RuntimeVariables.replace call is unclear. Lacks comments and proper context. Variable names are descriptive but insufficient to offset the structural issues. Overall difficult to comprehend without surrounding code.","tokens":1559,"name":"129.jsnp"}
{"score":"40","reasoning":"Code snippet is incomplete and truncated at both ends hindering full comprehension. Features repetitive method calls with opaque numeric IDs and hardcoded permission strings without explanatory comments or constants. Inconsistent formatting and lack of context make it difficult to understand purpose. While permission strings are somewhat descriptive the code lacks maintainability and clear structure.","tokens":2113,"name":"127.jsnp"}
{"score":"85","reasoning":"Well-structured utility class with clear method separation. Excellent Javadoc documentation explains purpose parameters and return values. Method names are descriptive and logic is straightforward with simple null check. Minor deductions for legacy Enumeration type and slightly abbreviated variable name ecP. Overall formatting is clean and readable for developers familiar with basic Java and crypto concepts.","tokens":1776,"name":"122.jsnp"}
{"score":"65","reasoning":"Code has clear method names and basic structure but suffers from major readability issues. Raw Map type without generics forces developers to rely on Javadoc instead of type system. Inconsistent documentation (getName lacks Javadoc) and self-referential interface comment reduce clarity. Using array instead of collection is outdated. Overall understandable but requires improvements for modern Java standards.","tokens":1905,"name":"216.jsnp"}
{"score":"20","reasoning":"Code contains empty catch block that silently ignores all exceptions preventing error diagnosis. Magic string and number lack descriptive constants. Uses outdated Selenium style with inefficient Thread.sleep polling. Awkward indentation and missing loop structure context reduce readability. Catching generic Exception is poor practice. Anti-patterns make behavior unpredictable and maintenance difficult.","tokens":2381,"name":"143.jsnp"}
{"score":"58","reasoning":"Incomplete first method signature severely impacts readability. Inconsistent naming convention between URL and Url reduces clarity. Parameter names are descriptive but indentation is inconsistent. While individual methods are simple, the snippet\u0027s overall structure is compromised, requiring extra effort to understand.","tokens":1583,"name":"195.jsnp"}
{"score":"50","reasoning":"Code shows inconsistent naming (Hungarian notation lSequenceNo, cryptic AZID), poor toString formatting, magic number 32767 without context, and incomplete first method. Simple getters are clear but undefined fields, minimal Javadoc, and PlaformMessage typo hamper comprehension. Maintenance issues significantly reduce readability.","tokens":2688,"name":"108.jsnp"}
{"score":"70","reasoning":"Code has clear structure and good variable names but lacks documentation. Potential NullPointerException if FacesContext.getCurrentInstance() returns null. Debug log message is malformed missing closing brace. Methods isEmpty and keySet throw UnsupportedOperationException without explanation suggesting incomplete implementation. JSF dependency requires framework knowledge. Overall readable but needs error handling comments and bug fixes.","tokens":3657,"name":"154.jsnp"}
