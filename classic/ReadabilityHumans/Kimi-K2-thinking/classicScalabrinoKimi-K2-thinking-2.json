{"score":"70","reasoning":"Method name clearly indicates purpose. Variable names are descriptive but overly long class names reduce readability. Comment explains indeterminate order well. Logic is understandable but conditional block with repetitive assertions is verbose and could be streamlined. Overall structure is clear but verbosity and complexity of the ordering test slightly hinder comprehension.","tokens":1527,"name":"181.jsnp"}
{"score":"88","reasoning":"Clean and consistent code structure with clear function naming patterns. Each registration follows a predictable format making it easy to scan. The Javadoc is minimal but sufficient. For developers familiar with Hibernate dialects, the purpose is immediately clear. Minor improvement could be brief comments explaining the Sybase-specific functions, but overall highly readable with no complexity or confusion.","tokens":1376,"name":"21.jsnp"}
{"score":"45","reasoning":"Method name is overly verbose yet fails to clarify test purpose. No assertions make validation logic unclear. Test body does not reflect complex scenario described in name. Lacks comments explaining intent. While code structure follows standard Hibernate pattern and is concise, the disconnect between name and implementation plus missing documentation significantly hinders comprehension.","tokens":1235,"name":"133.jsnp"}
{"score":"88","reasoning":"Clear method structure with descriptive constants. Sequential calls are easy to follow. Minor deductions for inconsistent use of getProperties().put() vs setProperty(), abbreviated parameter name cfg, and mixing constant classes. Highly readable for Hibernate developers.","tokens":1325,"name":"191.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear naming, concise Javadoc, and clean formatting. The static factory method is simple and focused, extracting five properties in a well-structured constructor call. No unnecessary complexity makes it easy to understand at a glance. Minor improvements could include null checks but overall highly comprehensible.","tokens":1295,"name":"67.jsnp"}
{"score":"70","reasoning":"Descriptive method name clearly states intent. Complex HQL query on single line reduces readability. Manual session management and verbose try-catch-fail pattern are dated. Structure is logical but could be modernized with try-with-resources and assertThrows for better clarity and safety.","tokens":1302,"name":"81.jsnp"}
{"score":"60","reasoning":"Method name is overly verbose and complex. Uses anonymous inner classes which reduce readability compared to modern lambda syntax. Result checker contains nested assertions with heavy casting and conditional logic that makes flow harder to follow. However, HQL query is clear and variable names are descriptive. Overall structure follows a consistent pattern but shows dated Java style.","tokens":1605,"name":"98.jsnp"}
{"score":"58","reasoning":"The test method follows a clear pattern but suffers from poor readability due to unformatted SQL strings with extremely long lines lacking indentation or line breaks. The monolithic structure tests many scenarios without explanatory comments. Method name \u0027testNoLoss\u0027 is vague without additional context. While the progression from simple to complex SQL is logical, the dense SQL syntax is hard to parse visually. Splitting into multiple descriptively-named test methods and formatting SQL would significantly improve comprehension.","tokens":1839,"name":"101.jsnp"}
{"score":"48","reasoning":"Test method contains complex nested dialect conditions with multiple instanceof checks that are hard to parse. Long string literals lack descriptive names or explanatory comments. Inconsistent formatting and scattered logic reduce clarity. While method name is descriptive, the dialect-specific exclusions require deep domain knowledge. Overall structure makes it difficult to understand test coverage and maintain.","tokens":1782,"name":"89.jsnp"}
{"score":"58","reasoning":"Inconsistent indentation and formatting significantly hinder readability. Mix of tabs/spaces misaligns code blocks. Poor line breaks in method calls. However, logic is simple and the pattern of delegating to a private integrate method is good. Anonymous inner class adds complexity but is idiomatic for the framework. Overall structure is understandable despite formatting flaws.","tokens":1559,"name":"174.jsnp"}
{"score":"70","reasoning":"Test method has descriptive name and clear structure with setup execution and verification phases. Good resource cleanup with try-finally. However verbose property keys reduce readability magic numbers lack named constants and variable p is not descriptive. Comment explains scenario but is lengthy. Assertions are specific and meaningful. Overall decent readability but could be improved with constants and shorter property references.","tokens":1794,"name":"131.jsnp"}
{"score":"70","reasoning":"Clear method name and parameter names with logical grouping. Good use of helper methods. However, duplicate conditional logic for setCollectionPersisterClass with different conditions (isNotEmpty vs null) and contexts (currentBindingContext vs metadata) is confusing and appears erroneous, significantly reducing comprehension. Otherwise well-structured with consistent formatting.","tokens":1959,"name":"146.jsnp"}
{"score":"68","reasoning":"Code has clear variable names and logical flow but suffers from a lengthy TODO comment highlighting architectural flaws, raw type usage for Iterator, complex three-step condition resolution logic, and a fully qualified class name. The method is understandable but requires significant domain knowledge and the TODO suggests brittleness that impacts confidence in comprehension.","tokens":1959,"name":"31.jsnp"}
{"score":"85","reasoning":"Well structured test with clear naming and descriptive comments explaining dialect behavior differences. Logical flow with good variable names and assertions. Minor issues: requires Hibernate domain knowledge, combines two scenarios in one method, and depends on external methods not shown. Overall highly readable for intended audience.","tokens":2057,"name":"57.jsnp"}
{"score":"78","reasoning":"Method has clear naming and helpful comments but relies heavily on instance variables lacking context. Null parameters in createEntity are unclear. Ternary operator is dense. Final comment misleads about return value. Good structure but needs more explicit parameters and reduced external dependencies.","tokens":2115,"name":"170.jsnp"}
{"score":"88","reasoning":"Clean concise method with clear null check and resource release pattern. Proper use of Override annotation. Minor deduction for empty catch block without explanatory comment, which may obscure intent to silently ignore close failures. Overall structure and naming are excellent.","tokens":986,"name":"150.jsnp"}
{"score":"35","reasoning":"Code suffers from excessive debug output with long tilde strings obscuring logic. Bit manipulation lacks comments and uses magic numbers making intent unclear. Variable names like hiTime loTime are cryptic. Dependencies on undefined helper classes BytesHelper and Helper reduce comprehension. The manual UUID construction is overly complex compared to standard library methods. Overall purpose is not evident from the code structure.","tokens":2372,"name":"58.jsnp"}
{"score":"50","reasoning":"Extremely verbose class names reduce readability significantly. Repetitive code blocks for rev1-4 should be looped. Cryptic variable names ed2 and ing2_id lack clarity. No comments explain test intent. Magic revision numbers 1-4 are unexplained. Logical assertion structure is the only positive aspect. Overall comprehension is moderately difficult due to naming and redundancy.","tokens":2339,"name":"186.jsnp"}
{"score":"50","reasoning":"Code suffers from poor readability due to an empty undocumented else-if block causing confusion. Significant duplication exists in person-address relationship management logic. Variable names are terse p and a lacking clarity. Magic string NULL appears without constant definition. The method combines input parsing entity management and error handling without comments making maintenance hard despite clear control flow structure.","tokens":2342,"name":"61.jsnp"}
{"score":"88","reasoning":"Clear structure with descriptive variable names and helpful comments explaining the buffering logic. The method cleanly separates buffered and direct reading paths. Minor deduction for slightly awkward phrasing in the first comment and subtle semantics of eventLimit values that require careful reading. Overall well-organized and easy to follow.","tokens":1516,"name":"151.jsnp"}
{"score":"85","reasoning":"Code demonstrates good readability with descriptive naming, clear Javadoc, and helpful inline comments. Structure is clean with proper indentation. Method is concise and focused. Minor deductions for long method chains requiring domain knowledge of Hibernate\u0027s natural ID handling, and unexplained null parameter. Overall well-written for its specialized context.","tokens":1358,"name":"103.jsnp"}
{"score":"65","reasoning":"Method has clear structure and naming but contains bugs: missing parenthesis in tuple creation and inconsistent replace() usage. Heavy reliance on undefined helpers (repeat, joinWithQualifier) and constants (BATCH_ID_PLACEHOLDER) requires external context. Dialect-specific logic demands SQL knowledge. Minimal comments aid understanding but code is not self-contained, hindering quick comprehension for those unfamiliar with the domain.","tokens":2657,"name":"112.jsnp"}
{"score":"68","reasoning":"The test has clear naming and structure with helpful comments. However, readability is significantly hampered by extremely verbose Hibernate API calls with deep method chaining (SessionImplementor casting and multiple getTransactionCoordinator/getJdbcCoordinator calls). The anonymous inner class syntax is also outdated compared to modern lambda expressions. While functional, the code requires substantial Hibernate internal knowledge to comprehend quickly.","tokens":1790,"name":"93.jsnp"}
{"score":"93","reasoning":"Excellent readability with self-documenting method names and consistent pattern. Each line follows predictable structure making database mapping purpose obvious. Repetitive nature reinforces understanding. Minor deductions for minimal Javadoc and lack of grouping comments but intent is immediately clear. No complex logic or nested structures. Easily comprehensible for Hibernate dialect maintenance.","tokens":1847,"name":"20.jsnp"}
{"score":"65","reasoning":"Repetitive session/transaction boilerplate reduces clarity. Inconsistent formatting and variable reuse across blocks make flow hard to follow. Multi-phase test lacks visual separation or comments. Magic strings and typos add confusion. While functional, extracting helper methods and using distinct variables would greatly improve readability.","tokens":3107,"name":"192.jsnp"}
{"score":"60","reasoning":"Code suffers from poor readability due to cryptic variable names xs, ys, p and unexplained magic number 5. The diamond-shaped coordinate arrays lack clarity about their geometric purpose. Trailing commas and inconsistent formatting add confusion. No comments explain the algorithm. While concise and functional, these issues significantly hinder comprehension.","tokens":1723,"name":"153.jsnp"}
{"score":"80","reasoning":"The method demonstrates good readability with clear naming conventions and logical structure. It processes JPA/Hibernate discriminator annotations methodically. Minor issues include split logic for inheritance state checking and redundant null checks. Ternary operators are used appropriately for conciseness. The code is well-indented and easy to follow for developers familiar with ORM frameworks. Overall comprehension is straightforward despite handling multiple annotation types.","tokens":1489,"name":"28.jsnp"}
{"score":"70","reasoning":"Moderate readability with clear naming and logical structure but requires deep Hibernate knowledge. Comments are partially helpful but contain typos and unclear phrasing. Complex logic for implied optimistic locking is difficult without context. Method name has typo. Loop purpose unclear without understanding table span concept.","tokens":2235,"name":"106.jsnp"}
{"score":"45","reasoning":"Nested loops with deep casting create readability issues. Boolean flags for state management add cognitive overhead. Inconsistent indentation and commented-out code reduce maintainability. O(n*m) search is inefficient. Overall logic requires significant context to understand.","tokens":1714,"name":"50.jsnp"}
{"score":"58","reasoning":"Test name is cryptic and variable names like ed1, ed2, ing2_id are ambiguous. Repetitive calls to getAuditReader().find() could be looped or abstracted. Uses assert instead of JUnit assertions, reducing debuggability. No comments explain the scenario or revision numbers. Linear structure is clear but these issues significantly hinder readability.","tokens":2235,"name":"166.jsnp"}
{"score":"70","reasoning":"Test method name is cryptic and uses magic numbers without constants reducing maintainability However code structure is clear with descriptive variable names and a helpful comment linking values to configuration The logic is straightforward and follows standard JUnit patterns making it reasonably easy to comprehend despite these flaws","tokens":2400,"name":"90.jsnp"}
{"score":"65","reasoning":"Code uses verbose anonymous inner classes creating nesting and clutter. Inconsistent spacing in casts reduces visual clarity. Test name abbreviation Assn is unclear. ResultChecker has repetitive casting and a duplicated assertion. The boolean parameter in runTest is ambiguous. While structure is logical and naming is generally descriptive, these issues hinder quick comprehension. Modern Java features like lambdas would improve readability significantly.","tokens":1831,"name":"96.jsnp"}
{"score":"35","reasoning":"Excessive casting makes code hard to parse. Complex conditional logic with instanceof checks and overloaded test scenarios reduce clarity. The index++ pattern for verification is error-prone. Method tries to test too many cases at once, violating single responsibility principle for tests. Variable names are somewhat unclear and nested parentheses create visual noise.","tokens":2240,"name":"140.jsnp"}
{"score":"75","reasoning":"Uses anonymous inner class to run test in separate thread with proper cleanup in finally block. Comments explain the inlined code workaround. The qualified this syntax and anonymous inner class structure are verbose but standard pre-Java 8 patterns. Clear for developers familiar with Java concurrency but slightly dated.","tokens":2241,"name":"73.jsnp"}
{"score":"72","reasoning":"Clear naming and structure with helpful comments. Nested conditions and instanceof checks increase complexity. Independent if statements may confuse. Magic strings reduce maintainability. Static Model.getFacade() is verbose. Decent readability but could improve with polymorphism and constants.","tokens":1865,"name":"47.jsnp"}
{"score":"90","reasoning":"Clear Javadoc documents parameter and return value. Follows standard equals() pattern with explicit sequential checks: reference equality, instanceof validation, and super.equals() call. Each condition is simple with immediate return. Slightly verbose but enhances readability. Well-structured and easy to comprehend for all developer levels.","tokens":1572,"name":"39.jsnp"}
{"score":"70","reasoning":"The method follows standard equals pattern with clear reference and type checks. The cast is straightforward. Primitive field comparison is simple. However, the string comparisons using ternary operators for null safety are unnecessarily complex. The expression name !\u003d null ? !name.equals(person.name) : person.name !\u003d null requires mental parsing to understand the null handling logic. While functional and common in older Java code, modern Objects.equals() would be far more readable. The code is correct but forces readers to decode the null check pattern.","tokens":1729,"name":"60.jsnp"}
{"score":"15","reasoning":"Code suffers from severe readability issues due to deeply nested ternary operators condensed into a single line. The complex boolean logic for schema and catalog comparison is nearly incomprehensible and error-prone regarding operator precedence. Lack of formatting and helper methods makes understanding the intended case-sensitive/insensitive matching logic extremely difficult. Initial null and identity checks are clear but the rest violates basic readability principles.","tokens":2383,"name":"36.jsnp"}
{"score":"72","reasoning":"Method name excessively long. Anonymous inner classes add verbosity and nesting. ResultChecker contains deeply nested casts reducing clarity. However structure is logical with clear separation of concerns and descriptive variable names. Familiarity with Hibernate patterns helps comprehension. Overall moderately readable but shows age in style.","tokens":1991,"name":"99.jsnp"}
{"score":"45","reasoning":"Method is overly long and complex testing multiple scenarios without structure. The dialect conditional is extremely verbose with nested negations and commented code. Magic strings and mixed setup execution assertions reduce clarity. While HQL queries are readable the lack of separation of concerns and helper methods makes maintenance difficult. Overall comprehension requires significant effort due to density and poor organization.","tokens":1685,"name":"68.jsnp"}
{"score":"88","reasoning":"Method demonstrates good readability with clear conditional structure and descriptive naming. The logic flow is straightforward: handles empty list, single element, and multiple elements cases. Formatting is consistent with proper indentation. Minor deductions for method name starting with noun \u0027parser\u0027 instead of verb, and an unexplained null parameter in nestedPrimaryKeyJoinColumnList call. Overall well-structured and easy to comprehend.","tokens":1751,"name":"193.jsnp"}
{"score":"40","reasoning":"Method name misleadingly suggests processing but always returns null. Unused entityType parameter creates confusion. Vague comment about cascade handling lacks clarity. Inconsistent spacing reduces readability. Despite brevity, the method\u0027s purpose and side effects are unclear, making comprehension difficult.","tokens":1429,"name":"65.jsnp"}
{"score":"65","reasoning":"Test method structure is clear but property keys use cryptic rpt.N prefix requiring domain knowledge. Duplicate password_enc line appears erroneous. Hardcoded magic strings reduce maintainability. Assertions are concise but test intent is not self-explanatory. Better naming and constants would improve readability significantly.","tokens":2097,"name":"35.jsnp"}
{"score":"40","reasoning":"Code suffers from excessive method chaining, repeated casting to SessionImplementor, and deep internal API usage making it hard to follow. Uses anonymous inner class instead of lambda, has empty catch block ignoring exceptions, and lacks proper resource management with try-with-resources. No comments explain intent. While basic structure is logical, these issues significantly hinder readability and maintainability.","tokens":1763,"name":"100.jsnp"}
{"score":"88","reasoning":"Clear and consistent structure with descriptive naming. Each function registration follows a uniform pattern making it easy to scan and understand. Well-formatted with proper indentation. Minor deduction for length and lack of logical grouping comments which could improve navigation. Overall purpose is immediately apparent.","tokens":1515,"name":"18.jsnp"}
{"score":"75","reasoning":"The code features excellent Javadoc that clearly explains purpose, usage, and exception details. Variable names are descriptive and meaningful. However, the else block contains dense chained method calls (iterator().next()) to retrieve first elements from collections, reducing readability. The logic requires understanding multiple domain-specific data structures. While functional, the implementation could benefit from helper methods or Java 8 streams to improve clarity.","tokens":1636,"name":"102.jsnp"}
{"score":"88","reasoning":"Test method demonstrates clear JPA transaction pattern with good structure and naming. The Country.of() factory method is readable. Minor deductions for ambiguous \u0027Revision 1\u0027 comment and undeclared \u0027country\u0027 field requiring external context. Overall highly comprehensible for target audience.","tokens":1593,"name":"168.jsnp"}
{"score":"45","reasoning":"The code suffers from excessive nesting depth and convoluted if-else logic that should use else-if or switch statement. Inconsistent indentation and awkward line breaks reduce clarity. Repetitive method calls to Model.getAggregationKind() could be extracted. While the method\u0027s intent is discernible, the structure makes it harder to follow than necessary. The nested if-else pattern instead of else-if creates unnecessary cognitive load.","tokens":1135,"name":"157.jsnp"}
{"score":"45","reasoning":"Code readability is hampered by inconsistent formatting, commented-out cast, poor variable naming like mInterface and sbText, raw type Stack, and unclear null parameter usage. The logic flow is confusing with stack manipulation and nested conditionals. Missing context for variable name and side effects on parseStateStack reduce comprehension. Overall structure is understandable but requires cleanup for maintainability.","tokens":1845,"name":"116.jsnp"}
{"score":"42","reasoning":"Inconsistent indentation and legacy Java features severely impact readability. Uses obsolete Vector and Enumeration with raw types requiring unsafe casts. Inefficient O(n*m) nested loops and redundant method calls show poor design. Cryptic comments and abbreviated variable names add confusion. While the basic logic can be traced, the code violates modern practices and requires significant refactoring for maintainability.","tokens":2252,"name":"46.jsnp"}
{"score":"68","reasoning":"Clear parameter names and helpful comment aid understanding. Complex multi-part condition spanning lines 11-14 requires careful parsing. Deep nesting and raw casting reduce immediate comprehension. Domain-specific Hibernate internals add unavoidable complexity. Structure is logical but could be improved by extracting the condition into a descriptive method.","tokens":1679,"name":"198.jsnp"}
{"score":"65","reasoning":"Code has clear documentation and logical structure but suffers from inconsistent indentation mixing tabs and spaces reducing visual clarity. Uses raw type Iterator instead of generic Iterator\u003cClassLoader\u003e which is outdated Java style. Implicit null handling when bundle not found could be more explicit. Variable names are meaningful and logging aids debugging. Overall decent but requires cleanup for modern standards.","tokens":1876,"name":"7.jsnp"}
{"score":"72","reasoning":"Test method has descriptive name and clear structure but suffers from poor readability due to long SQL string concatenation across multiple lines. The complex expected SQL is hard to parse visually, and the dense assertion line reduces comprehension. While functional, modern text blocks would significantly improve clarity.","tokens":1902,"name":"23.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear naming, structured switch statement for XML events, comprehensive error checks with meaningful messages, and proper StringBuilder usage. Method is lengthy due to complex parsing but well-organized. Explicit ignore comments and detailed exceptions aid comprehension. Minor complexity from XMLStream API casting and loop condition.","tokens":1896,"name":"152.jsnp"}
{"score":"80","reasoning":"The code shows good structure with logical string building flow. Names are descriptive and the null-check comment is helpful but slightly verbose. Inconsistent use of \u0027this.\u0027 qualifier (region vs other members) is a minor style issue. Chained appends are readable but could be more compact. Overall straightforward, easy to comprehend, with only minor improvements needed.","tokens":1653,"name":"64.jsnp"}
{"score":"68","reasoning":"Test method suffers from excessive repetition with 18 nearly identical assertAnnotationNotPresent calls making it verbose and hard to scan. Test name testNoChildren is cryptic and doesn\u0027t clearly explain the scenario. However code is well-formatted and assertions are clear. Could be improved with a helper method or parameterized approach to reduce duplication and a more descriptive name.","tokens":1328,"name":"176.jsnp"}
{"score":"40","reasoning":"Extensive commented code with poor indentation severely obscures actual logic. Variable runs is always zero causing confusing dead code and broken calculations. Missing if braces reduce clarity. While basic timing structure is understandable the snippet appears incomplete and requires significant cleanup for proper comprehension.","tokens":2812,"name":"172.jsnp"}
{"score":"72","reasoning":"Test method demonstrates clear purpose through annotations and comments. Follows logical Arrange-Act-Assert pattern. However, inconsistent indentation mixing tabs and spaces reduces readability. Variable naming could be improved (e.g., \u0027s\u0027 instead of \u0027session\u0027). Uses string concatenation for SQL which is poor practice. Magic numbers for IDs. Overall structure is understandable but needs cleanup for better maintainability.","tokens":2540,"name":"136.jsnp"}
{"score":"65","reasoning":"Long HQL query on single line hurts readability. Assertion message has typo and is verbose. @SuppressWarnings has odd spacing. Commented code adds clutter. Method name is clear and structure is simple, but these issues significantly impact comprehension.","tokens":1477,"name":"92.jsnp"}
{"score":"88","reasoning":"The method follows the standard equals() pattern with clear structure: reference check, type check, cast, and field comparisons. Variable names are descriptive and logic flows logically with early returns. Javadoc is mostly clear but has minor inconsistency: return tag mentions only second and minute while code also checks hour and day. Overall highly readable for any Java developer.","tokens":1930,"name":"42.jsnp"}
{"score":"75","reasoning":"Test method demonstrates good structure with clear sections testing different annotation scenarios. Logical flow and descriptive assertions enhance readability. However repetitive reader.getAnnotation() calls create verbosity. Magic strings for XML paths and numeric literals could be constants. Deep property chains like uniqueConstraints()[0].columnNames() reduce clarity. Overall decent readability for domain-experienced developers but could benefit from helper methods and constants.","tokens":2417,"name":"135.jsnp"}
{"score":"80","reasoning":"Clear method name and structure with good formatting. Constructor parameters are well-aligned for readability. Minor issues: raw Map type lacks generics, TODO comment is slightly vague, and method depends on multiple instance fields not visible in snippet. Overall straightforward and easy to understand.","tokens":1307,"name":"55.jsnp"}
{"score":"68","reasoning":"Method name is excessively long and convoluted despite attempting descriptiveness. Comments are verbose but provide crucial context for this Hibernate bug fix test. Test structure follows clear setup-execute-cleanup pattern. Variable names are adequate. Overall understandable for domain experts but challenging for newcomers due to complex scenario and naming.","tokens":1705,"name":"175.jsnp"}
{"score":"78","reasoning":"Well-structured method with descriptive naming and clear conditional logic. Uses final appropriately and provides good logging. Main readability issues are verbose nested method calls repeated in exception messages and logging statement. Domain-specific ORM concepts require context. Could extract repeated role path to a variable for better clarity.","tokens":1539,"name":"183.jsnp"}
{"score":"72","reasoning":"Moderate readability due to anonymous inner class complexity and external dependencies runner output expected method requiring context. Magic strings in expected output lack clarity. Dense formatting reduces scannability. Clear purpose and logical flow but demands JUnit 3 familiarity and increases cognitive load unnecessarily.","tokens":2133,"name":"12.jsnp"}
{"score":"68","reasoning":"Code shows clear transactional patterns with helpful comments explaining each revision step. However suffers from repetitive boilerplate for transaction management, unclear context for external variables c3_1 and c3_2, and verbose entity refetching. Comment about both collections is confusing since only one is modified. Could be improved by extracting helper method for transactions and providing more context about test data.","tokens":1730,"name":"188.jsnp"}
{"score":"78","reasoning":"Clear test structure with descriptive name and consistent pattern. Good variable naming and comprehensive coverage of SQL TRIM variations. However, suffers from repetitive code blocks that could be refactored into a parameterized test, reducing maintainability. Magic constants require external context but are acceptable for unit tests. Overall straightforward and easy to comprehend despite verbosity.","tokens":1783,"name":"26.jsnp"}
{"score":"88","reasoning":"Code demonstrates excellent clarity with consistent naming pattern and proper JavaDoc documentation. The serialization logic follows standard practices with clear method signature. While the method is lengthy due to 22 repetitive field assignments, the uniform structure makes comprehension straightforward. Each line performs a single obvious operation. Minor deduction for verbosity but overall highly readable.","tokens":1540,"name":"3.jsnp"}
{"score":"68","reasoning":"The code shows clear precedence logic with helpful comments explaining each branch purpose. However it suffers from code duplication createEntityLoader appears four times and the third condition is overly complex. The lengthy if else chain makes flow control somewhat cumbersome. While intent is clear through comments the structure could be improved by refactoring to reduce repetition and simplify the decision tree.","tokens":1918,"name":"107.jsnp"}
{"score":"95","reasoning":"Excellent readability with comprehensive Javadoc, descriptive naming, and clear linear flow. Method is concise, well-structured, and each step is logical. The parameter names and types are explicit, making purpose obvious. Minor formatting inconsistency in Javadoc indentation doesn\u0027t detract from overall comprehension. A prime example of clean, maintainable code.","tokens":1676,"name":"126.jsnp"}
{"score":"50","reasoning":"Code suffers from inconsistent indentation mixing tabs and spaces confusing naming like CompositeIdId and getted variable cryptic comments referencing internal Hibernate details repetitive session transaction boilerplate and complex SQL syntax without clear explanation making it hard to understand the tests purpose without deep framework knowledge","tokens":1390,"name":"72.jsnp"}
{"score":"55","reasoning":"Deep method chaining makes code hard to follow and violates Law of Demeter. Boolean flag pattern for exception testing is outdated. Manual resource management is verbose. Exception variable named \u0027ok\u0027 is unclear. However test structure is logical and assertion message is descriptive.","tokens":1862,"name":"145.jsnp"}
{"score":"55","reasoning":"The code suffers from unexplained magic numbers (15, 16, 17), complex object instantiation without clarity, and lacks comments. The query chain formatting is awkward, and it requires deep framework knowledge. While the structure is logical and naming is decent, these issues significantly hinder comprehension for anyone not intimately familiar with the codebase.","tokens":2250,"name":"167.jsnp"}
{"score":"45","reasoning":"Method name is misleading as it suggests resetting state but calls getter-like methods. The naming getSawRegionModification and getSawRegionAccess is confusing and non-standard. Code is repetitive with hardcoded class names. The log message claims state is cleared but this is not evident from the operations. Overall purpose and side effects are unclear, making comprehension difficult despite simple structure.","tokens":1464,"name":"190.jsnp"}
{"score":"80","reasoning":"The test method has a clear descriptive name and follows AAA pattern. Variable names are meaningful and assertions are expressive using Hamcrest. However, nested constructor calls and framework-specific methods like signature() require external context. The helper method getStringValuesFromAssignments adds hidden complexity. Overall well-structured but assumes familiarity with the testing framework.","tokens":1189,"name":"159.jsnp"}
{"score":"75","reasoning":"Well-structured event handler with clear comments, but commented-out code severely impacts maintainability. Terse variable name \u0027p\u0027 and awkward line break also reduce readability. Logic is simple and follows conventions.","tokens":1897,"name":"11.jsnp"}
{"score":"72","reasoning":"Test method is explicit and well-structured with clear naming and logical flow. However it suffers from excessive verbosity and repetitive assertions for column properties making it longer than necessary. The awkward line break for getAnnotation call reduces readability. While domain knowledge is required this is acceptable for JPA annotation testing. Overall good clarity but could benefit from helper methods to reduce duplication.","tokens":2084,"name":"177.jsnp"}
{"score":"68","reasoning":"Method name is overly verbose and technical. Code structure is clear with setup-test-cleanup phases but session management is repetitive. HQL query is complex but that\u0027s the test focus. Uses magic values without constants. Raw HashMap usage requires SuppressWarnings. Lacks explanatory comments. Understandable for Hibernate developers but could be more accessible.","tokens":1548,"name":"82.jsnp"}
{"score":"65","reasoning":"Method name is descriptive but structure is monolithic with multiple scenarios. Reusing translator variable harms clarity. Lack of comments or visual separation makes parsing harder. Assertions are clear with good messages. Would benefit from splitting into separate tests or adding blank lines and comments to distinguish scenarios.","tokens":2045,"name":"88.jsnp"}
{"score":"60","reasoning":"Excessively long method name severely impacts readability. Comment uses unexplained abbreviation. Method body is clean with well-named helpers and logical flow, but hidden assertions reduce transparency. Good structure undermined by poor naming.","tokens":2173,"name":"187.jsnp"}
{"score":"95","reasoning":"Code shows excellent readability with descriptive method names that self-document the setup sequence. Each call on its own line creates clear linear flow. Minimal Javadoc is adequate. No complex logic ensures immediate comprehension. Explicit super() is slightly redundant but harmless. Highly readable and maintainable.","tokens":1592,"name":"19.jsnp"}
{"score":"85","reasoning":"Code demonstrates good readability with clear naming conventions and consistent formatting. The method has a single focused purpose well-documented by the Javadoc comment. Repeated registration calls create a clear visual pattern. Minor deductions for the commented-out code fragment, unclear null parameter in makeNotation, and numeric suffix in class name. Overall structure is clean and easy to comprehend.","tokens":2091,"name":"5.jsnp"}
{"score":"45","reasoning":"Deep method chaining with buried cast makes parsing difficult. Extremely long class name creates line width issues. No intermediate variables clarifies intent. Single complex expression requires mental tracking of getCfg().getClassMapping().getKey().getColumnIterator().next().getName() sequence. Test logic remains obscure despite descriptive method name.","tokens":1356,"name":"199.jsnp"}
{"score":"60","reasoning":"Method has clear JavaDoc and intent but suffers from significant readability issues. Awkward line breaks split method calls unnaturally. Repeated array indexing instead of enhanced for-loop is verbose. Unnecessary casting suggests raw type usage. Deeply nested method calls make logic dense. Comments explain branches but are wordy. Overall functional but needs refactoring for clarity.","tokens":1743,"name":"51.jsnp"}
{"score":"70","reasoning":"Test method with multiple parse calls testing HQL syntax. Code is dense without blank lines between test cases. Contains a duplicated test case which is confusing. Commented section with developer uncertainty provides helpful context. Overall structure is clear but formatting could be improved for better scanability.","tokens":2443,"name":"85.jsnp"}
{"score":"65","reasoning":"Code shows clear pattern for Hibernate Envers test setup with three revisions. Constructor parameters use cryptic string/number literals lacking context. Repetitive table mapping retrieval with long class names violates DRY. Comments help but method name is generic. Transaction handling is correct. Requires domain knowledge. Could be improved with builder pattern and helper methods.","tokens":1777,"name":"189.jsnp"}
{"score":"72","reasoning":"Method demonstrates clear intent with descriptive naming and logical flow. Validation and error handling provide good context. However uses deprecated newInstance(), broad Exception type, and verbose string concatenation for messages. Variable each could be more specific. Missing bounds check for annotation index. Overall understandable but shows dated patterns and lacks modern Java best practices.","tokens":2045,"name":"13.jsnp"}
{"score":"60","reasoning":"Code structure is simple but readability suffers from unexplained null values that appear to be separators. Lack of comments and documentation makes intent unclear. Uses generic Object[] reducing type safety. Method names are descriptive and consistent, which helps, but overall comprehension requires external context. The pattern suggests grouping but isn\u0027t self-documenting.","tokens":1168,"name":"156.jsnp"}
{"score":"88","reasoning":"Excellent Javadoc clearly explains purpose, parameters, and return value. Variable names are descriptive and logic flows naturally with nested loops accumulating positive and negative values separately. Parameter validation is present. Minor improvements: loop variable \u0027item\u0027 could be \u0027categoryIndex\u0027 for clarity, and a comment on the final if-check would help understand the no-data edge case. Overall highly readable and maintainable.","tokens":1560,"name":"41.jsnp"}
{"score":"58","reasoning":"The method has clear naming and helpful Javadoc but suffers from high cognitive load due to 15+ side-effecting helper calls that modify the annotationList. It depends on external state (elementsForProperty field) and is overly long. The attribute-override comment is useful but overall the sequential structure makes it hard to track individual responsibilities. Side effects and state coupling significantly reduce readability.","tokens":1966,"name":"149.jsnp"}
{"score":"88","reasoning":"Code shows strong readability with descriptive names and clear error messages. Logic is well-structured: range validation followed by usage checking. The usedIndices array pattern is efficient though requires momentary mental parsing. Minor enhancements possible: extract helper method for annotation processing and break up nested calls like getField().getAnnotation().value(). Overall excellent comprehension for experienced developers, very good for juniors.","tokens":1772,"name":"14.jsnp"}
{"score":"50","reasoning":"The test method suffers from excessive length and repetition, particularly the iterator validation blocks which are nearly identical. Complex method chains are repeated multiple times, reducing clarity. The HashSet iteration pattern is unnecessarily verbose. While the test structure is logical, these issues significantly hinder readability. The method would benefit from helper methods and extracting repeated expressions into local variables.","tokens":2311,"name":"180.jsnp"}
{"score":"58","reasoning":"Method name is descriptive but overly verbose. Lacks local context for serviceRegistry creating hidden dependency. Uses magic number 0 for property index without explanation. Deep method chaining and casting increase cognitive load. Resource leak risk as factory.close() is not in finally block. Uses deprecated AnnotationConfiguration API. Assertion messages are clear but overall comprehension requires deep Hibernate knowledge. No comments explain test intent or setup rationale.","tokens":1300,"name":"178.jsnp"}
{"score":"60","reasoning":"Parameter j lacks descriptiveness. Method combines initialization snapshot handling and name validation reducing single responsibility clarity. Heavy coupling to external state. Return value is unintuitive for initialization. Comment referencing HHH-2236 is cryptic. Clean structure but requires domain knowledge.","tokens":3121,"name":"104.jsnp"}
{"score":"70","reasoning":"Method name and parameter are descriptive. Code is concise with good vertical alignment. However, multiple explicit casts (QueryableCollection, OuterJoinLoadable, CompositeType) indicate complex type hierarchies requiring domain knowledge. Deep method chaining adds mental overhead. Readable for framework experts but opaque for others.","tokens":1633,"name":"148.jsnp"}
{"score":"35","reasoning":"Machine-generated parser code with poor readability. Contains unnecessary nested blocks, cryptic auto-generated names like _tokenSet_6 and _loop119, and convoluted do-while-true loop with labeled break instead of simple while. Excessive blank lines and inconsistent formatting further reduce clarity. Understandable only with domain knowledge of parser generators.","tokens":1279,"name":"115.jsnp"}
{"score":"45","reasoning":"Code suffers from repetitive if-statements checking model element types, violating DRY principle. Variable names like pce, eo, me are cryptic. Uses legacy Vector class. Lacks comments explaining intent. Logic for detecting removal is indirect. Could be refactored with polymorphism or lookup map for better maintainability.","tokens":1552,"name":"119.jsnp"}
{"score":"88","reasoning":"Code demonstrates good readability with clear Javadoc and inline comments explaining the listener notification pattern. Variable names are descriptive except for the terse \u0027e\u0027 event variable. The reverse iteration with step of 2 is standard for EventListenerList but requires comment for clarity. Lazy initialization is well-implemented and documented. Minor formatting inconsistencies slightly reduce readability. Overall follows Java conventions effectively.","tokens":1388,"name":"9.jsnp"}
{"score":"90","reasoning":"Clear test structure with descriptive naming following AAA pattern. Variables are well-named and final. Method name accurately describes purpose. Long SQL strings reduce readability slightly but are necessary for the test. Overall concise and easy to comprehend.","tokens":1735,"name":"24.jsnp"}
{"score":"65","reasoning":"The code uses a non-obvious compare-and-swap retry pattern in compact for-loops that is difficult to parse. The readLock usage is unconventional and requires careful comment reading to understand its purpose. While variable names are clear and the method is short, the dense atomic operations and confusing synchronization strategy significantly hinder readability. Comments are present but vague. Overall comprehension requires deep concurrent programming knowledge.","tokens":1935,"name":"62.jsnp"}
{"score":"55","reasoning":"Code suffers from repeated method calls within loop condition and body, creating verbosity and potential inefficiency. The 7-parameter method call is hard to read. While naming is consistent, it\u0027s overly verbose. Basic intent is clear but implementation clutter hinders comprehension. Could be improved by storing arrays in local variables first.","tokens":1544,"name":"105.jsnp"}
{"score":"62","reasoning":"Inconsistent brace style on first if statement reduces clarity. Excessive method chaining and repeated session casting create verbosity. The double-dollar method name is unconventional. However, the early-return structure is logical and the method name is descriptive. Complex boolean logic with negations requires careful reading. A comment aids understanding but Hibernate-specific patterns may challenge unfamiliar developers. Overall decent structure hampered by stylistic inconsistencies and density.","tokens":2289,"name":"111.jsnp"}
{"score":"78","reasoning":"Code has clear naming and logical structure but suffers from minor issues. The thread.interrupt() call is oddly placed inside a stack trace null check, creating confusion. Formatting inconsistencies (space before parenthesis, awkward line breaks) and verbose Java 7 generic syntax reduce readability. Overall logic is understandable for experienced developers but these quirks hinder smooth comprehension.","tokens":1550,"name":"125.jsnp"}
{"score":"85","reasoning":"Clear variable names and structure with proper null checks. Formatting is good. However the multiplication by PRIME placed between field contributions follows a slightly non-standard pattern which may cause momentary confusion compared to the typical result \u003d result * PRIME + field.hashCode() idiom. Still straightforward to comprehend.","tokens":1259,"name":"141.jsnp"}
{"score":"70","reasoning":"Test method demonstrates clear AAA pattern with descriptive entity names. However readability suffers from verbose nested annotations inconsistent indentation and unnecessary System.out.println. The Hibernate specific skip annotations while functional are visually cluttered. Core logic is straightforward for familiar developers but could be improved with consistent formatting and removal of debug output.","tokens":2013,"name":"138.jsnp"}
{"score":"80","reasoning":"Clear and simple logic with proper formatting. Method name addChar is slightly generic and the comment start of a line-end is awkward. Variable names hasLf and hasCr are abbreviated but standard. Side effects are not immediately clear without context. Overall easy to comprehend for target audience.","tokens":1684,"name":"6.jsnp"}
{"score":"65","reasoning":"Method name is overly verbose yet unclear. Empty catch block is confusing without comments. \u0027thrown.expectMessage()\u0027 requires external JUnit context. Magic numbers like TIMEOUT+50 lack clarity. Test combines two scenarios making intent ambiguous. Broad \u0027throws Throwable\u0027 is unspecific. While it follows JUnit patterns, it needs better naming and comments for clarity.","tokens":1773,"name":"160.jsnp"}
{"score":"65","reasoning":"Moderate readability due to clear test name and logical structure. However excessive casting deep nesting verbose anonymous classes and inconsistent formatting create significant cognitive load. The commented assertion with bug reference provides useful context but adds noise. Unclear boolean parameter reduces clarity. Modern Java features would improve conciseness significantly.","tokens":2611,"name":"97.jsnp"}
{"score":"78","reasoning":"Code shows good structure with clear Javadoc and consistent patterns for adding fields and actions. Logical grouping with separators enhances readability. Main issues are inconsistent indentation around classifierScroll creation, poorly named variable a, and complex nested constructors. The boolean literal true lacks clarity. These minor formatting and naming problems slightly reduce overall comprehension but the core logic remains understandable.","tokens":2330,"name":"158.jsnp"}
{"score":"88","reasoning":"Clear Javadoc explains purpose and parameters. Logic is straightforward: fetch element, handle null, return value. Exception handling is explicit but slightly complex with nested type check. Unnecessary else block after return adds minor clutter. Fully qualified exception name is verbose. Overall structure is sound with good variable naming and clear flow. Minor formatting inconsistencies. High readability with small improvement opportunities.","tokens":1641,"name":"164.jsnp"}
{"score":"45","reasoning":"Method includes basic Javadoc and clear structure but bit manipulation logic using left then right shifts is highly non-intuitive and difficult to comprehend. The pattern (longValue \u003c\u003c N) \u003e\u003e 56 is cryptic compared to standard direct right shifts or bit masking. Method name and return description are vague. Requires significant mental effort to verify correctness.","tokens":1854,"name":"113.jsnp"}
{"score":"48","reasoning":"Code uses nested anonymous inner classes creating deep indentation and complexity. Inconsistent formatting missing braces on conditional. Fully qualified class name adds noise. Null parameters lack clarity. Overriding methods for configuration is less readable than composition. No comments explain custom behavior. While method has clear purpose the implementation pattern significantly hinders quick comprehension.","tokens":1366,"name":"132.jsnp"}
{"score":"70","reasoning":"Code has clear naming and structure but suffers from complex boolean logic requiring careful parsing. Deep method chaining creates coupling. Field context isDriver/isInitiator is unclear. The flush condition should be extracted to a helper method. Comment is helpful but overall logic density reduces immediate comprehension.","tokens":1910,"name":"184.jsnp"}
{"score":"60","reasoning":"Code suffers from deep nesting via anonymous inner class, dual boolean parameters creating complexity, and confusing exception handling. The finally block\u0027s conditional check after assertFalse is redundant. External variable dependencies (cm, tm, KEY1) lack context. Method name is descriptive and formatting is consistent, but test logic requires significant domain knowledge about PutFromLoadValidator, reducing overall comprehension.","tokens":1515,"name":"173.jsnp"}
{"score":"45","reasoning":"Raw List type forces unsafe casts reducing type safety and clarity. Overly complex method call with 6 parameters including inline conditionals. Dense ternary operators for suffix selection. Inconsistent formatting hampers visual flow. Logic is understandable but syntax choices create unnecessary cognitive load.","tokens":2545,"name":"34.jsnp"}
{"score":"90","reasoning":"Code demonstrates excellent readability through consistent formatting and a clear repetitive pattern. Each line follows identical structure making it easy to scan and understand JDBC to database type mappings. Method names are descriptive and purpose is immediately obvious. Minor deduction for minimal Javadoc comment that states the obvious without adding contextual value about the dialect or placeholders.","tokens":1700,"name":"25.jsnp"}
{"score":"68","reasoning":"The code has a critical naming flaw: the Stack variable is misleadingly called \u0027queue\u0027, which severely impacts comprehension. The test method name \u0027testHHH1780\u0027 is cryptic. However, the inline comment clarifies the Verifier\u0027s purpose, and the test structure is simple. The logic is correct but requires careful reading due to the naming issues. The \u0027false\u0027 parameter in doParse is unexplained. Overall, understandable but hampered by poor naming.","tokens":2741,"name":"87.jsnp"}
{"score":"72","reasoning":"Method is clearly named and indented but repetitive add() calls create verbosity. Uses concrete HashSet type instead of interface and fully qualified Collections class. Easy to understand purpose but modern Java features like Set.of() would greatly improve conciseness and readability.","tokens":2358,"name":"16.jsnp"}
{"score":"55","reasoning":"Deep nesting and repetitive handler calls reduce clarity. Inconsistent formatting with misaligned parameters creates visual noise. Magic number event type ranges are not self-documenting. The ANY_EVENT branch inconsistently excludes generator listeners, creating potential confusion. Missing comments explaining dispatch logic. While variable names are clear, the structure requires careful study to understand event routing and identify potential edge cases.","tokens":2051,"name":"43.jsnp"}
{"score":"70","reasoning":"The code demonstrates moderate readability with clear test structure and descriptive naming. However, terse variable names, minimal visual separation between logical sections, lack of assertions, and a suppressed warning annotation without context hinder comprehension. The TODO comment provides helpful technical context, but overall the code requires domain knowledge about Hibernate to fully understand its intent.","tokens":1722,"name":"80.jsnp"}
{"score":"72","reasoning":"Method has clear purpose and logical flow but suffers from inconsistent formatting, potential resource leak with unclosed InputStream, minimal error handling, and abbreviated variable names. While understandable to experienced developers, these issues reduce maintainability and robustness.","tokens":1585,"name":"194.jsnp"}
{"score":"70","reasoning":"Test shows clear structure and intent but suffers from abbreviated variable names like ep and rtn, extremely long framework class names, and complex chained operations requiring deep domain knowledge. The mix of standard and custom assertions adds slight cognitive overhead. Overall readability is moderate due to Hibernate internal complexity.","tokens":1753,"name":"142.jsnp"}
{"score":"78","reasoning":"Clear Javadoc and logical structure. Good error handling. Main issues: long method chain on session object is hard to parse. Complex boolean condition with double negation reduces clarity. Long parameter list but names are descriptive. Overall readable for domain experts.","tokens":2215,"name":"33.jsnp"}
{"score":"40","reasoning":"Inconsistent indentation and cryptic variable names severely impact readability. Duplicated logic for row retrieval and flawed final logic where setTarget overwrites previous call. Missing null safety for sel unexpected side effect with numJumpToRelated counter and no comments. Code is confusing and error prone.","tokens":2094,"name":"10.jsnp"}
{"score":"68","reasoning":"Overly verbose method name testing multiple scenarios in one method. Comments help but code relies on external TestData context and magic values. Sequential filter enabling creates state dependency. Should be split into focused tests with named constants for filters and parameters to improve readability.","tokens":1930,"name":"91.jsnp"}
{"score":"78","reasoning":"Well-documented method with clear Javadoc and helpful inline comments explaining design decisions. Good naming conventions. Logic structure using nested try-finally blocks is correct but requires careful reading. Complex generic type signature with multiple bounds adds cognitive load. Overall readable for experienced Java developers familiar with Hibernate patterns.","tokens":1866,"name":"110.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear Javadoc, standard equals() implementation pattern, and straightforward field comparisons. Each step is explicitly separated making it easy to follow. Minor deduction for potential floating-point precision issues if fields are double and for verbosity that could be simplified, but overall highly comprehensible for developers of any level.","tokens":1801,"name":"114.jsnp"}
{"score":"78","reasoning":"The method has clear logic and good naming but suffers from inconsistent indentation and spacing. The try-finally block is correct but outdated compared to try-with-resources. The line break in cmd.setScale parameters is awkward. Overall structure is sound and understandable despite formatting flaws.","tokens":1889,"name":"49.jsnp"}
{"score":"45","reasoning":"Clear method name but poor implementation readability. Abbreviated parameter name ps lacks clarity. Type cast to SessionImplementor exposes internal API. Long method chain is complex. Catching Throwable with empty block is a major anti-pattern that silently hides all exceptions and errors, severely impacting debuggability and comprehension. Inconsistent formatting reduces visual clarity.","tokens":1690,"name":"95.jsnp"}
{"score":"70","reasoning":"Creates test instances via reflection. Logic is clear but hampered by unhelpful poetic Javadoc comment, nonstandard modifier order, verbose exception handling blocks, and an unnecessary final type cast. Variable naming is acceptable. Understandable for experienced developers but lacks clarity for broader audiences.","tokens":1858,"name":"2.jsnp"}
{"score":"82","reasoning":"Clear test name and structure with explanatory comments for HiLo scenarios. Good variable naming and logical flow. Minor readability issues: magic number -1 lacks context, comment typos, and dual scenarios in one method reduce focus. Casting and required algorithm knowledge slightly hinder comprehension. Well-written overall but would benefit from scenario separation and clearer magic value documentation.","tokens":2398,"name":"56.jsnp"}
{"score":"58","reasoning":"Method name is clear and JPA spec references help but core logic is confusing. Loops process fieldAccessMap to populate propertyAccessMap and vice versa with inverted conditions. Variable names contradict operations, indentation is inconsistent, and debug messages are misleading. High cognitive load required to understand the intent. Redundant structure could be refactored.","tokens":2170,"name":"27.jsnp"}
{"score":"70","reasoning":"Good Javadoc and naming but major code duplication reduces readability. Magic number -10 is unclear. Raw Vector requires casts. Extracting a helper method would eliminate duplication and improve clarity. Understandable but outdated patterns hinder comprehension.","tokens":1875,"name":"121.jsnp"}
{"score":"50","reasoning":"Code suffers from excessive method chaining and repeated casting to SessionImplementor making it hard to read. The anonymous inner class adds unnecessary verbosity. Long chained calls reduce clarity. While test intent is clear from comments, the implementation is overly complex and not easily comprehensible.","tokens":1574,"name":"94.jsnp"}
{"score":"70","reasoning":"The method has a descriptive name and clear parameter types. Early null check improves readability. However, inconsistent indentation and spacing throughout the code create visual noise. The comments are poorly formatted and distracting. The instanceof check uses uncommon syntax. While the logic flow is understandable, these style inconsistencies reduce overall comprehension. The nested conditions and casting add slight complexity.","tokens":1851,"name":"147.jsnp"}
{"score":"88","reasoning":"Clear descriptive method name and JavaDoc explain purpose well. Uses standard JUnit patterns with anonymous inner class overriding single method. Implementation is minimal and focused. Minor deductions for anonymous class verbosity and hidden dependencies on parent class fields (fNotifier) and test logic in AbstractConcurrentFailuresTest.test(). Overall highly readable for developers familiar with Java testing patterns.","tokens":1076,"name":"53.jsnp"}
{"score":"75","reasoning":"Test method demonstrates clear structure with proper setup and teardown. Anonymous inner class adds verbosity making SQL execution harder to follow. Dialect-specific conditional logic and lengthy annotation comment increase cognitive load. Overall readable for Hibernate developers but nested callbacks and quote handling reduce clarity.","tokens":1356,"name":"69.jsnp"}
{"score":"85","reasoning":"Method name clearly indicates testing keyword-as-identifier edge cases. Each parse call is a distinct test case on its own line making it easy to follow. Comments are informal but effectively convey the pathological nature of tests. The single commented-out parse call without explanation is confusing. Could benefit from blank lines grouping related tests. Despite testing inherently confusing HQL syntax the test structure itself is clean and comprehensible.","tokens":1576,"name":"86.jsnp"}
{"score":"88","reasoning":"Standard equals pattern with clear structure and proper null handling. Easy to follow logic with consistent indentation. Minor deductions for verbose pre-Java 7 style null check and very long class name. super.equals may be redundant. Highly readable but slightly dated.","tokens":1705,"name":"169.jsnp"}
{"score":"35","reasoning":"Inconsistent naming conventions mixing underscore prefixes with regular names. Improper indentation makes the long boolean chain hard to read. Dangerous null handling pattern (\u003d\u003d || equals()) risks NullPointerExceptions. Commented-out code reduces clarity. Inconsistent array comparison approaches manual loop versus Arrays.equals. Monolithic structure with repetitive logic and latent bugs requires significant effort to understand.","tokens":3290,"name":"74.jsnp"}
{"score":"88","reasoning":"Clear method name and descriptive parameters. Consistent variable naming eachClass eachMethod eachField. Proper indentation shows hierarchy. Helpful comment explains deterministic sorting. Minor issues: lengthy signature could be multiline and fClass field reference is slightly cryptic. Overall logic is straightforward for reflection-based scanning making it highly readable.","tokens":1556,"name":"52.jsnp"}
{"score":"65","reasoning":"Test method has clear naming but suffers from deep nested method calls requiring inside-out parsing. The long fully qualified class name string literal adds to cognitive load. While line breaks help, intermediate variables would significantly improve readability by reducing nesting and making the assertion\u0027s intent more immediately apparent.","tokens":1200,"name":"165.jsnp"}
{"score":"75","reasoning":"Test purpose is clear with good structure and descriptive assertions. However, boolean variable names are excessively long, reducing scanability. The loop is straightforward but could be more concise with modern Java features. Overall comprehension is solid but requires unnecessary mental overhead from verbosity.","tokens":1796,"name":"161.jsnp"}
{"score":"85","reasoning":"Test method shows good readability with clear naming, descriptive annotations, and comprehensive comments explaining the JIRA issue. Structure follows setup execute cleanup pattern. Test cases include helpful messages. Minor deductions for dense comment block and external checkCounts method dependency, but overall well documented and maintainable.","tokens":2229,"name":"78.jsnp"}
{"score":"70","reasoning":"Moderately readable with clear structure and logical grouping. Suffers from magic numbers 20, 30, 900, duplicate setAutoResizeMode call, minimal Javadoc, and mixes UI setup with initialization. Variable names are decent but abbreviations like sp reduce clarity. Hardcoded strings and implicit table field dependency are concerns. Understandable but needs refactoring for maintainability.","tokens":2257,"name":"118.jsnp"}
{"score":"45","reasoning":"Severe repetition with 11 nearly identical lines. Inconsistent spacing in arrays reduces clarity. Boolean arrays lack descriptive names or comments explaining test purpose. Deep nesting of method calls compounds issues. While method name is descriptive, a data-driven approach with loops or parameterized tests would eliminate redundancy and greatly improve maintainability and readability.","tokens":2397,"name":"59.jsnp"}
{"score":"72","reasoning":"Java method with clear naming and structure but suffers from deep method chaining and casting. The nested calls like getCollectionReferenceAliases().getCollectionColumnAliases().getSuffix() require mental tracking of return types. Conditional block for many-to-many is well isolated. Overall readable for ORM context but could be improved by extracting intermediate variables.","tokens":1363,"name":"182.jsnp"}
{"score":"20","reasoning":"Code uses single-letter variables and class names making it extremely cryptic. No comments explain the purpose. Mixes domain relationship cleanup with persistence logic without separation. Repetitive patterns lack abstraction. Method is overly long and tries to do too much. Understanding requires deep external context about the object model. Naming violates basic readability principles.","tokens":1221,"name":"200.jsnp"}
{"score":"68","reasoning":"Excellent top comments explain the Mammal/Animal/Human hierarchy and bug context. Descriptive method name and JIRA annotation. However, the code is overly repetitive with 12 similar SyntaxChecker calls. No inline comments explain individual test case purposes. Dense structure hinders quick comprehension. The distinction between checkIterate() and checkAll() requires external knowledge. Refactoring to a data-driven approach would significantly improve readability.","tokens":2452,"name":"79.jsnp"}
{"score":"55","reasoning":"The code uses cryptic ternary operators for null checks that are difficult to parse mentally. Variable naming is confusing (cidDetailID) and doesn\u0027t clearly indicate it\u0027s the other object for comparison. While it follows the standard equals pattern and handles nulls correctly, the compact syntax sacrifices readability. Modern Java\u0027s Objects.equals() would be much clearer. The inconsistent brace style also detracts from clarity.","tokens":1215,"name":"70.jsnp"}
{"score":"65","reasoning":"The code has moderate readability issues. The first if statement combines three OR conditions with inline comments making lines long. The nested if logic checking a subset of the outer condition is confusing and requires careful tracing. Formatting is inconsistent with the closing parenthesis on a separate line. The exception message construction is split across lines. While method name and comments are helpful, the complex conditional structure and poor formatting hinder quick comprehension.","tokens":1663,"name":"29.jsnp"}
{"score":"70","reasoning":"The test has good explanatory comments and clear structure with proper setup and cleanup. However the method name is overly verbose, variable naming is inconsistent (s, sr vs silly), and the code is dense with domain-specific complexity. The try-catch block is compact but readable. Overall moderately easy to comprehend for Hibernate developers but could be improved with more descriptive variable names and slightly better formatting.","tokens":1520,"name":"75.jsnp"}
{"score":"80","reasoning":"The code demonstrates clear constructor delegation with good Javadoc documentation. Formatting is clean with each parameter on a separate line. However, the five consecutive boolean literals, even with inline comments, reduce readability. Named constants or a builder pattern would improve comprehension. The numeric default constants are well-used. Overall, it\u0027s above average but not exemplary due to the magic booleans.","tokens":1681,"name":"4.jsnp"}
{"score":"88","reasoning":"Code demonstrates good readability with descriptive naming conventions and clear separation of concerns. The constructor\u0027s purpose is immediately apparent. Minor improvements could include consistent spacing between registry calls and potentially refactoring repetitive listener registration pattern. The Hibernate-specific casting is acceptable within its domain. Overall structure is logical and easy to follow for developers familiar with the framework.","tokens":1196,"name":"139.jsnp"}
{"score":"72","reasoning":"Code demonstrates clear variable naming and logical structure for JPA Criteria API usage. The correlated subquery pattern is correctly implemented and readable for those familiar with the API. However, the test lacks assertions which is a critical omission. The Criteria API\u0027s inherent verbosity and generic syntax noise reduce readability. More comments explaining the correlation concept would help. Overall decent readability despite the complex domain.","tokens":1176,"name":"163.jsnp"}
{"score":"88","reasoning":"The test method demonstrates good readability with clear variable names and a consistent test pattern. Each step logically progresses through cache mode combinations, making the mapping between JPA hints and Hibernate cache modes explicit. While the method is somewhat long and contains repetitive assertion patterns, the linear flow and descriptive assertions make it easy to comprehend. The casting chain is verbose but necessary for testing integration points.","tokens":1531,"name":"162.jsnp"}
{"score":"48","reasoning":"Code suffers from inconsistent formatting, raw types, and poor naming. Assertions inside loop with verbose messages reduce clarity. Broad exception handling and mixing logging with test logic create confusion. Magic strings and deprecated API usage further hinder readability. Structure is functional but lacks modern practices like try-with-resources.","tokens":2093,"name":"137.jsnp"}
{"score":"68","reasoning":"Short variable names s and t hurt readability. Child naming like child_1_1 with cryptic strings is confusing. Interleaved save order and mid-method flush break flow. However the logical structure and clear intent to create parent-child test data make it comprehensible despite these issues.","tokens":2417,"name":"76.jsnp"}
{"score":"78","reasoning":"Method is concise with clear naming and helpful comments explaining each SQL state case. Uses consistent pattern for constraint extraction. However relies on magic numbers without named constants making maintenance harder. Hardcoded template strings and ambiguous null returns reduce clarity. NumberFormatException handling is broad. Overall structure is logical and easy to follow for its limited scope.","tokens":1187,"name":"22.jsnp"}
{"score":"78","reasoning":"Descriptive method name follows AAA pattern. Variable names mostly clear except cryptic fMax. Anonymous inner class is verbose and lacks diamond operator. Missing context for class fields. Understandable for JUnit developers but needs better naming and modern syntax.","tokens":2187,"name":"124.jsnp"}
{"score":"60","reasoning":"Method name testEscapedJDBC is cryptic and does not explain the case-insensitive query test purpose. Unused variables savedB and count create confusion. Repetitive session transaction management is verbose and clunky. Dialect-specific logic is well-commented but the overall structure is inefficient. SQL syntax is appropriate but test intent is obscured by poor naming and unnecessary code.","tokens":2186,"name":"71.jsnp"}
{"score":"72","reasoning":"Test method shows clear structure and intent with descriptive name and proper resource cleanup. However readability suffers from repetitive property setup, magic numbers without constants, duplicated assertion patterns for entity and collection regions, and an unclear factory.getCacheManager() call. Long property keys and necessary casting add noise. Overall decent but could be improved by extracting helper methods and using named constants.","tokens":1978,"name":"130.jsnp"}
{"score":"80","reasoning":"Well-structured Hibernate internal code with clear JavaDoc and descriptive naming. Good inline comments explain rationale. Complexity is inherent to domain. Minor issues: long for-each line could be split, commented-out code slightly distracting. Requires framework knowledge but logic flow is clear. Overall solid readability for advanced developers.","tokens":1815,"name":"66.jsnp"}
{"score":"78","reasoning":"Test name and comments clearly explain the JPA spec being tested. Structure follows arrange-act-assert pattern well. Main readability issue is the overly complex assertion with deep method chaining that requires careful parsing. Session management is verbose with manual open and close. Variable names are decent but could be more descriptive. Overall good for a complex Hibernate test case.","tokens":2220,"name":"134.jsnp"}
{"score":"90","reasoning":"Clear Javadoc explains purpose parameters and exceptions. Simple if-else logic with descriptive method names. TODO provides context. Minor density in combined null and enum check but remains idiomatic Java. Well-structured and easy to follow.","tokens":1053,"name":"32.jsnp"}
{"score":"48","reasoning":"Test method lacks assertions making it ineffective. Reuses results variable for 18 queries reducing traceability. No comments explain query purposes. Complex nested functions lack context. The suppress warnings annotation indicates code smells. Method name is clear and setup teardown pattern is correct but overall readability suffers from query density and lack of documentation.","tokens":2504,"name":"83.jsnp"}
{"score":"70","reasoning":"Uses verbose generic syntax adding unnecessary noise. Multi-line ternary operators are consistent but hinder scanning. Repetitive pattern could use a helper method. Logic is clear but syntax choices reduce readability. Modern Java features would improve clarity.","tokens":2147,"name":"196.jsnp"}
{"score":"75","reasoning":"Anonymous inner class is verbose versus lambda but clear. Qualified this syntax can confuse beginners. Good try-finally ensures cleanup. Comment explains workaround context. Short focused method with understandable intent despite legacy style.","tokens":1665,"name":"1.jsnp"}
{"score":"50","reasoning":"Inconsistent indentation and raw Set type severely impact readability. Poor variable naming (set), repetitive Model.getFacade() calls, and returning null instead of empty set are problematic. Core logic is understandable but hampered by style and design issues.","tokens":1639,"name":"123.jsnp"}
{"score":"88","reasoning":"Method is concise with clear naming and single responsibility. Parameter list is well-structured. The strategy pattern implementation is straightforward. Minor deductions for abbreviated parameter name \u0027sf\u0027 and unconventional closing parenthesis placement. Domain-specific terms are appropriate for Hibernate context. Overall highly readable with minimal cognitive load.","tokens":1300,"name":"143.jsnp"}
{"score":"85","reasoning":"Method demonstrates clear intent with descriptive naming and consistent registration pattern for transaction factories. Each factory type is registered with both short name and fully qualified name, making the dual-registration strategy obvious. While repetitive, the pattern enhances comprehension. Minor improvement would be extracting duplicate logic into a helper method or loop, but current form is highly readable and immediately understandable.","tokens":2968,"name":"171.jsnp"}
{"score":"58","reasoning":"Code has clear structure and reasonable naming but suffers from ambiguous intent. The final line gets a value without assertion or comment, leaving purpose unclear. Missing verification of actual implicit joining behavior. No comments explain the test scenario. Casting adds minor noise. Overall comprehension is hindered by incomplete validation and lack of documentation.","tokens":1501,"name":"128.jsnp"}
{"score":"72","reasoning":"The test has clear intent via descriptive name and helpful annotations. Core logic follows AAA pattern and is easy to follow. However, repetitive session/transaction boilerplate creates noise and reduces focus. Raw List type and lack of helper methods show outdated patterns, increasing cognitive load. Overall structure is sound but could be more concise with modern testing practices.","tokens":1623,"name":"77.jsnp"}
{"score":"88","reasoning":"The code demonstrates excellent readability with clear Javadoc documentation, descriptive naming conventions, and a consistent serialization pattern. The method follows standard Java serialization practices, making it immediately recognizable to experienced developers. While the repetitive utility calls are slightly verbose, they enhance clarity by explicitly showing each serialized field. The structure is clean, well-formatted, and easy to comprehend.","tokens":1469,"name":"38.jsnp"}
{"score":"82","reasoning":"Well-documented method with clear Javadoc explaining purpose and parameters. Code structure uses good practices like early returns and descriptive variable names. Logic flow is linear and easy to follow. Main readability issue is the final constructor call with nine parameters which requires careful tracking. Inconsistent logging format (tracef vs string concatenation) and necessary suppressed warnings slightly reduce clarity. Overall solid readability for framework-level code dealing with complex metadata.","tokens":1615,"name":"84.jsnp"}
{"score":"45","reasoning":"Uses raw types and legacy Vector harming type safety. Unnecessary variable cr and cryptic names reduce clarity. Comment acknowledges waste without fixing it. Returns List but uses Vector with addElement. Simple logic but outdated style and poor practices severely impact readability.","tokens":1367,"name":"120.jsnp"}
{"score":"75","reasoning":"Method clearly prints debug comparison between JoinWalker and LoadQueryDetails objects. Simple structure with visual separators. Minor issues: inconsistent spacing in parentheses, long concatenated line for suffixes, generic method name, and use of System.out instead of logger. Overall straightforward but could benefit from formatting improvements and better naming.","tokens":1398,"name":"144.jsnp"}
{"score":"58","reasoning":"Deep nesting with three levels and parameter reassignment reduce clarity. The double normalizeIdentifierQuoting call is confusing and potentially buggy. Long method chains and boolean flag further obscure logic. While method is short with descriptive names, implementation complexity requires careful reading to understand intent.","tokens":1952,"name":"30.jsnp"}
{"score":"60","reasoning":"Method shows moderate readability with clear conditional structure but suffers from deep nesting, heavy reliance on instance state, and complex nested conditions. Casting without null checks and magic strings reduce clarity. The backref creation block is particularly dense. While variable names are descriptive, the method mixes multiple concerns and lacks comments, making it harder to understand at a glance. Refactoring into smaller methods would improve comprehension.","tokens":1508,"name":"109.jsnp"}
{"score":"90","reasoning":"Clear Javadoc and standard equals pattern. Good variable names and structure. Proper null handling with explicit checks. Logic is straightforward: reference check, type check, structural comparison, then cell-by-cell value comparison. Slightly verbose but very readable and maintainable.","tokens":1557,"name":"40.jsnp"}
{"score":"55","reasoning":"Variable naming is misleading as lists is a map not a list. Uses inefficient contains then get pattern. Outdated Enumeration API instead of Iterator. Mixed indentation and informal comments with typos. Caching logic is clever but not clearly explained. Javadoc has spelling errors and lacks clarity about the data structure. Overall understandable but requires careful reading due to multiple style and efficiency issues.","tokens":2646,"name":"44.jsnp"}
{"score":"42","reasoning":"Deep nesting with 4 to 5 levels makes logic hard to follow. Poor variable names like nod and comp reduce clarity. Comments interrupt boolean conditions. Redundant else if encloser null check. Method mixes responsibilities setting enclosure and managing layer contents. Static helper calls obscure logic. Inconsistent formatting. Overall structure is convoluted requiring significant effort to understand.","tokens":3809,"name":"155.jsnp"}
{"score":"45","reasoning":"Code has excessive nesting 4+ levels deep and hidden side effects on class fields filter/parserErrors. Uses magic strings complex boolean conditions and tricky index manipulation. Method signature suggests pure function but modifies external state making it hard to understand in isolation. Error handling is present but return logic with copyArray is unclear. High cognitive load poor maintainability.","tokens":1929,"name":"15.jsnp"}
{"score":"40","reasoning":"Code has poor variable naming (f, fr, mAry), redundant null checks, manual resource management instead of try-with-resources, inefficient string concatenation in loop, and swallowed exceptions. The while-if-null pattern is confusing and the logic duplication reduces clarity. Missing context for getSectId and mAry makes behavior unclear. Overall structure is functional but requires significant effort to understand and maintain.","tokens":2422,"name":"48.jsnp"}
{"score":"60","reasoning":"Code uses raw Vector type without generics reducing type safety and clarity. Repetitive addElement calls are verbose and outdated. Minimal Javadoc lacks context. While method structure is simple and constant names are descriptive, modern Java practices would improve readability significantly.","tokens":1495,"name":"45.jsnp"}
{"score":"72","reasoning":"Clear test name and JIRA context. Comments explain operations well. Weaknesses: generic variable name \u0027it\u0027, typo \u0027excpect\u0027 in assertion, combines multiple scenarios, tests a dense caching edge case requiring domain knowledge. Structure is sound but needs polish.","tokens":1854,"name":"179.jsnp"}
{"score":"60","reasoning":"Test has clear name and logical flow but excessive casting between SessionImplementor Session and TransactionImplementor hurts readability. Repetitive assertions necessary for state verification but make it verbose. Relies on implicit knowledge of JTA Hibernate internals. The getFlushMode side effect is obscure even with comment. Moderate comprehension for domain experts but steep for others.","tokens":2257,"name":"127.jsnp"}
{"score":"35","reasoning":"ANTLR generated parser method with poor readability. Non-standard variable naming using underscores and cryptic abbreviations like _ttype _saveIndex. Contains unused variable. No comments. Requires framework knowledge to understand LA matchRange makeToken methods. Overly verbose for simple hex digit matching. Inconsistent formatting. Functional but follows machine generated patterns not human readable conventions.","tokens":2703,"name":"117.jsnp"}
{"score":"75","reasoning":"Method demonstrates good naming conventions and clear structure with descriptive comments. The recursive pattern is consistent and logic flows well. However it mixes entity key resolution with state hydration which reduces single responsibility clarity. The CompositeFetch branch lacks symmetry by not calling hydrateEntityState creating potential confusion. Type checking via isInstance and casting is verbose but understandable. Overall readability is solid for complex ORM domain logic.","tokens":1811,"name":"197.jsnp"}
{"score":"68","reasoning":"Inconsistent indentation and commented-out code reduce clarity. Deep nesting of tooltip logic with redundant getJComponent() calls makes the flow harder to follow. Variable naming is acceptable but could be improved. Logic is understandable but requires effort to parse. Separation of concerns is reasonable but could benefit from blank lines or extracted methods.","tokens":1876,"name":"122.jsnp"}
{"score":"45","reasoning":"Code suffers from extremely long class names and unconventional formatting with awkward line breaks and misplaced parentheses. This makes it hard to parse visually. While the test intent is clear verify revision counts the execution is verbose and repetitive. Lack of comments and context for test data further reduces comprehension. Standard formatting and helper methods would significantly improve readability.","tokens":1564,"name":"185.jsnp"}
{"score":"72","reasoning":"Long if-else chain with repetitive patterns and nested conditionals reduces readability. Good naming and consistent structure help comprehension. Commented code and string concatenation are minor issues. Overall moderately readable but could benefit from refactoring.","tokens":1836,"name":"108.jsnp"}
{"score":"45","reasoning":"Poor variable naming with cryptic abbreviations like mee trCollection. Contains serious bug using \u003d\u003d for string comparison instead of equals method noted by TODO comment. Code duplication for incomingoutgoing cases. Unsafe type casts from Object to Collection. Inconsistent brace style. Magic strings hardcoded. Anonymous inner class adds nesting. Lacks null safety checks. Overall difficult to comprehend and maintain.","tokens":2185,"name":"154.jsnp"}
{"score":"78","reasoning":"Clear test intent with descriptive method name and proper exception handling. Nested try-catch-finally blocks enable good resource management. Variable names are somewhat terse but acceptable for tests. Comments and logging aid comprehension. Deep nesting slightly reduces readability but overall structure is logical and follows Hibernate testing patterns well.","tokens":2303,"name":"129.jsnp"}
{"score":"80","reasoning":"Clear method name and variable names make intent obvious. Boolean flags are set verbosely using separate if statements instead of direct assignment. Unnecessary copying of annotation values before early return check. Conditional blocks for schema and catalog are repetitive. Minor spacing inconsistencies. Overall logic is straightforward but implementation could be more concise.","tokens":1937,"name":"195.jsnp"}
{"score":"72","reasoning":"Code has clear structure and variable names but suffers from ambiguous method/field calls like getSqlTypeCode(), verbose string concatenation in exception messages, minor grammatical error, and inconsistent spacing. The try-catch logic is sound but the exception message construction spans multiple lines making it harder to follow. Overall decent readability with room for improvement.","tokens":2108,"name":"37.jsnp"}
{"score":"80","reasoning":"Uses StringBuilder efficiently with clear field\u003dvalue pattern. Intent is obvious to Java developers. Indentation is inconsistent reducing visual flow. Mixing this.field with this.getter() is slightly confusing. Structure is logical and conventional. Minor formatting fixes would improve readability significantly.","tokens":1565,"name":"63.jsnp"}
{"score":"88","reasoning":"Method shows clear logic flow with well-structured if-else chain for Test subtypes. Recursive suite processing is easy to follow. Variable names are concise and meaningful. The instanceof checks are verbose but typical for this pattern and do not hinder understanding. Formatting is consistent and the final comment clarifies the default case. Overall highly readable with minor verbosity from type casting.","tokens":1822,"name":"54.jsnp"}
{"score":"65","reasoning":"Clear test structure for HiLo algorithm but marred by repetitive code and excessive casting noise. Critical flaw: comment contradicts code, stating first value should be 4 while asserting 1, causing confusion. Long separator lines are distracting. Variable names are adequate but the inconsistent comment severely undermines readability. Requires careful analysis to resolve the discrepancy and understand true behavior.","tokens":2297,"name":"17.jsnp"}
{"score":"58","reasoning":"Raw type List missing generics reduces type safety. Side effects on instance fields create hidden dependencies. Magic strings lack named constants. No comments explain model element handling. Iterator pattern is verbose. Variable names v and sep are terse. Underscore prefixes are outdated. Logic is understandable but has maintainability issues.","tokens":3090,"name":"8.jsnp"}
