{"score":"60","reasoning":"The test method has good coverage of SQL variants and uses a helper method for DRYness but suffers from poor readability. Key issues: no documentation explaining what no loss means inconsistent indentation mixing tabs and spaces monolithic structure with many assertions and SQL strings lack internal formatting making complex queries hard to parse. The code is functional but would benefit from splitting into multiple named tests adding comments and proper SQL formatting within strings.","tokens":1406,"name":"101.jsnp"}
{"score":"90","reasoning":"Excellent readability with descriptive naming and clear Javadoc. Test structure logically separates scenarios using meaningful variable names and clean assertions. Inline comments effectively clarify dialect behavior differences. Minor deduction for lengthy method name but follows JUnit patterns well and is highly comprehensible.","tokens":1352,"name":"57.jsnp"}
{"score":"85","reasoning":"Clear and consistent structure with each function registration on separate lines. Descriptive function names and standard SQL template placeholders make intent obvious. Minimal Javadoc is adequate. Repetitive pattern is typical for dialect configuration and not a readability issue. Easily understood by developers familiar with Hibernate dialects.","tokens":1291,"name":"21.jsnp"}
{"score":"45","reasoning":"Excessively long method name, verbose anonymous inner classes, repetitive casting, and deeply nested assertions reduce readability. Conditional logic and framework dependencies require external context. While the HQL query is clear, the overall structure is cumbersome and difficult to follow at a glance.","tokens":1562,"name":"98.jsnp"}
{"score":"65","reasoning":"Code lacks comments and clear structure. Repetitive session/transaction management and cache eviction reduce readability. Magic strings and reused variables like mapKey create confusion. No explicit separation of test phases. Manual resource handling adds verbosity. Understandable but requires Hibernate knowledge.","tokens":1592,"name":"192.jsnp"}
{"score":"88","reasoning":"Method is straightforward with clear intent. Descriptive constants make purpose obvious. Minor issues: inconsistent use of getProperties().put() breaks pattern, abbreviated parameter name cfg, and inconsistent spacing. Still highly readable for Hibernate/JPA developers.","tokens":1504,"name":"191.jsnp"}
{"score":"75","reasoning":"Well-structured method with clear naming and helpful comments explaining purpose. Uses final keywords appropriately. However, nested method calls create long lines, heavy reliance on instance fields reduces clarity, return value is slightly confusing (returns ID element not full entity), and ternary operator could be split. Good but could improve by extracting intermediate variables and simplifying expressions.","tokens":1776,"name":"170.jsnp"}
{"score":"45","reasoning":"Code suffers from major duplication of null-setting logic appearing three times. Parameter naming is poor p instead of person. Empty else-if block is unclear without comments. Deep nesting makes flow hard to follow. Mixed responsibilities of parsing validation and relationship management. Magic string NULL used. No comments explaining business logic. While functional the maintenance burden is high.","tokens":1679,"name":"61.jsnp"}
{"score":"70","reasoning":"Test method follows standard Hibernate pattern with clear setup and teardown. However, the method name is excessively long, variable names are abbreviated, and there are no explicit assertions making the test\u0027s success criteria unclear. While understandable for Hibernate developers, these issues reduce overall readability.","tokens":1517,"name":"133.jsnp"}
{"score":"48","reasoning":"Extremely verbose class names cause line breaks and severely hurt readability. Cryptic abbreviations like ed2/ing2 and repetitive audit reader calls make comprehension difficult. Test structure is logical and assertions are clear, but require deep domain knowledge. Overall moderate readability hampered by poor naming and redundancy.","tokens":1862,"name":"186.jsnp"}
{"score":"70","reasoning":"The code shows clear intent with descriptive variable names and logical flow. However it uses outdated Java practices like raw Iterator types requiring explicit casts fully qualified class names and inconsistent formatting. The long TODO comment while informative disrupts readability. Modern generics and improved spacing would significantly enhance comprehension. Overall structure is sound but syntax issues reduce clarity.","tokens":1936,"name":"31.jsnp"}
{"score":"98","reasoning":"Clear Javadoc explains purpose parameters and return value. Method name follows factory pattern conventions. Single line implementation extracts five properties from registration. Excellent formatting with each argument on separate line maximizes readability. No complex logic. Descriptive naming makes code self-explanatory. Virtually perfect minor deduction only for parameter count which is mitigated by clean formatting.","tokens":1682,"name":"67.jsnp"}
{"score":"50","reasoning":"Excessive dialect-specific conditional logic with long repetitive instanceof chains fragments execution flow. Clear individual assertions are obscured by complex nested conditions and early returns. Dense HQL strings and inconsistent branching patterns reduce readability. Comments provide minimal help. Overall structure requires significant effort to understand full test coverage across dialects.","tokens":2073,"name":"89.jsnp"}
{"score":"62","reasoning":"Code has inconsistent indentation and alignment issues that obscure structure. Uses good delegation pattern to avoid duplication. Awkward line breaks and empty disintegrate method without comment reduce clarity. Simple logic but formatting problems significantly hinder readability.","tokens":1978,"name":"174.jsnp"}
{"score":"82","reasoning":"Descriptive method name and helpful comment. Verbose but clear variable names. Handles non-deterministic ordering via conditional block with repetitive assertions. Requires Hibernate entity binding knowledge. Logical structure but could be streamlined. Good readability with moderate complexity.","tokens":2331,"name":"181.jsnp"}
{"score":"65","reasoning":"Test method name clearly indicates purpose. Uses standard JUnit negative test pattern with try-catch. However the HQL query string is dense and unreadable as a single line. Resource management is flawed: Session.close() is not in finally block risking leaks. Could benefit from try-with-resources and multi-line query formatting. Overall structure is understandable but implementation details reduce comprehension.","tokens":1992,"name":"81.jsnp"}
{"score":"78","reasoning":"Test method shows good structure with clear naming and proper cleanup. Comment explains scenario well. However dense property setup with verbose keys reduces readability. Duplicate assertion and magic numbers without constants are minor issues. Overall logic is followable for domain-aware developers but could benefit from extracted helper methods or constants.","tokens":2328,"name":"131.jsnp"}
{"score":"35","reasoning":"Code suffers from cryptic variable names loBits hiTime loTime excessive magic numbers 8 2 4 0x3f and noisy inconsistent print statements. Complex bit manipulation lacks comments explaining purpose making intent unclear. Potential bug with truncating cast to short. Unusual spacing in for loop. Dependencies on unknown helper classes add confusion. Sequential structure is clear but overall maintainability is poor.","tokens":2514,"name":"58.jsnp"}
{"score":"65","reasoning":"Clear method structure and parameter names but contains critical bug: missing closing parenthesis in tuple string. Inconsistent static method calls StringHelper.replace vs replace. Heavy reliance on undefined helpers repeat joinWithQualifier reduces clarity. Parameter ids is misleadingly unused except for length. Minimal comments help but insufficient for complex composite key logic.","tokens":2248,"name":"112.jsnp"}
{"score":"65","reasoning":"Method shows clear intent of binding source to target but suffers from major readability issues. Duplicate if-blocks checking CustomPersisterClassName with different conditions and contexts create confusion and suggest a bug. Hidden dependencies on instance variables currentBindingContext and metadata reduce clarity. Inconsistent whitespace and verbose generic syntax further hinder comprehension. Otherwise straightforward sequential structure.","tokens":2488,"name":"146.jsnp"}
{"score":"78","reasoning":"Code demonstrates moderate readability with clear variable names and logical structure. First comment is grammatically awkward causing slight confusion. The eventLimit logic with its zero and negative value distinctions requires careful reading. Early return pattern is good. Method length is appropriate. Comments are present but inconsistent quality. Overall comprehension is reasonable but not immediate.","tokens":1520,"name":"151.jsnp"}
{"score":"68","reasoning":"Clear method name and helpful annotations. Verbose anonymous inner class syntax and long Hibernate API chains like ((SessionImplementor)session).getTransactionCoordinator()... reduce readability. Good comments explain intent. Proper resource management. Modern Java lambdas would improve clarity. Core logic is understandable but implementation details are overly complex.","tokens":1673,"name":"93.jsnp"}
{"score":"72","reasoning":"Code uses anonymous inner class with clear comments explaining VA/Java limitations. Try-finally ensures proper cleanup. Qualified this syntax is correct but adds slight complexity. Pre-Java 8 style is verbose compared to modern lambda alternatives. Overall structure is logical and well-documented, making it reasonably easy to follow for experienced Java developers.","tokens":1309,"name":"73.jsnp"}
{"score":"95","reasoning":"Code demonstrates excellent readability through clear method naming, consistent formatting, and logical grouping. The constructor follows a declarative pattern with straightforward JDBC type mappings to Interbase-specific types. Each registration appears on its own line with proper indentation, enabling quick scanning. Minor improvements could include more descriptive Javadoc and comments for specific type mapping decisions, but overall structure is clean and immediately comprehensible to developers familiar with Hibernate dialects.","tokens":1467,"name":"20.jsnp"}
{"score":"68","reasoning":"Code shows moderate readability with clear variable names and logical structure. However it suffers from a confusing comment containing typos and garbled text about proxy handling. The method requires deep Hibernate domain knowledge and mixes multiple concerns. The loop calling an overloaded delete method with many parameters reduces immediate comprehension. Overall decent for experienced Hibernate developers but challenging for others.","tokens":2149,"name":"106.jsnp"}
{"score":"75","reasoning":"Test method has clear structure and descriptive variable names but suffers from cryptic test name referencing issue ID, magic numbers without constants, minor style inconsistencies, and a typo in error message. Logic flow is straightforward and comment helps context. Overall decent readability with room for improvement in maintainability and clarity.","tokens":2067,"name":"90.jsnp"}
{"score":"40","reasoning":"Poor naming conventions with cryptic abbreviations ed, ing2. Repetitive code patterns for audit reader calls and assertions. Magic numbers 1-5 lack context. Uses raw Collections.EMPTY_SET instead of type-safe alternative. Lacks comments explaining test scenario. assert keyword usage instead of JUnit assertions reduces debuggability. Overall unclear what specific history scenario is being validated.","tokens":1849,"name":"166.jsnp"}
{"score":"52","reasoning":"Code uses verbose anonymous inner classes instead of modern lambdas. Excessive casting and inconsistent spacing reduce clarity. ResultChecker contains repetitive assertions and a duplicated line creating confusion. While test intent is clear, implementation is cluttered and harder to maintain than necessary. Nested method calls make it dense. Overall structure is understandable but suffers from outdated patterns and lack of polish.","tokens":1635,"name":"96.jsnp"}
{"score":"70","reasoning":"Clear method name and variables but mixes multiple concerns. Conditional logic for inheritance validation is split across two if blocks reducing clarity. Ternary operators are concise but slightly dense. Sequence of processing column value and options is logical but could be extracted into helper methods. Overall readable for experienced developers but structure could be improved for better comprehension.","tokens":1564,"name":"28.jsnp"}
{"score":"35","reasoning":"Method uses deeply nested ternary operators making logic hard to follow. Poor formatting with everything on one line increases cognitive load. Critical design flaw: doesn\u0027t override Object.equals() which violates Java conventions and causes confusion. Complex null and quoting checks should be extracted to helper methods. Overall very difficult to comprehend and maintain.","tokens":1955,"name":"36.jsnp"}
{"score":"85","reasoning":"Clear method name and structure with proper indentation. Uses @Override annotation effectively. Guard clause pattern is good. Minor deductions for empty catch block lacking explanatory comment and inconsistent spacing around parentheses. Overall very easy to comprehend for Java developers familiar with resource management.","tokens":2423,"name":"150.jsnp"}
{"score":"90","reasoning":"Method has excellent Javadoc and inline comments with descriptive naming. Well-structured code with clear conditional logic. Minor readability impact from method chaining and unexplained null parameters but overall highly comprehensible for its domain.","tokens":1875,"name":"103.jsnp"}
{"score":"45","reasoning":"Code suffers from nested loops causing O(n*m) complexity, deep casting chains that reduce clarity, and unexplained state flags. The inner loop\u0027s purpose matching targets to tree rows is not immediately obvious. Variable reassignment of \u0027target\u0027 is confusing. Commented-out code at the end suggests maintenance issues. While variable names are decent and the re-entrancy guard is good, overall structure requires significant effort to comprehend. Could be improved by extracting methods, using maps for lookup, and adding comments.","tokens":1942,"name":"50.jsnp"}
{"score":"68","reasoning":"The method follows standard equals pattern with clear identity and type checks. However the null-safe comparisons using nested ternary operators are overly complex and reduce readability. Modern alternatives like Objects.equals() would significantly improve clarity. The structure is sound but the implementation of field comparisons requires unnecessary mental parsing making it moderately difficult to comprehend.","tokens":1591,"name":"60.jsnp"}
{"score":"95","reasoning":"Excellent readability with clear Javadoc, standard equals pattern, proper instanceof and identity checks, and super class delegation. Follows Java best practices using explicit fail-fast conditions that are easy to understand. Minor verbosity in final return does not affect comprehension.","tokens":1568,"name":"39.jsnp"}
{"score":"58","reasoning":"Code has unclear geometric intent creating a diamond shape from rectangle bounds. Variable names are abbreviated (r, xs, ys, p). Magic number 5 lacks context. No comments explain the algorithm. Formatting issues include trailing commas and awkward line breaks. While method name is clear and uses a helper function, overall comprehension requires significant effort due to poor naming and lack of documentation.","tokens":2114,"name":"153.jsnp"}
{"score":"68","reasoning":"Nested anonymous classes create complexity. Complex HQL string and multiple casts reduce clarity. External dependencies like yogiExpected require context. Descriptive method name and separation of concerns help. Requires Hibernate expertise.","tokens":1971,"name":"99.jsnp"}
{"score":"48","reasoning":"The code suffers from a complex nested dialect condition with commented logic, lacks explanatory comments for test scenarios, uses magic strings without context, combines multiple unrelated queries in a single test method, and has no assertion failure messages. Dense formatting without vertical spacing further reduces readability. While functional, these issues significantly hinder comprehension of the test\u0027s intent and scope.","tokens":1689,"name":"68.jsnp"}
{"score":"40","reasoning":"Poor readability due to extremely long method chains with multiple casts, verbose anonymous inner class syntax, silent exception swallowing, mixing Hibernate and JDBC abstractions, and hardcoded SQL strings. Modern Java features like lambdas and try-with-resources would improve clarity significantly.","tokens":1199,"name":"100.jsnp"}
{"score":"78","reasoning":"Method name uses parser instead of parse violating Java conventions. Inconsistent spacing in method calls. Logic is clear with good parameter names and proper constant usage. Could reduce nesting with early returns. Unnecessary blank line before final return. Overall structure is straightforward and easy to comprehend.","tokens":1708,"name":"193.jsnp"}
{"score":"45","reasoning":"Code suffers from large commented blocks disrupting flow and logic. Variable runs is initialized but never incremented, causing confusion. Mix of active and inactive code makes actual behavior unclear. Good aspects include proper try-finally structure and conditional trace logging. Overall appears as unfinished work, significantly impairing readability and comprehension.","tokens":1562,"name":"172.jsnp"}
{"score":"35","reasoning":"Code suffers from excessive casting making it verbose and hard to follow. The index++ pattern scattered throughout verification logic is error-prone and unclear. Multiple instanceof checks and conditional blocks suggest the test handles too many scenarios at once. Method name is cryptic and doesn\u0027t clearly describe intent. While structurally sound with proper setup and assertions, the implementation details severely hinder readability and maintainability.","tokens":2763,"name":"140.jsnp"}
{"score":"75","reasoning":"Code is moderately readable with clear logic flow and mostly descriptive naming. The nested if structure appropriately handles event types. Minor issues include non-standard formatting with leading operators, generic variable obj, and hardcoded property name. Comments are minimal but helpful. Requires familiarity with PropertyChangeEvent pattern and Model facade for full comprehension.","tokens":2242,"name":"47.jsnp"}
{"score":"72","reasoning":"The test has clear structure and reasonable variable names but suffers from a generic method name, confusing duplicate password entries, and non-obvious logic that requires understanding the implementation of getConnectionProperties. The rpt prefix pattern is unclear without context, and magic strings reduce maintainability.","tokens":1980,"name":"35.jsnp"}
{"score":"50","reasoning":"Inconsistent indentation and spacing, unclear variable names (mInterface, ffCodePiece), commented-out code, and undefined \u0027name\u0027 variable reduce readability. The logic is straightforward but requires context to understand null writer usage and stack management. Comments are minimal and don\u0027t fully explain intent.","tokens":1384,"name":"116.jsnp"}
{"score":"78","reasoning":"Test method has clear purpose and structure. SQL query and expected result are explicitly defined. Main readability issue is the multi-line string concatenation for expected SQL which breaks flow and indentation. Method name is long but descriptive. Annotations provide good context. Overall comprehension is good despite complex SQL but string formatting could be improved.","tokens":1343,"name":"23.jsnp"}
{"score":"40","reasoning":"Misleading method name suggests processing but always returns null. Unused entityType parameter indicates incomplete implementation. Vague comment about cascade handling lacks clarity. Inconsistent spacing harms readability. Purpose requires deep Hibernate knowledge. Overall structure is poor and intent is unclear, making comprehension difficult.","tokens":1539,"name":"65.jsnp"}
{"score":"70","reasoning":"The code has clear naming and helpful comments but suffers from inconsistent indentation making control flow hard to follow. Raw type usage for Iterator reduces type safety and clarity. The logic is understandable but formatting issues and outdated Java practices significantly impact readability.","tokens":1600,"name":"7.jsnp"}
{"score":"68","reasoning":"The method has clear parameter names and logical structure but suffers from a complex three-part conditional check with deep method chaining that reduces immediate comprehension. The nested if-else blocks increase cognitive load, though the comment helps explain the special case. Domain-specific Hibernate terminology adds inherent complexity. Could be improved by extracting the condition into a named method and reducing nesting levels. Overall moderately readable for those familiar with the framework.","tokens":1568,"name":"198.jsnp"}
{"score":"88","reasoning":"Clear method name and standard JPA patterns make this highly readable. Minor issues include the undeclared country field, vague Revision 1 comment, and magic number 123. Overall structure is clean with good indentation and logical flow. Developers familiar with testing and JPA will understand it easily.","tokens":1579,"name":"168.jsnp"}
{"score":"55","reasoning":"Deep nesting with inconsistent indentation and awkward line breaks hampers readability. Uses nested if-else instead of else-if chain creating unnecessary complexity. Contains redundant logic in final else clause. Simple mapping logic is obscured by poor structure and could be simplified significantly.","tokens":1284,"name":"157.jsnp"}
{"score":"45","reasoning":"Inconsistent formatting mixes tabs and spaces. Legacy Vector/Enumeration APIs with raw types require explicit casts. Inefficient O(n*m) nested loops, unclear abbreviations, redundant method calls, and mutable path array reuse create side effects. Vague comment and unexplained magic number reduce clarity. Functional but notably hard to read and maintain.","tokens":2437,"name":"46.jsnp"}
{"score":"85","reasoning":"Clear implementation following standard equals() pattern with good structure. Each field check is explicit and easy to follow. However, Javadoc @return tag is incomplete, mentioning only second and minute while code also compares hour and day, creating potential confusion. Variable naming is conventional and logic flow is straightforward with early returns.","tokens":1541,"name":"42.jsnp"}
{"score":"95","reasoning":"Highly readable code with consistent structure and clear naming. Each line follows registerFunction(name, new FunctionType()) pattern, making SQL dialect mapping obvious. Repetitive format aids scanning despite length. Minimal Javadoc is adequate. Lacks grouping comments but remains very easy to comprehend for any developer level.","tokens":1794,"name":"18.jsnp"}
{"score":"70","reasoning":"The code demonstrates clear intent with a logical structure for building a string representation. However inconsistent indentation and line breaks disrupt visual flow. Mixed usage of this keyword and an informal comment reduce professionalism. While functional and understandable the formatting flaws moderately impact readability.","tokens":1538,"name":"64.jsnp"}
{"score":"65","reasoning":"Test method has descriptive name but suffers from a long single-line HQL query making it hard to read. Manual session management and commented debug code reduce clarity. Assertion logic is indirect and contains a typo. SuppressWarnings indicates type safety issues. Overall structure is understandable but formatting and outdated practices hinder readability.","tokens":1334,"name":"92.jsnp"}
{"score":"70","reasoning":"Moderate readability. Clear testing intent but anonymous inner classes add complexity. External dependencies (runner, output, expected()) reduce clarity. Logical flow and decent naming help, yet dated JUnit 3 style hampers modern comprehension. Could benefit from lambda expressions and better context exposure.","tokens":1541,"name":"12.jsnp"}
{"score":"70","reasoning":"The test method has a clear structure and consistent assertion patterns, making its intent understandable. However, the repetitive assertAnnotationNotPresent calls create verbosity and hurt maintainability. The method name testNoChildren is ambiguous without context. While comprehensible for domain experts, it could be significantly improved with a helper method and more descriptive naming.","tokens":1587,"name":"176.jsnp"}
{"score":"65","reasoning":"Method name is overly verbose and self-admitted as long winded. Comments explain the complex Hibernate bug but are dense. Requires deep understanding of composite keys and eager fetching internals. Test structure is clear but domain model is not immediately obvious. Exception handling for OverflowCondition is non-standard. Overall functional but not easily comprehensible without significant context.","tokens":1739,"name":"175.jsnp"}
{"score":"78","reasoning":"Method name is clear and constructor parameters are well-formatted vertically. However inconsistent indentation reduces readability. The raw Map type without generics is outdated. The TODO comment is helpful but indicates incomplete implementation. Instance field dependencies are not visible in snippet. Overall structure is simple but minor formatting and type safety issues prevent higher score.","tokens":1400,"name":"55.jsnp"}
{"score":"68","reasoning":"JPA annotation override test with repetitive getAnnotation calls, dense chained methods, and magic numbers. Lacks comments and combines multiple scenarios reducing clarity. Descriptive names help but domain knowledge is required. Could improve by extracting variables, adding section headers, and splitting methods.","tokens":2328,"name":"135.jsnp"}
{"score":"70","reasoning":"Code demonstrates clear transactional boundaries with helpful revision comments explaining each operation. However, cryptic variable names like c3_1 and c3_2 reduce self-documentation. Repetitive boilerplate for transaction management is necessary but impacts brevity. Overall structure is logical and sequential, making it moderately easy to follow for developers familiar with JPA testing patterns.","tokens":1384,"name":"188.jsnp"}
{"score":"62","reasoning":"Clear test purpose with descriptive annotations but severely hampered by inconsistent indentation mixing tabs and spaces. Poor resource management lacking try-with-resources and unclear transaction boundaries where native SQL inserts bypass the test transaction. No guaranteed cleanup on failure. Core logic remains understandable but requires effort to parse.","tokens":2670,"name":"136.jsnp"}
{"score":"88","reasoning":"Excellent readability with descriptive naming and comprehensive comments explaining loader selection precedence. Clear if-else structure with well-documented branches. Minor deductions for complex compound condition and repeated method calls. Logical structure easy to follow for Hibernate developers.","tokens":1814,"name":"107.jsnp"}
{"score":"90","reasoning":"Clear test structure with consistent pattern. Each case is self-explanatory showing SQL TRIM variations. Good coverage of function forms. Minor repetition of render call could be refactored but enhances clarity. Well-formatted and immediately understandable intent. Constants are used appropriately. A senior engineer would grasp purpose instantly.","tokens":1615,"name":"26.jsnp"}
{"score":"82","reasoning":"Code demonstrates good readability with clear method naming, descriptive variables, and proper use of final keywords. Logging provides helpful debugging context. However, repeated deep method chaining in log statements and exceptions reduces conciseness. The domain-specific Hibernate ORM terminology and the unchecked cast to ExpandingFetchSource require contextual knowledge. Overall structure is clean with well-organized conditional logic.","tokens":1647,"name":"183.jsnp"}
{"score":"40","reasoning":"Code suffers from poor readability due to magic numbers (15,16,17) without context, confusing variable naming (ternaryMap is an entity), lack of comments, and multiple test scenarios combined in one method. Complex setup with nested constructors and type casting reduces clarity. Assumes external state for variables. While structurally sound, these issues make it hard to understand test purpose and expected behavior without deep domain knowledge.","tokens":2173,"name":"167.jsnp"}
{"score":"45","reasoning":"Method name is vague and lacks documentation. Complex HQL strings are unformatted and hard to read. Contains duplicate test cases and commented code with uncertainty notes. No assertions make validation unclear. Uses deprecated syntax without explanation. While structurally simple, the test\u0027s purpose and success criteria are not evident, requiring external context to understand.","tokens":1341,"name":"85.jsnp"}
{"score":"88","reasoning":"Well-documented method with clear Javadoc explaining purpose and parameters. Code follows clean linear structure with descriptive naming. Minor readability issue with long return statement line but overall excellent comprehension. Logic is straightforward and well-organized.","tokens":1580,"name":"126.jsnp"}
{"score":"65","reasoning":"Method is concise but has poor variable naming (j), heavy external state dependencies, mixed responsibilities, and inconsistent formatting. The cryptic HHH-2236 comment provides minimal help. Parameter names are generally clear but the index variable reduces comprehension. Adequate for framework code but not easily understandable without broader context.","tokens":1589,"name":"104.jsnp"}
{"score":"68","reasoning":"Test method is overly long and combines multiple scenarios making it a kitchen sink test. While variable names are clear and assertions have good messages, the repetitive pattern and mixing of return type and parameter type concerns reduce readability. Could be improved by splitting into focused test methods or using parameterized tests. Understandable but requires domain knowledge to follow all cases.","tokens":1377,"name":"88.jsnp"}
{"score":"85","reasoning":"Clear and focused static initializer with descriptive naming and consistent formatting. The repetitive registration calls follow an obvious pattern making intent easy to grasp. Minor deductions for commented-out code which creates slight confusion and the verbose but necessary repetition. Overall well-structured and comprehensible for its purpose.","tokens":1380,"name":"5.jsnp"}
{"score":"68","reasoning":"Method name is overly verbose and exceeds reasonable length. Test logic is hidden in helper methods making it hard to see actual assertions. Comment is minimal and uses unclear abbreviation AR. Excessive blank lines reduce code density. However structure is clear and helper method names are descriptive. Overall comprehension requires jumping to helper method implementations.","tokens":1584,"name":"187.jsnp"}
{"score":"80","reasoning":"Clear variable names and structured exception handling make this readable. The switch statement is well organized with descriptive error messages. However the loop logic is confusing, throwing on END ELEMENT instead of terminating normally. This counterintuitive behavior reduces comprehension and requires careful analysis to understand intended functionality.","tokens":3108,"name":"152.jsnp"}
{"score":"55","reasoning":"Method has clear naming but suffers from repetitive structure and confusing method names. The getSawRegionModification and getSawRegionAccess methods appear to be getters but return values are ignored suggesting side effects. This semantic mismatch reduces comprehension. The log message is misleading as no direct state clearing occurs. Lack of comments explaining purpose further hurts readability. Overall structure is simple but intent is unclear.","tokens":1605,"name":"190.jsnp"}
{"score":"88","reasoning":"Excellent JavaDoc and clear method name. Descriptive variables like firstDependentAction. Simple if-else structure. Domain complexity (Hibernate ORM) is high but well-documented. Chained calls like iterator().next() are slightly verbose. Reliance on unseen instance fields requires context. Highly readable for its purpose.","tokens":3397,"name":"102.jsnp"}
{"score":"60","reasoning":"Clear test structure and naming but severely impacted by deep method chaining (train wreck anti-pattern) which harms readability. The long call chain violates Law of Demeter, making object relationships unclear. While intent is obvious and cleanup is proper, the chained calls require excessive mental parsing. Using assertThrows instead of boolean flag would be more modern. Variable names are decent but the chaining is the dominant issue.","tokens":2008,"name":"145.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear descriptive method names following consistent patterns. The constructor is well-structured with each registration call on separate lines. Javadoc is present but minimal. Code is straightforward, linear, and easy to comprehend at a glance. No complex logic or nested structures. The separation of concerns into distinct register methods enhances maintainability and understanding.","tokens":1300,"name":"19.jsnp"}
{"score":"70","reasoning":"Clear Javadoc and descriptive variable names make the serialization purpose obvious. However the method suffers from severe code duplication with 22 nearly identical lines reading paint objects. This repetition creates verbosity that hinders quick scanning and makes maintenance error-prone despite the simple functional logic.","tokens":2245,"name":"3.jsnp"}
{"score":"88","reasoning":"The test method has excellent naming that clearly describes its purpose. It follows a clean AAA pattern with well-named variables and helper methods. The assertions are specific and readable using Hamcrest matchers. Minor points deducted for the broad throws Throwable clause and reliance on external methods (signature, getStringValuesFromAssignments) not defined in the snippet, which require context to fully understand.","tokens":1300,"name":"159.jsnp"}
{"score":"80","reasoning":"Method name clearly describes purpose. Good validation with descriptive error messages. Logical flow is easy to follow. Minor issues: variable name \u0027each\u0027 is generic, uses deprecated newInstance(), string concatenation is verbose, and throws broad Exception. Overall readable for developers familiar with reflection and testing frameworks but could benefit from modern Java practices and better variable naming.","tokens":1752,"name":"13.jsnp"}
{"score":"55","reasoning":"Poor indentation first line inside loop not indented unnecessary cast to Action repeated array indexing newActionsi makes code verbose complex conditional logic requires comments to understand Javadoc present but implementation not self documenting could be improved by extracting local variables and simplifying structure","tokens":1591,"name":"51.jsnp"}
{"score":"50","reasoning":"Deeply nested method chaining with a very long class name string makes this hard to read. The cast is buried in the middle of the chain. While the method name is clear, the lack of intermediate variables hurts comprehension. Breaking this into smaller steps with meaningful variable names would significantly improve readability.","tokens":1304,"name":"199.jsnp"}
{"score":"70","reasoning":"The test demonstrates clear structure with setup, execution, and cleanup phases, but suffers from a verbose method name, minimal explanatory comments, and complex HQL query embedded directly in the code. The raw HashMap usage requiring suppression warnings and multiple session management blocks add unnecessary cognitive load, making it moderately readable for experienced Hibernate developers but potentially challenging for others.","tokens":1739,"name":"82.jsnp"}
{"score":"68","reasoning":"Test method shows clear transaction boundaries and revision sequencing. However constructor parameters with string literals and numeric values lack semantic meaning. Long fully qualified class names reduce readability. Variable names are adequate but method name initData is too generic. Repetitive pattern is acceptable in test context but overall requires Hibernate Envers knowledge to comprehend purpose. Structure is logical but cryptic values hinder quick understanding.","tokens":1754,"name":"189.jsnp"}
{"score":"88","reasoning":"Clear method structure with logical flow. Good variable naming except for generic \u0027each\u0027. Descriptive error messages aid understanding. Validation logic is straightforward: check bounds then verify usage counts. No comments needed due to self-documenting code. Minor improvement possible with more specific iterator name.","tokens":1407,"name":"14.jsnp"}
{"score":"75","reasoning":"Code structure is clear with good indentation and mostly descriptive naming. Logic flow is straightforward: check property name, validate project, then update components. However, commented-out code reduces maintainability and causes confusion. Variable \u0027p\u0027 is terse, and the line break after getPropertyName() is awkward. These issues slightly hinder quick comprehension despite overall decent clarity.","tokens":2451,"name":"11.jsnp"}
{"score":"72","reasoning":"Method name uses complex double-negative phrasing. Repeated casting to Session creates verbosity. Generated method name with $$ is jarring. However, logic is well-structured with clear early returns, helpful comments, and sequential checks. Domain complexity is handled reasonably well, making it understandable for Hibernate developers despite minor friction points.","tokens":1399,"name":"111.jsnp"}
{"score":"65","reasoning":"Test method has clear naming and logical structure but suffers from excessive verbosity. The 22 repetitive assertions for column properties make it hard to quickly identify differences between overrides. Magic literals are acceptable in tests but add noise. Minor formatting issue with line break. Could improve by extracting column variables or using helper methods. Overall decent readability hampered by repetition.","tokens":2745,"name":"177.jsnp"}
{"score":"55","reasoning":"Code suffers from inconsistent indentation mixing tabs and spaces creating poor visual structure. Variable naming is confusing using id for entity object and id2 and getted as identifiers. Dense formatting lacks visual separation between test phases. However the test has clear logical sections with helpful comments explaining the Jira issue making the overall intent understandable despite formatting flaws.","tokens":2675,"name":"72.jsnp"}
{"score":"68","reasoning":"Method is overly long with dense sequential operations modifying annotationList via side effects. While helper methods are descriptively named, reliance on external state (elementsForProperty) reduces clarity. Javadoc spec reference is overly detailed. The attribute-override merging comment is helpful but structure could be improved by decomposition. Consistent pattern but readability suffers from length and tight coupling.","tokens":2041,"name":"149.jsnp"}
{"score":"88","reasoning":"Clear test structure with descriptive naming conventions. Uses standard JUnit patterns and final variables appropriately. The long SQL strings reduce readability slightly but are necessary for testing SQL dialect logic. String concatenation formatting is acceptable. Overall well-organized and easy to comprehend for its purpose.","tokens":1318,"name":"24.jsnp"}
{"score":"65","reasoning":"Test method uses descriptive naming but suffers from verbose anonymous classes and dated Hibernate Criteria API. Deep casting chains in assertions reduce clarity. Dependencies on external state like yogiExpected and areDynamicNonLazyAssociationsChecked() are unclear. Commented bug reference HHH-3524 provides context but indicates technical debt. Overall understandable for domain experts but requires significant context and patience.","tokens":1640,"name":"97.jsnp"}
{"score":"80","reasoning":"The code features clear Javadoc and logical structure but variable naming like positive/negative accumulation is slightly ambiguous requiring inline comments. The algorithm is correct and handles edge cases well, but domain knowledge is needed for quick comprehension. Overall above average readability with minor clarity improvements possible.","tokens":1945,"name":"41.jsnp"}
{"score":"75","reasoning":"Clear test intent via descriptive method name and assertion messages. Flaws include mixed indentation, inconsistent spacing, potential resource leak factory.close() lacks finally block, deprecated AnnotationConfiguration usage, and external serviceRegistry dependency. Chained calls are understandable but instanceof checks are brittle. Follows arrange-act-assert pattern adequately.","tokens":1729,"name":"178.jsnp"}
{"score":"65","reasoning":"Overly verbose method name. Contains chained calls and three casts increasing cognitive load. Five parameters is high. Requires deep ORM knowledge. Positive aspects: descriptive variable names and concise linear logic.","tokens":2078,"name":"148.jsnp"}
{"score":"55","reasoning":"Repetitive getter calls within the loop create visual clutter and inefficiency. The six similar-looking array accesses and long parameter list make the code hard to parse and error-prone. While method names are descriptive, their verbosity and similarity reduce readability. Simple improvements like local variables would help.","tokens":1367,"name":"105.jsnp"}
{"score":"40","reasoning":"Generated parser code with cryptic identifiers like _loop119 and _tokenSet_6. Uses unnatural do-while-true loop with labeled break instead of simpler while loop. Contains unnecessary nested blocks and empty statements. Inconsistent formatting with excessive whitespace. Prioritizes machine generation over human readability, making maintenance difficult.","tokens":1478,"name":"115.jsnp"}
{"score":"75","reasoning":"Test method has clear name and logical structure with setup execution verification and cleanup phases. Variable names are meaningful and assertions are specific. However the SkipForDialects annotation is overly verbose with nested arrays making it hard to parse. Mixed indentation direct field access instead of setters and System.out.println usage reduce clarity. Comment explains purpose well but annotation comments are slightly confusing. Overall decent readability with notable formatting and style issues.","tokens":1656,"name":"138.jsnp"}
{"score":"45","reasoning":"Repetitive type-checking if-statements create verbosity and hurt maintainability. Cryptic variable names (eo, me) reduce clarity. No comments explain the non-obvious removal detection logic. Uses legacy Vector. Could be refactored with polymorphism or lookup map. Structure is followable but significant readability issues remain.","tokens":1736,"name":"119.jsnp"}
{"score":"40","reasoning":"Uses generic Object[] array losing type safety with unexplained null values at arbitrary positions creating structural confusion. No comments document purpose or null meaning. Method names are descriptive and syntax is clean but semantic intent is unclear. Callers must cast elements and infer structure from implementation details.","tokens":2247,"name":"156.jsnp"}
{"score":"65","reasoning":"Method name is overly verbose and hard to parse. Empty catch block is confusing without comments making intent unclear. Magic number 50 lacks context. The test flow is counter-intuitive: swallowing an exception then expecting a timeout. While concise, it requires significant domain knowledge to understand. Better naming, comments, or restructuring would improve readability significantly.","tokens":1456,"name":"160.jsnp"}
{"score":"65","reasoning":"Test method is overly long with repetitive iterator handling and deep method chaining. Multiple concerns tested together reduce clarity. Variable names are descriptive but verbose. Magic numbers and dense assertions make comprehension difficult. Could benefit from helper methods and splitting into focused tests. Overall structure is logical but readability suffers from verbosity and lack of abstraction.","tokens":2987,"name":"180.jsnp"}
{"score":"78","reasoning":"Well-documented method with clear Javadoc explaining lazy event creation. Parameter names are descriptive. However, the reverse iteration by 2 over listener pairs is a Swing-specific pattern that requires external knowledge to understand quickly. Comments help but the EventListenerList structure remains non-obvious. Inconsistent indentation of constructor parameters slightly reduces readability. Overall good for those familiar with Swing event patterns.","tokens":1648,"name":"9.jsnp"}
{"score":"70","reasoning":"Method has clear purpose but uses outdated Hungarian notation for fields. Inconsistent formatting with awkward line breaks reduces readability. Interrupt logic placement is questionable. Variable names are mostly clear but generics syntax is verbose. Overall structure is understandable but requires careful reading.","tokens":1345,"name":"125.jsnp"}
{"score":"88","reasoning":"Code demonstrates clear structure with consistent addField patterns and logical section separation. Minor readability issues include abbreviated variable name \u0027a\u0027, inconsistent indentation in nested constructor calls, and extra whitespace. Overall easy to comprehend with descriptive method names and translator keys.","tokens":2172,"name":"158.jsnp"}
{"score":"58","reasoning":"Code has clear JavaDoc and purpose but suffers from raw type List forcing unsafe casts. Nested ternary operators and dense formatting reduce readability. Long parameter list in selectFragment call is hard to track. Magic number 100 and side-effect conditionals add minor friction. Overall structure is logical but implementation choices make it harder to comprehend than necessary.","tokens":1610,"name":"34.jsnp"}
{"score":"45","reasoning":"The code uses a complex CAS loop idiom crammed into single lines making it hard to parse. The comment about the read lock is contradictory and fails to clearly explain the hybrid lock-and-atomic approach, creating confusion about the concurrency model. While variable names are clear and lock release is handled correctly, the overall design requires deep concurrency knowledge to understand, significantly hindering readability.","tokens":2623,"name":"62.jsnp"}
{"score":"88","reasoning":"Good readability with clear Javadoc and straightforward logic. Try-catch structure is appropriate with specific exception handling. Minor formatting issues like inconsistent spacing and awkward line break slightly impact clarity. Meaningful variable names and clear purpose. Well-structured overall with minor style improvements possible.","tokens":1600,"name":"164.jsnp"}
{"score":"78","reasoning":"The code has good structure and naming but suffers from a complex boolean expression that requires careful parsing. Repeated method chains add noise. Extracting the flush logic into a named helper method and caching the transaction context would significantly improve readability. The single comment is helpful but insufficient for understanding the intricate conditions. Overall comprehension is moderate due to these complexity issues.","tokens":1577,"name":"184.jsnp"}
{"score":"90","reasoning":"Well-structured hashCode with clear variable names and explicit null checks. The pattern is slightly unconventional multiplying between fields rather than the typical before each field, but remains highly readable and easy to follow for any developer.","tokens":1645,"name":"141.jsnp"}
{"score":"70","reasoning":"The code has simple logic and clear structure but suffers from a misleading method name (addChar doesn\u0027t add anything) and vague Javadoc. The purpose of instance variables hasLf/hasCr is unclear without context. Formatting is consistent. Overall comprehension is moderate - easy to see what it does but not why.","tokens":2215,"name":"6.jsnp"}
{"score":"68","reasoning":"The method name clearly indicates its test purpose and parameters control scenario variations. However, readability suffers from anonymous inner class nesting, dense logic combining multiple test paths, and a ternary operator in the constructor. While variable names are meaningful and proper cleanup is implemented, the structure requires understanding callback patterns and cache domain concepts, making it moderately difficult to comprehend at first glance.","tokens":1269,"name":"173.jsnp"}
{"score":"45","reasoning":"Method name testHHH1780 is cryptic. Variable queue is misnamed it is a Stack not a Queue causing confusion. Inner class is overkill. Comments are minimal but helpful. Logic is simple DFS. Overall comprehension is hindered by poor naming choices despite straightforward algorithm.","tokens":2277,"name":"87.jsnp"}
{"score":"88","reasoning":"Method name and variable are clear. Each addition on separate lines enhances readability. Minor style issues include non-standard spacing in method calls and verbose fully qualified return type. Could be significantly more concise using Java 9+ Set.of(). Overall straightforward and very easy to comprehend.","tokens":2058,"name":"16.jsnp"}
{"score":"40","reasoning":"Deep nesting of anonymous inner classes with inconsistent indentation severely impacts readability. Poor parameter naming p and high framework coupling require significant domain knowledge. While compact the dense structure and mixed concerns make comprehension difficult. The double override pattern creates unnecessary cognitive load.","tokens":1579,"name":"132.jsnp"}
{"score":"72","reasoning":"Method has clear Javadoc and structure but suffers from a long chain of method calls violating Law of Demeter, making it hard to understand the object graph. Parameter list is lengthy. Boolean logic with double negation is slightly confusing. Variable abbreviations are acceptable in JDBC context. Overall decent readability for experienced developers but could be improved by extracting the coordinator chain and simplifying the conditional logic.","tokens":1665,"name":"33.jsnp"}
{"score":"70","reasoning":"Test method shows clear structure with setup execution verification phases. Naming is descriptive but class names are excessively long hurting readability. Requires deep Hibernate domain knowledge. Uses consistent assertion patterns but contains debugging code. Variable naming is mostly clear with minor abbreviations. Overall readable for experienced framework developers but less accessible for newcomers.","tokens":1523,"name":"142.jsnp"}
{"score":"45","reasoning":"The code uses a clever but obscure bit manipulation pattern that requires deep understanding to decipher intent. Javadoc is vague and method name is generic. Magic numbers lack context. While functional, it sacrifices clarity for brevity, making it harder to maintain than explicit shift-and-mask or ByteBuffer alternatives.","tokens":2144,"name":"113.jsnp"}
{"score":"75","reasoning":"Method is well-structured with clear purpose and logical flow. Variable names are mostly descriptive though some abbreviations like \u0027jc\u0027 and \u0027in\u0027 could be clearer. Main issues: InputStream is never closed causing resource leak, potential null pointer from locateResourceStream not handled, and minor formatting inconsistencies. Error handling is limited to JAXBException. Overall straightforward but lacks robustness considerations.","tokens":1384,"name":"194.jsnp"}
{"score":"95","reasoning":"Code shows excellent readability with clear naming consistent indentation and linear structure. Javadoc comment is adequate. Each line follows a predictable pattern making type mappings easy to understand. Uses standard Types constants and descriptive SQL strings. Minor deduction for cryptic placeholders l p s which are conventional but not explicitly documented.","tokens":1566,"name":"25.jsnp"}
{"score":"75","reasoning":"Method name overly verbose and difficult to parse. Combines multiple test scenarios reducing single-purpose clarity. Positional parameters less readable than named parameters. Strengths include good structure clear comments logical flow proper resource management descriptive variable names and straightforward assertions. Would be more readable split into separate test methods.","tokens":1640,"name":"91.jsnp"}
{"score":"45","reasoning":"Method name myDoubleClick is vague. Variables sel and d are poorly named. Code duplication exists for table row selection. Logic is confusing: setTarget called twice potentially overwriting the first call. Indentation is inconsistent. Uses raw Vector requiring unsafe cast. Overall intent is unclear due to these issues making it moderately difficult to comprehend.","tokens":1657,"name":"10.jsnp"}
{"score":"85","reasoning":"The method has clear Javadoc explaining its purpose. Inline comments effectively document design decisions and potential improvements. Complex generic type bounds with multiple interfaces require careful reading. Nested try-finally blocks are necessary but add slight cognitive load. Variable names are descriptive and logic flow is straightforward. Overall well-structured with good error handling patterns.","tokens":1697,"name":"110.jsnp"}
{"score":"50","reasoning":"Code duplication (handleFireModuleEvent appears twice) and inconsistent formatting reduce clarity. Deep nesting adds cognitive load. Asymmetrical ANY_EVENT handling (no generator check) is confusing. Magic number ranges for event types require external context. The dispatch logic is understandable but maintenance is hindered by these issues.","tokens":2277,"name":"43.jsnp"}
{"score":"60","reasoning":"Code demonstrates moderate readability with clear variable names and logical test structure. However, comprehension suffers from Hibernate-specific complexity, cryptic TODO comment about internal types, multiple queries without assertions or comments explaining their purpose, and unclear verification criteria. The @SuppressWarnings annotation indicates underlying type safety issues. Overall intent is not well-documented, requiring domain knowledge to fully understand.","tokens":1883,"name":"80.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear Javadoc and standard equals implementation pattern. Each step is explicit and well-structured. Minor improvements possible: return description is generic and field checks could be more compact using \u0026\u0026 operators. Overall very easy to comprehend for developers of any level.","tokens":1346,"name":"114.jsnp"}
{"score":"80","reasoning":"Clear test structure with descriptive naming and helpful comments explaining scenarios. Good separation of two test cases. However magic number -1 lacks context, Long casting is verbose, and a typo exists in comments. Requires domain knowledge of HiLo algorithm to fully understand expected values. Could benefit from splitting into separate test methods.","tokens":2053,"name":"56.jsnp"}
{"score":"85","reasoning":"Method name clearly indicates testing edge cases with keywords as identifiers. Structure is simple with sequential parse calls. Comments are informal but descriptive. One parse call is commented out without explanation, slightly reducing clarity. The HQL strings are intentionally complex, which is necessary for testing pathological cases. Overall easy to understand for domain-aware developers.","tokens":1209,"name":"86.jsnp"}
{"score":"30","reasoning":"Poor readability due to inconsistent naming conventions, flawed null handling patterns that risk NPE, commented-out code, and a complex single-line return statement with mixed comparison logic. The method combines primitive and wrapper comparisons unsafely and lacks structural clarity, making it difficult to understand and maintain.","tokens":2731,"name":"74.jsnp"}
{"score":"70","reasoning":"Code has clear naming and structure but inconsistent formatting hurts readability. Uses outdated try-finally pattern instead of try-with-resources creating verbosity. Mixes UI dialog logic with file operations which muddles responsibility. Hardcoded dialog keys and magic scale value reduce maintainability. Despite flaws, core save logic is straightforward to follow.","tokens":1720,"name":"49.jsnp"}
{"score":"72","reasoning":"The code follows standard equals pattern with clear structure identity check superclass delegation class verification and field comparison. However the class name is excessively verbose the null safe comparison uses outdated verbose syntax instead of Objects.equals and super.equals before class check is unconventional. Overall logic is correct and traceable but modern Java features would improve readability significantly.","tokens":1346,"name":"169.jsnp"}
{"score":"62","reasoning":"Code has clear test intent and proper cleanup but suffers from poor readability due to extremely long chained method calls requiring casting to SessionImplementor. The anonymous inner class syntax adds unnecessary verbosity and nesting. While comments help, the deep API access pattern makes comprehension difficult. Modern Java features like lambdas and try-with-resources would improve readability significantly.","tokens":1496,"name":"94.jsnp"}
{"score":"68","reasoning":"Code shows clear structure and logical flow with decent variable naming. However readability suffers from magic numbers without constants, duplicate setAutoResizeMode call, and a redundant javadoc comment. Dependencies on superclass members are implicit. While understandable to experienced developers, these issues hinder quick comprehension and maintainability.","tokens":1605,"name":"118.jsnp"}
{"score":"70","reasoning":"Clear method name and null check, but type casting to SessionImplementor is jarring and requires domain knowledge. Deep method chaining plus swallowing Throwable with minimal comment reduces maintainability. Non-standard spacing and abbreviated parameter name hurt readability. Short but not immediately comprehensible.","tokens":1841,"name":"95.jsnp"}
{"score":"62","reasoning":"Method has clear intent but suffers from undefined metadata variable usage making comprehension difficult. Non-idiomatic Class.isInstance() usage inconsistent formatting with excessive tildes and irregular indentation. Parameter names are descriptive and null checks are appropriate. The TODO comment provides useful context about limitations. Overall structure is logical but implementation details create significant readability barriers.","tokens":1874,"name":"147.jsnp"}
{"score":"85","reasoning":"Clear Javadoc explains purpose. Method name is descriptive but lengthy. Anonymous inner class is concise yet slightly verbose. Code structure is simple and follows standard patterns. Missing context for fNotifier and AbstractConcurrentFailuresTest slightly hinders full comprehension, but overall intent is easily understood by Java developers.","tokens":1053,"name":"53.jsnp"}
{"score":"88","reasoning":"Code shows excellent readability with clear naming and logical nested loop structure. Comment effectively explains deterministic field ordering. Minor deductions for lengthy method signature and external dependencies fClass field and addToAnnotationLists method not visible in snippet. Overall well-organized and easy to understand.","tokens":1505,"name":"52.jsnp"}
{"score":"45","reasoning":"The code has a descriptive method name and helpful initial comment explaining the three property types being tested. However, it suffers from poor readability due to repetitive boilerplate code, no visual separation between test cases, and lack of inline comments for individual queries. The dense structure makes it difficult to quickly parse differences between test scenarios. The purpose of checkIterate vs checkAll is not explained. Overall comprehension requires careful line-by-line analysis.","tokens":1960,"name":"79.jsnp"}
{"score":"70","reasoning":"The poetic Javadoc comment is unhelpful and violates documentation standards. Non-standard modifier order (static public) shows lack of attention to conventions. While the reflection logic is handled reasonably with clear exception messages, the nested try-catch blocks and repetitive error handling make it somewhat verbose. Variable naming is adequate but not exceptional. Overall comprehension requires moderate effort due to these issues and the inherent complexity of dynamic instantiation.","tokens":2224,"name":"2.jsnp"}
{"score":"78","reasoning":"Test demonstrates good structure with clear naming and issue annotation. Comments explain the HHH-2257 bug context well. Setup and cleanup are explicit. Test cases use descriptive messages. Minor deductions for dense initial comment block and reliance on external checkCounts method whose implementation isn\u0027t shown. Session management boilerplate is slightly verbose but standard for Hibernate tests. Overall comprehension is solid for domain-aware readers.","tokens":2122,"name":"78.jsnp"}
{"score":"68","reasoning":"Good Javadoc and clear variable names aid comprehension. However, significant code duplication between the two loops reduces maintainability and forces careful comparison. Raw type Vector requires unsafe casting. Magic number -10 lacks context. Mixing painting with state modification in Clarifier objects is a subtle concern. Overall readable but hindered by outdated practices and redundancy.","tokens":2324,"name":"121.jsnp"}
{"score":"70","reasoning":"Method name clearly states purpose and variables are descriptive but overly verbose. Long boolean flag names reduce readability. Magic strings for method names lack context. Loop logic is straightforward but could be more concise. Overall structure is logical but implementation is more complex than necessary.","tokens":1584,"name":"161.jsnp"}
{"score":"78","reasoning":"Well structured Hibernate test with clear transactional flow. Anonymous inner class for doWork is verbose but idiomatic. SQL construction with dialect methods is noisy yet necessary for cross database support. Conditional assertion adds complexity but handles dialect differences appropriately. Readable for experienced developers familiar with ORM testing patterns. Could improve with lambda syntax more descriptive naming and inline comments. Magic numbers slightly hinder immediate comprehension.","tokens":1819,"name":"69.jsnp"}
{"score":"75","reasoning":"Clear Hibernate session management and test data setup. Variable naming child_1_1 is compact but reveals parent-child grouping logic. Short identifiers s t p1 p2 are conventional yet reduce immediate comprehension. Interleaved save operations slightly obscure intent. Lacks explanatory comments. Overall well-structured and understandable for developers familiar with ORM testing patterns.","tokens":1718,"name":"76.jsnp"}
{"score":"45","reasoning":"The code uses convoluted ternary operators for null checks that are difficult to parse mentally. Variable naming is confusing with cidDetailID mixing concepts. While structurally correct for equals contract, the implementation is unnecessarily complex and lacks modern Java clarity. Could be greatly simplified with Objects.equals().","tokens":1231,"name":"70.jsnp"}
{"score":"90","reasoning":"The method demonstrates excellent readability through clear naming consistent structure and focused purpose. Each registration follows a predictable pattern making it easy to understand the configuration logic. The minor deduction comes from hardcoded fully qualified class name strings which could be constants but their pairing with SHORT_NAME constants and clear grouping by factory type maintains strong comprehensibility. The code is well-formatted and immediately conveys its intent of registering transaction factory strategies.","tokens":1462,"name":"171.jsnp"}
{"score":"72","reasoning":"Method name clearly states intent but variable fMax is cryptic and requires external context. Uses anonymous inner class which is verbose compared to modern lambda syntax. Dependencies on TwoTests and fMax fields are not self-explanatory. Older generic syntax without diamond operator. Overall structure follows standard JUnit patterns making it moderately readable for experienced developers.","tokens":1321,"name":"124.jsnp"}
{"score":"88","reasoning":"Clear test method with descriptive naming. Uses helper methods effectively. Nested calls and long class name slightly reduce readability but intent remains obvious. Standard JUnit structure. Could improve by breaking long line or extracting variables.","tokens":1732,"name":"165.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear Javadoc, well-named constants, and crucial inline comments explaining boolean parameters. Clean formatting and standard telescoping constructor pattern make intent obvious. Minor deduction for boolean flags requiring comments rather than being self-documenting, but overall very easy to comprehend.","tokens":1242,"name":"4.jsnp"}
{"score":"30","reasoning":"Code suffers from extremely poor variable naming (single letters) offering no context. Lacks comments explaining the complex bidirectional relationship cleanup logic. Object relationships and deletion order rationale are unclear. While formatting is consistent, the code is very difficult to comprehend and maintain without deep domain knowledge.","tokens":1320,"name":"200.jsnp"}
{"score":"60","reasoning":"Convoluted conditional logic with nested if statements creates confusion. Inline comments are poorly placed. Inconsistent formatting with awkward line breaks hinders readability. Method mixes validation with logging side effects. While core intent is discernible, the structure requires multiple reads to understand, significantly impeding quick comprehension.","tokens":1717,"name":"29.jsnp"}
{"score":"65","reasoning":"The method demonstrates adequate structure with proper session/transaction handling but suffers from poor separation of concerns mixing setup and test logic. The dialect-specific branching with instanceof check adds complexity. The native SQL query is verbose and uses Hibernate-specific placeholder syntax reducing clarity. Variable names are functional but generic. A comment explains the TimesTen exception but overall the code requires Hibernate knowledge to fully comprehend.","tokens":1462,"name":"71.jsnp"}
{"score":"60","reasoning":"Legacy code with inconsistent indentation and outdated patterns. Uses raw Iterator types and manual resource management instead of try-with-resources. Exception handling is verbose and loses stack trace. Assertions are split across loop iterations making logic harder to follow. However test purpose is clear from method name and comments explain JPA spec requirements. Variable names like foundIt are vague and magic strings are repeated.","tokens":1856,"name":"137.jsnp"}
{"score":"75","reasoning":"The method has a verbose name and relies heavily on comments to explain intent, indicating the code is not fully self-documenting. While the comments are helpful and the structure is logical, the mix of test logic, implementation details, and dialect-specific workarounds increases cognitive load. Variable naming is inconsistent and the try-catch pattern is dated. Overall readable for Hibernate experts but requires domain knowledge.","tokens":1637,"name":"75.jsnp"}
{"score":"55","reasoning":"Method name is clear but map semantics are counter-intuitive. Debug messages are misleading stating wrong access types. Comment typo exists. Logic duplication without helper method reduces conciseness. Requires deep JPA knowledge to understand the reclassification purpose. Overall comprehension is hindered by these issues despite being functional.","tokens":3372,"name":"27.jsnp"}
{"score":"35","reasoning":"Test method lacks assertions and comments making purpose unclear. Heavy repetition of query pattern without abstraction reduces readability. Variable reuse and suppressed warnings indicate results are unused. Complex HQL strings are hard to parse visually. No grouping or separation between test cases. Setup and teardown are clear but the core test logic is difficult to comprehend due to these structural issues.","tokens":1862,"name":"83.jsnp"}
{"score":"72","reasoning":"Clear variable names and logical structure. Criteria API verbosity and correlated subquery complexity reduce readability for novices. Minimal comments. Well-suited for experienced JPA developers but requires domain knowledge. Resource management is properly handled.","tokens":1295,"name":"163.jsnp"}
{"score":"70","reasoning":"Clear method naming and structure but deep method chaining reduces readability. Long lines with nested calls like getQueryableCollection().selectFragment() are hard to parse. Type casting adds complexity. Many-to-many condition is clear but requires domain knowledge. Good for experienced developers familiar with ORM patterns. Super call follows proper pattern.","tokens":2250,"name":"182.jsnp"}
{"score":"35","reasoning":"Excessive nesting depth with 4-5 levels makes logic hard to follow. Poor variable names nod and comp lack clarity. Comment splits boolean condition across lines severely harming readability. Redundant else-if for null check is illogical. Mixes UI and business logic concerns. 2006 TODO indicates unresolved design issues. Convoluted structure demands significant effort to understand.","tokens":2137,"name":"155.jsnp"}
{"score":"48","reasoning":"Code suffers from heavy duplication with 11 repetitive lines testing boolean arrays. Lack of abstraction obscures test intent and makes maintenance difficult. Inline boolean arrays act as unexplained magic values. Inconsistent spacing and overly long method name reduce clarity. Requires careful line-by-line reading to understand differences. Would benefit greatly from a data-driven loop or parameterized test approach.","tokens":3689,"name":"59.jsnp"}
{"score":"75","reasoning":"The test has a descriptive but overly long method name. Variable names like s, e, pm are too short reducing clarity. The assertion chain is excessively complex and hard to parse. However the extensive comment block effectively explains the JPA specification being tested and the test structure follows a clear arrange act assert pattern. Overall readability is moderate with room for improvement in variable naming and assertion simplicity.","tokens":2143,"name":"134.jsnp"}
{"score":"45","reasoning":"Code uses raw types reducing type safety and clarity. Returns null instead of empty set, risking NullPointerExceptions. Variable naming is generic \u0027set\u0027. Inconsistent indentation. Heavy static facade usage obscures dependencies. No comments. While logic is simple to follow, these issues significantly impact readability and maintainability for a senior engineer.","tokens":1315,"name":"123.jsnp"}
{"score":"82","reasoning":"Clear constructor with descriptive naming. Listener initialization and registration follow a logical pattern. Repetitive registry calls are explicit and traceable. Hibernate casting is standard practice. Minor verbosity is offset by self-documenting nature. Easily comprehensible for domain-aware developers.","tokens":1639,"name":"139.jsnp"}
{"score":"80","reasoning":"Clear structure with switch statement mapping SQL states to constraint extraction patterns. Helpful inline comments explain each case. Consistent method calls improve readability. Minor deductions for magic numbers (could use constants) and reliance on external extractUsingTemplate method. Exception handling is appropriate. Overall straightforward and easy to follow.","tokens":1564,"name":"22.jsnp"}
{"score":"70","reasoning":"Verbose generic syntax and lengthy ternary operators create dense lines exceeding 100 characters. While naming is descriptive and the defensive-copy pattern is consistent, visual clutter hampers quick comprehension. Repeated logic should be extracted to a helper method. Functional but stylistically dated and harder to parse than necessary.","tokens":2080,"name":"196.jsnp"}
{"score":"80","reasoning":"Method is concise with clear naming and single responsibility. Minor issues include inconsistent indentation of constructor parameters and closing parenthesis, abbreviated parameter name \u0027sf\u0027, and very long class name following framework conventions. Overall structure is logical and easy to follow for domain-aware developers.","tokens":1278,"name":"143.jsnp"}
{"score":"88","reasoning":"Well-structured test with clear setup, execution, and assertion phases. Uses descriptive naming and proper resource cleanup via try-finally. Minor issues include early variable declaration separated from usage and ignored return value from getCacheManager(). Property keys are verbose but domain-appropriate. Logical separation between entity and collection region tests enhances clarity. Overall easy to comprehend despite complex caching domain.","tokens":2403,"name":"130.jsnp"}
{"score":"85","reasoning":"The code demonstrates good readability with clear JavaDoc, descriptive variable names, logical structure, and helpful comments explaining non-obvious behaviors. Minor deductions for a long for-loop line and commented-out code that could be removed. The complexity is domain-related Hibernate internals rather than poor style. Overall well-structured and maintainable.","tokens":1960,"name":"66.jsnp"}
{"score":"65","reasoning":"Clear JUnit structure with descriptive naming but incomplete test logic. The purpose of session.getFlushMode() is ambiguous and there are no assertions verifying the autoJoinTransactions false behavior. Missing transaction cleanup and session closing reduces comprehension. Test intent not fully expressed through code.","tokens":1485,"name":"128.jsnp"}
{"score":"68","reasoning":"The test has clear naming and structure but suffers from repetitive session/transaction boilerplate that obscures the core logic. Uses raw List type instead of generics. Inline cleanup code and lack of helper methods reduce readability. The empty IN clause query is cryptic without comments. Annotations provide good context. Overall decent but could be more concise and modern.","tokens":1397,"name":"77.jsnp"}
{"score":"90","reasoning":"Clear Javadoc documents purpose parameters and exceptions. Descriptive method and parameter names. Straightforward if-else logic with proper error handling. TODO provides context. Null-safe mode check is concise. Well-structured and short method enhances readability.","tokens":1488,"name":"32.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear Javadoc, descriptive naming, and consistent pattern. Method is short and focused, following Java serialization conventions. Each field serialization is explicit and easy to follow. Minor deduction for repetitive but necessary serialization calls. Overall highly comprehensible for its purpose.","tokens":1417,"name":"38.jsnp"}
{"score":"75","reasoning":"Method intent is clear with proper try-finally cleanup. Anonymous inner class is verbose compared to modern lambda syntax. ActiveTestSuite.this reference may confuse beginners. Comment explains inlining rationale but commented code adds slight noise. Thread lifecycle management is not visible in this snippet. Overall readable but uses dated Java patterns.","tokens":1892,"name":"1.jsnp"}
{"score":"62","reasoning":"Method shows moderate readability with descriptive naming but suffers from excessive nesting depth of 3-4 levels. Contains code duplication with repeated normalizeIdentifierQuoting calls. Parameter reassignment is poor practice. Logic flow requires careful tracing to understand transformation sequence. Minimal commenting. Side effects on mappingColumn are not obvious. Could be improved by flattening structure and extracting helper methods.","tokens":1551,"name":"30.jsnp"}
{"score":"70","reasoning":"Test method has clear name and good variable naming. However nested casting AbstractQueryImpl HibernateQuery reduces readability. Repetitive structure with multiple assertions per block makes it hard to distinguish test scenarios quickly. No comments explain the complex JPA to Hibernate cache mode mappings being verified. While functional the monolithic structure and lack of explanatory context hinder comprehension for those not deeply familiar with the domain.","tokens":2630,"name":"162.jsnp"}
{"score":"55","reasoning":"Uses outdated Java practices: raw types, Enumeration, and inefficient double lookup. Getting interfaces inside loop is confusing. Variable names are inconsistent and cryptic. Javadoc has typos. While comments help, the implementation obscures the simple lookup intent. Caching mechanism is clever but not clearly explained. Overall requires significant effort to comprehend.","tokens":2340,"name":"44.jsnp"}
{"score":"80","reasoning":"Well-documented with clear Javadoc and descriptive parameter names. Good structure using early returns to avoid deep nesting. Logic flow is straightforward. Minor issues: the constructor has many parameters making it dense, logging style is inconsistent between tracef and string concatenation, and requires SuppressWarnings for a necessary cast. Overall readable for the domain complexity.","tokens":1838,"name":"84.jsnp"}
{"score":"50","reasoning":"The code suffers from deep nesting (4 levels), multiple exit points, and a large try-catch block that obscures error sources. Loop uses unconventional syntax (i !\u003d length, ++i). Logic for handling --filter vs --filter\u003dvalue is convoluted with manual index manipulation. Dependencies on external fields (parserErrors, filter) are not explicit. Mixing parsing with business logic reduces clarity. Variable names are decent but structure needs refactoring for better readability.","tokens":1552,"name":"15.jsnp"}
{"score":"35","reasoning":"This is generated ANTLR lexer code with poor readability. Non-standard naming conventions (underscores, abbreviations like _ttype, mHEX_DIGIT), lack of comments, verbose boilerplate obscuring simple hex digit matching logic, inconsistent formatting, and framework-specific API calls make it difficult for humans to comprehend. The switch structure is clear but spread across many lines with unnecessary blocks.","tokens":1937,"name":"117.jsnp"}
{"score":"85","reasoning":"Code is highly readable with clear visual structure and consistent formatting. Uses descriptive labels and logical grouping. Loses points for misleading method name (prints rather than compares), hardcoded formatting, direct System.out usage instead of logger, and lack of null safety. Overall simple, linear flow with no complexity.","tokens":1301,"name":"144.jsnp"}
{"score":"72","reasoning":"Test method demonstrates proper Hibernate session management with nested try-finally blocks. Clear intent through descriptive name and expected exception handling. Nested structure slightly reduces readability but cleanup logic is well organized. Variable names are concise but meaningful. Exception testing pattern is standard but could benefit from inline comments explaining why TransientObjectException is expected. Overall structure is solid for a test case.","tokens":1348,"name":"129.jsnp"}
{"score":"45","reasoning":"Code uses raw types and outdated Vector class reducing type safety and clarity. Variable names like cr and aer are cryptic. Redundant Object cr assignment adds confusion. Explicit Iterator is verbose compared to for-each. Comments are unhelpful. While logic is simple the implementation uses obsolete patterns and poor naming making comprehension harder than necessary.","tokens":1726,"name":"120.jsnp"}
{"score":"65","reasoning":"The code uses outdated Vector without generics reducing type safety. Repetitive addElement calls make it verbose. Minimal Javadoc provides little context. While the lazy initialization pattern is clear and method name is descriptive, modern Java practices would improve readability significantly. Thread safety concerns and static mutable state are additional drawbacks.","tokens":1392,"name":"45.jsnp"}
{"score":"55","reasoning":"Code has poor variable naming like f, fr, mAry reducing clarity. Resource management is unsafe as fr.close() might not execute. Loop logic is convoluted with redundant null checks and duplicate getSectId calls. While functional and briefly documented, these issues hinder readability and maintainability significantly.","tokens":2324,"name":"48.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability with clear Javadoc, standard equals method structure, and logical flow. Variable names are meaningful and early returns enhance comprehension. The nested iteration with null handling is slightly complex but well-implemented and necessary for the domain. Overall, it\u0027s easy to understand for developers familiar with Java equality patterns.","tokens":1698,"name":"40.jsnp"}
{"score":"70","reasoning":"The test has a clear name and logical flow but suffers from excessive casting and verbose lines. Repetitive assertions make it longer than necessary. The single comment helps but more context on state transitions would improve comprehension. While the pattern is consistent, the code assumes deep knowledge of Hibernate\u0027s transaction API. Overall structure is sound but implementation details hinder readability.","tokens":1954,"name":"127.jsnp"}
{"score":"72","reasoning":"Test demonstrates specific Hibernate bug fix with helpful inline comments explaining actions. Method name clearly states purpose. However entity class name Another is generic and uninformative. Test logic is dense combining insert update flush and commit before verification. Assertion message contains typo excpect. Structure follows standard patterns but could benefit from clearer section separation. Overall understandable for Hibernate developers but not self-documenting.","tokens":1752,"name":"179.jsnp"}
{"score":"65","reasoning":"Code has inconsistent indentation and distracting commented-out lines that suggest incomplete refactoring. Deep nesting in tooltip logic and redundant getJComponent() calls reduce clarity. While the overall flow is logical and null checks are proper, these issues make it harder to follow. Structure could be improved with better formatting and removal of obsolete comments.","tokens":1688,"name":"122.jsnp"}
{"score":"88","reasoning":"The method uses a clear if-else chain to handle different Test types. Logic is straightforward with recursive handling for TestSuite. Variable names are descriptive. Minor readability issues include dense ternary operator and necessary type casting. Overall structure is clean and easy to comprehend.","tokens":1221,"name":"54.jsnp"}
{"score":"48","reasoning":"Poor formatting with awkward line breaks and misplaced parentheses makes structure hard to follow. Extremely long entity class names reduce readability. Cryptic variable names like ing1_id and ed1_id lack context. Repetitive assertions without comments or data setup explanation hinder comprehension. While the test pattern is consistent, these issues significantly impact overall clarity.","tokens":1475,"name":"185.jsnp"}
{"score":"80","reasoning":"The code uses clear naming and descriptive error messages making it easy to follow. However, the long if-else chain is verbose and creates minor duplication in validation logic. The commented-out code in the final else block is slightly distracting. Overall structure is consistent and logic within each branch is simple, but the control flow could be more compact.","tokens":1655,"name":"108.jsnp"}
{"score":"60","reasoning":"Method has clear naming and logical structure but suffers from deep nesting, complex conditional logic, and lacks inline comments. Magic strings like \u0027key\u0027 and \u0027integer\u0027 reduce maintainability. The IndexBackref block is repetitive and could be extracted. Side effects on multiple objects make behavior harder to trace. Understandable for domain experts but challenging for newcomers due to mixed abstraction levels and tight coupling.","tokens":2298,"name":"109.jsnp"}
{"score":"78","reasoning":"The code demonstrates reasonable readability with clear method signature and logical flow. However it has minor issues: double invocation of getSqlTypeCode() in condition, verbose string concatenation in exception handling, and dense array indexing. Variable names are meaningful and error messages are descriptive despite a small grammatical error. Overall structure is sound but could benefit from minor refactoring for improved clarity.","tokens":1763,"name":"37.jsnp"}
{"score":"80","reasoning":"StringBuilder usage is efficient and field names are descriptive with consistent append pattern. Formatting is cramped without line breaks between fields hurting visual scanning. Indentation appears inconsistent. Mix of direct field access and getter method is slightly inconsistent. Overall intent is clear and code is concise making it reasonably readable with minor improvements needed.","tokens":1579,"name":"63.jsnp"}
{"score":"38","reasoning":"Critical string comparison bug using \u003d\u003d instead of equals. Poor abbreviated variable names like mee, tr, eName reduce clarity. Duplicated logic for incoming and outgoing cases. Inconsistent brace style and magic strings harm maintainability. TODO comments indicate uncertainty. Unsafe casting without instanceof. The explanatory comment is helpful but severe issues make code difficult to understand and maintain.","tokens":2504,"name":"154.jsnp"}
{"score":"65","reasoning":"Uses raw types List and Iterator reducing type safety. Field dependencies _scratchBindings and _strBuf obscure method behavior. Lacks comments and uses magic strings. Verbose manual iteration. Clear method name and structured logic with null-safe checks. Shows outdated Java practices but remains comprehensible.","tokens":2330,"name":"8.jsnp"}
{"score":"88","reasoning":"Descriptive naming makes intent clear. Logic is straightforward with good early return. However boolean flags are redundant since null checks could be used directly. Unnecessary list copying when no changes needed. Well structured but slightly verbose.","tokens":2351,"name":"195.jsnp"}
{"score":"68","reasoning":"Moderate readability via descriptive naming and loop separation. Comprehension hindered by recursion to unseen overloaded methods, verbose Class.isInstance checks, and side effects (hydrateEntityState) mismatched with method name. Long parameter lists add visual noise. Requires deep ORM framework knowledge.","tokens":2533,"name":"197.jsnp"}
{"score":"65","reasoning":"Test method has clear name and logical step-by-step structure. However, excessive tilde separators create visual noise. A critical flaw is the contradictory comment stating first value should be 4 while asserting it equals 1. Inconsistent session casting and redundant parentheses add confusion. Repetitive pattern could be streamlined. Overall understandable but hampered by misleading comments and clutter.","tokens":2447,"name":"17.jsnp"}
