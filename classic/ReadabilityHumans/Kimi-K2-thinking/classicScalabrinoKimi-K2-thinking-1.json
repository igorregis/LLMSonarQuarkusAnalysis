{"score":"80","reasoning":"Test method demonstrates clear Hibernate transaction flow with descriptive naming. Code is concise and follows standard patterns. Points deducted for overly verbose method name, absence of explicit assertions, and manual resource management instead of try-with-resources. Lacks inline comments but self-documenting structure partially compensates. Overall straightforward to comprehend for developers familiar with ORM testing.","tokens":1035,"name":"133.jsnp"}
{"score":"68","reasoning":"Method name clearly indicates purpose but HQL query string is overly dense and difficult to parse visually. Variable naming is terse (s). Uses outdated try-catch-fail pattern instead of modern assertThrows. Session close is outside try block. Overall intent is understandable but readability suffers from compact formatting and older testing patterns.","tokens":1189,"name":"81.jsnp"}
{"score":"78","reasoning":"Well-structured method with clear variable names and helpful comments explaining audit entity creation. Uses final keywords appropriately. Minor issues: some long lines, ternary operator reduces clarity, and returning the ID element rather than the entity itself is slightly unexpected based on method name. Overall logic flow is easy to follow for framework code.","tokens":1562,"name":"170.jsnp"}
{"score":"70","reasoning":"Test method structure is clear with separate assertions. SQL strings range from simple to highly complex with nested functions and subqueries. Consistent formatting but extreme statement length reduces quick readability. Method name is somewhat ambiguous without additional context. Moderate readability suitable for specialized testing but challenging for casual review.","tokens":1763,"name":"101.jsnp"}
{"score":"88","reasoning":"Method is concise and follows a clear configuration pattern. Constant names are descriptive and method calls are self-explanatory. Minor deductions for inconsistent use of cfg.getProperties().put() instead of setProperty() like other lines, and abbreviated parameter name cfg. Overall structure is clean and highly readable for developers familiar with Hibernate configuration.","tokens":1376,"name":"191.jsnp"}
{"score":"60","reasoning":"The method has a clear name and parameter types. Most setter calls are straightforward. However, two consecutive if-statements with different null/empty checks for custom persister class create major confusion and suggest a bug. The method is long and could benefit from extraction into helper methods. Deep method chaining and generic method syntax add slight complexity but are acceptable.","tokens":1732,"name":"146.jsnp"}
{"score":"72","reasoning":"Well-structured test with descriptive variable names and a useful comment explaining non-deterministic ordering. Long similar class names hinder quick comprehension. The if-else block with nearly identical assertions adds verbosity but is logically necessary. Clear intent but requires domain knowledge. Could be streamlined.","tokens":1852,"name":"181.jsnp"}
{"score":"68","reasoning":"The test suffers from repetitive session/transaction boilerplate that obscures core logic. Lack of comments makes the orphan deletion scenario unclear. Inconsistent naming (Widge vs Widget) and multiple cache evictions add unnecessary complexity. While understandable for Hibernate developers, the structure could be improved with helper methods or clearer separation of concerns.","tokens":1794,"name":"192.jsnp"}
{"score":"72","reasoning":"Method has clear structure and logical branching for handling composite vs non-composite keys. Parameter names are good and code is concise. However readability suffers from undefined external helpers repeat joinWithQualifier and constant BATCH_ID_PLACEHOLDER. Inconsistent use of StringHelper prefix on last replace call creates confusion. Requires deep knowledge of SQL dialects. Minimal comments help but domain complexity makes it challenging for newcomers.","tokens":1639,"name":"112.jsnp"}
{"score":"60","reasoning":"The code suffers from excessively verbose class names that embed JPA mapping details, making them hard to read. Variable names like ed2 and ing2_id are cryptic. Repetitive audit reader calls could be refactored into a helper method. However, the test structure and assertions are clear, showing expected revision history states. Overall comprehension is moderate but requires significant effort due to naming issues and redundancy.","tokens":1883,"name":"186.jsnp"}
{"score":"90","reasoning":"The code demonstrates excellent readability through consistent structure and clear naming conventions. Each line follows a predictable pattern for registering SQL functions, making it easy to understand at a glance. The function names and type parameters are descriptive, and the overall length is appropriate. Minor improvements could include more detailed Javadoc or grouping comments, but these do not significantly impact comprehension.","tokens":1872,"name":"21.jsnp"}
{"score":"35","reasoning":"Code suffers from cryptic variable names like loBits hiTime excessive verbose print statements with magic tilde lines unclear bit manipulation with magic numbers 0x3f and shifts no comments explaining purpose or UUID generation logic external helper classes not defined making behavior unclear inconsistent spacing and redundant System.currentTimeMillis calls reduce readability significantly","tokens":2217,"name":"58.jsnp"}
{"score":"85","reasoning":"Code demonstrates strong readability with clear JavaDoc, descriptive method name, and logical structure. Inline comments effectively separate two related test scenarios. Variable names are meaningful and assertion patterns are consistent. Minor improvements could include splitting into separate methods and clarifying the comment about table structure usage. Requires domain knowledge about Hibernate ID generation but remains comprehensible for its target audience.","tokens":2068,"name":"57.jsnp"}
{"score":"65","reasoning":"Code has inconsistent formatting, uses raw Iterator type, and fully qualified Map. Logic for condition resolution is fragmented with three separate checks. TODO comment reveals known design flaw and ordering dependency. Potential NullPointerException from unguarded model.getFilterDefinition() call. Variable names are clear and logging is helpful, but technical debt is evident.","tokens":2119,"name":"31.jsnp"}
{"score":"95","reasoning":"Clear Javadoc and descriptive naming. Clean formatting with each parameter on its own line. Simple factory method pattern with straightforward logic. Very easy to understand at a glance. Minor deduction for no null checks but appropriate for this context.","tokens":1864,"name":"67.jsnp"}
{"score":"60","reasoning":"Method name clearly indicates purpose and initial assertions are simple. However, readability suffers from complex nested instanceof checks with negations, long conditional lines, and dialect-specific branching with early returns. The logic requires deep knowledge of Hibernate dialect hierarchy. Extracting dialect checks into helper methods and restructuring would significantly improve comprehension. Comments help but don\u0027t offset structural issues.","tokens":2219,"name":"89.jsnp"}
{"score":"68","reasoning":"Method shows moderate readability with clear AAA structure and proper resource cleanup. Variable naming is inconsistent (p vs person). Property setup is verbose and repetitive with long keys. Single comment helps but is insufficient. Numerous assertions obscure the main test objective. Ignored getCacheManager() call is confusing. Requires domain knowledge. Could benefit from helper methods and better naming.","tokens":2197,"name":"131.jsnp"}
{"score":"60","reasoning":"Code uses anonymous inner classes creating excessive nesting and verbosity. Method name is overly long and complex. Heavy casting makes assertions hard to read. HQL query is clear but checking logic has deep nesting and inconsistent formatting. Parameters lack context. Understandable for experienced developers but requires effort to parse.","tokens":2191,"name":"98.jsnp"}
{"score":"78","reasoning":"Hibernate Integrator registration with clear purpose but inconsistent formatting and confusing method overloading where two public integrate methods delegate to a private integrate method. Anonymous inner class slightly obscures structure. Simple concise logic aids comprehension for Hibernate-aware developers despite these issues.","tokens":2094,"name":"174.jsnp"}
{"score":"92","reasoning":"Clean concise method with clear naming and structure. Null check prevents NPE. Try-catch properly handles close operation. Exception parameter named ignore clearly signals intent to suppress IOException. Minor deduction for empty catch block which could hide issues but pattern is common in resource cleanup. Overall highly readable and easily comprehensible for any Java developer.","tokens":1469,"name":"150.jsnp"}
{"score":"85","reasoning":"Code demonstrates good readability with clear variable names, logical structure, and helpful comments explaining the buffering mechanism. The method follows a straightforward two-path approach: draining buffered events or reading new ones. Minor deduction for slightly awkward phrasing in the first comment and subtle semantics of eventLimit values which could be clearer. Overall well-structured and easy to comprehend.","tokens":1506,"name":"151.jsnp"}
{"score":"90","reasoning":"The code demonstrates excellent readability through clear descriptive method names consistent formatting and self-documenting structure. The constructor\u0027s purpose is immediately obvious from the Javadoc and the repetitive pattern of registerColumnType calls makes the mapping logic easy to follow. While the $l $p $s placeholders might require domain knowledge and the method is lengthy due to necessary boilerplate these are minor issues that do not significantly impact comprehension.","tokens":1476,"name":"20.jsnp"}
{"score":"88","reasoning":"Code demonstrates good readability for asynchronous test execution. The try-finally block ensures proper cleanup. Comment explains the inlined approach clearly. Anonymous inner class syntax is verbose but functional. Qualified this reference may confuse beginners. Variable names are clear and scope is limited. Logic is straightforward and concise. Minor modernization could improve clarity but overall comprehension is strong.","tokens":1588,"name":"73.jsnp"}
{"score":"88","reasoning":"Clear Javadoc with proper parameter documentation. Standard equals method structure with early returns makes logic flow easy to follow. Uses familiar patterns: reference check, instanceof test, and super call. Minor redundancy in final return could be simplified but doesn\u0027t hinder comprehension. Well-indented and follows Java conventions.","tokens":1135,"name":"39.jsnp"}
{"score":"78","reasoning":"Code has clear intent and logical structure with good parameter naming. Minor formatting inconsistencies (mixed indentation, odd line breaks) and generic variable \u0027obj\u0027 slightly reduce readability. Domain-specific concepts (stereotypes, PropertyChangeEvent) require context. Independent if-blocks for add/remove are clear but could be commented. Overall well-organized with adequate separation of concerns.","tokens":1284,"name":"47.jsnp"}
{"score":"68","reasoning":"Decent structure with clear variable names and logical flow. Comments explain optimistic locking but contain a confusing phrase and typo. Method handles multiple concerns requiring Hibernate knowledge. Loop purpose unclear without context. Readable for ORM experts but challenging for others. Typo in generateSQLDeletStrings reduces quality.","tokens":2146,"name":"106.jsnp"}
{"score":"45","reasoning":"The code suffers from significant duplication of logic for removing a person from their old address, appearing four times. An empty else-if block for empty string input is confusing and lacks documentation. Deep nesting and side effects on both Person and Address objects reduce clarity. While null-safe and functional, these issues make maintenance difficult.","tokens":3047,"name":"61.jsnp"}
{"score":"68","reasoning":"The code has clear naming and helpful comments but suffers from long method chains violating Law of Demeter, requiring deep Hibernate domain knowledge. The null parameter is unclear and the subtle difference between generatedId and getId() adds cognitive load. Structure is clean but dependency navigation is complex.","tokens":1541,"name":"103.jsnp"}
{"score":"58","reasoning":"The code has clear intent and proper resource management but suffers from severe verbosity. Hibernate API requires deep method chaining with multiple casts making it hard to read. Anonymous inner class adds boilerplate versus modern lambdas. Deep nesting and magic numbers reduce comprehension. While functional and commented the outdated patterns and excessive verbosity significantly hinder readability.","tokens":2098,"name":"93.jsnp"}
{"score":"58","reasoning":"Method uses three anonymous inner classes causing deep nesting and verbosity. Raw type casting reduces clarity. HQL query line is excessively long. Complex assertions with nested calls and magic strings s/pc. Dependencies on external fields like yogiExpected are not visible. While the test pattern is clear, these issues significantly hinder readability for an otherwise moderately complex Hibernate test.","tokens":1748,"name":"99.jsnp"}
{"score":"58","reasoning":"The test method name testHHH6635 is cryptic and non-descriptive. Contains a critical bug: maxPoolSize retrieves maxStatements attribute, severely hindering comprehension. Variable names set and obj are too generic. Uses fragile indexOf for MBean lookup. While the assert pattern is clear and the comment helps, the typo in BMean and lack of self-documentation reduce readability. Structure is adequate but clarity is poor.","tokens":2441,"name":"90.jsnp"}
{"score":"30","reasoning":"Poor readability due to deeply nested ternary operators and dense single-line structure. Complex logic mixing null checks with quoted/unquoted comparisons creates a convoluted decision tree that\u0027s extremely hard to follow and error-prone. Requires decomposition into intermediate variables or helper methods for clarity.","tokens":2090,"name":"36.jsnp"}
{"score":"50","reasoning":"Deep nesting with double loops creates O(n*m) complexity and hinders readability. Awkward multi-line casting and complex state flags make logic harder to trace. No comments explain intent. Mixed concerns and commented-out code suggest hidden complexity. Variable names are adequate but don\u0027t compensate for structural issues.","tokens":1860,"name":"50.jsnp"}
{"score":"40","reasoning":"Cryptic method name with excessive length. Heavy casting throughout reduces readability. Manual index tracking via scattered index++ calls is error-prone and unclear. Multiple nested instanceof checks create complex conditional branches. Test mixes Hibernate boilerplate with verification logic in a dense structure. Listener method names are descriptive but overall flow is obscured by type conversions and unclear intent. Single test validates too many scenarios simultaneously.","tokens":2354,"name":"140.jsnp"}
{"score":"65","reasoning":"Test method has clear structure but suffers from severe code repetition with hardcoded revision numbers 1-5. Cryptic variable names like ed1_id and ing2_id lack context. Uses raw assert statements instead of JUnit assertions reducing debuggability. Magic numbers and missing comments obscure what each revision represents. Should be refactored with a loop and helper method for clarity.","tokens":2645,"name":"166.jsnp"}
{"score":"35","reasoning":"The method suffers from poor single responsibility principle being a kitchen-sink test with excessive length. The dialect check is overly complex and hard to parse. Magic strings and lack of comments make query purposes unclear. Complex HQL queries are unformatted and crammed. While it follows Hibernate patterns, the mixing of setup, multiple test cases, assertions, and teardown without structure severely hampers comprehension.","tokens":1767,"name":"68.jsnp"}
{"score":"68","reasoning":"Method name is clear but code lacks comments explaining intent. The xs, ys arrays implicitly define a diamond shape, requiring mental parsing. Magic number 5 is ambiguous; its purpose is unclear. Variable names are functional but brief. Understandable with effort, but implicit geometry and unexplained magic number are significant readability hurdles.","tokens":2514,"name":"153.jsnp"}
{"score":"70","reasoning":"The code uses anonymous inner classes creating excessive nesting and verbosity. Inconsistent spacing in casts reduces visual clarity. Contains redundant assertions and mixes data validation with Hibernate lazy-loading checks. While method name is descriptive and structure is logical, modern lambda syntax would improve readability significantly. The multiple concerns in one test method make it harder to understand the specific behavior being tested.","tokens":2434,"name":"96.jsnp"}
{"score":"35","reasoning":"Code uses verbose anonymous inner class instead of lambda, repetitive casting to internal Hibernate APIs, long chained method calls, empty exception handling, and lacks try-with-resources. Hardcoded SQL strings and no comments reduce maintainability. Modern Java features would significantly improve readability.","tokens":1387,"name":"100.jsnp"}
{"score":"68","reasoning":"Method uses parser instead of parse verb form. MockHelper name is confusing for production code. Nested ifs could be flattened. Inconsistent spacing around parentheses. Logic is clear and variable names are descriptive but these issues reduce readability. Returning null requires caller checks. Understandable but has style and naming problems.","tokens":1823,"name":"193.jsnp"}
{"score":"70","reasoning":"The test follows a clear AAA structure with straightforward assertions. However, the method name testProperties is too generic and doesn\u0027t convey the specific filtering behavior being tested. The property keys are cryptic (rpt.N prefix) and the duplicate rpt.5/rpt.6 entries are confusing without comments. While the code is functional, it lacks self-documenting clarity and requires inference to understand its purpose.","tokens":1831,"name":"35.jsnp"}
{"score":"85","reasoning":"Code demonstrates good readability with clear method structure, descriptive naming, and standard JPA transaction patterns. Minor issues include undeclared country field dependency, magic number 123, and ambiguous Priority annotation purpose. Well-spaced logical blocks and concise comments enhance comprehension. Overall very readable test setup method with room for minor improvements.","tokens":1180,"name":"168.jsnp"}
{"score":"65","reasoning":"Test method has clear purpose and logical structure but suffers from poor resource management with unclosed Statement, no exception handling, mixing JDBC and HQL abstractions, and Hibernate-specific casting. Magic numbers for IDs and lack of cleanup in finally block reduce maintainability. Annotations provide good context but the implementation has readability issues.","tokens":1517,"name":"136.jsnp"}
{"score":"65","reasoning":"Code follows standard equals pattern correctly but suffers from dense ternary operators for null checks that hinder readability. The logic requires careful mental parsing and is less intuitive than using Objects.equals(). While functional and recognizable to experienced developers, the compact style makes it unnecessarily difficult for junior developers and deviates from modern Java best practices.","tokens":2343,"name":"60.jsnp"}
{"score":"35","reasoning":"Code suffers from inconsistent indentation mixing tabs and spaces uses legacy Vector and Enumeration requiring explicit casts includes unclear comment source and duplicates Designer call algorithm uses inefficient nested loops variable names like tde elems p are cryptic overall structure is hard to follow despite simple logic","tokens":1719,"name":"46.jsnp"}
{"score":"55","reasoning":"Code has significant readability issues: poorly named mInterface variable as Object commented-out cast suggests confusion cryptic ffCodePiece method uses null parameter raw Stack requires casting and undefined name variable breaks context. Simple if-else structure is clear but maintenance is hindered by these problems.","tokens":1764,"name":"116.jsnp"}
{"score":"65","reasoning":"Method demonstrates clear naming conventions and logical structure for processing discriminator annotations. However critical typo clazzToClass creates confusion. Inconsistent use of fully qualified names reduces clarity. Method combines multiple responsibilities violating single purpose principle. While ternary operators are used effectively the complex inheritance logic lacks explanatory comments. Overall decent readability marred by significant issues.","tokens":2995,"name":"28.jsnp"}
{"score":"55","reasoning":"Method name processEntity is misleading as it always returns null. Unused entityType parameter adds confusion. Formatting issues like value!\u003dnull reduce clarity. The comment helps but reveals this is framework-specific code requiring Hibernate knowledge. Side effects without clear return value make it hard to understand in isolation. Simple structure is its only readability merit.","tokens":1781,"name":"65.jsnp"}
{"score":"70","reasoning":"Descriptive method name and clear test intent but readability suffers from multi-line string concatenation for complex SQL. The expected query is difficult to parse visually due to broken formatting. Dense assertion statement and verbose method name slightly hinder comprehension. Would benefit from text blocks or formatted external resources.","tokens":1773,"name":"23.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear naming, structured switch statement, and meaningful exceptions. Defensive checks are well-placed. Logic is easy to follow despite XML parsing complexity. Minor improvement could be extracting entity handling, but overall comprehension is high. Good use of StringBuilder and appropriate comments.","tokens":1480,"name":"152.jsnp"}
{"score":"68","reasoning":"Code has clear variable names and good formatting but suffers from nested complexity. The three-part conditional with deep method chains (entityPersister.getEntityMetamodel().getIdentifierProperty...) is hard to parse. Logic for composite identifiers is cryptic despite the brief comment. Could be improved by extracting the condition into a named method and adding more explanatory documentation. Requires domain knowledge to fully comprehend.","tokens":1650,"name":"198.jsnp"}
{"score":"65","reasoning":"The code suffers from excessive nesting (3 levels) and inconsistent indentation mixing tabs and spaces. The nested if-else structure instead of using else-if creates unnecessary complexity. While the logic is straightforward, the formatting issues and deep nesting make it harder to follow than necessary. Better structure and consistent formatting would significantly improve readability.","tokens":1094,"name":"157.jsnp"}
{"score":"52","reasoning":"The code suffers from severe indentation inconsistencies, particularly within the catch block where the while loop and its contents are misaligned. This makes the nested control flow difficult to parse visually. Additionally, using a raw Iterator type reduces type safety and clarity. While method naming and Javadoc are good, the formatting issues significantly hinder readability and ease of comprehension.","tokens":1872,"name":"7.jsnp"}
{"score":"92","reasoning":"Code demonstrates excellent readability with consistent pattern and clear naming. Each line follows a predictable structure making it easy to scan. Minor deductions for minimal Javadoc and lack of functional grouping. The substring to substr mapping is slightly subtle but acceptable. Overall very easy to comprehend for anyone familiar with SQL function registration patterns.","tokens":1619,"name":"18.jsnp"}
{"score":"80","reasoning":"Method name is clear and constructor parameters are well-formatted vertically. Map parameter is overly generic, constructor takes many arguments reducing clarity, and TODO indicates incomplete implementation requiring context about instance fields.","tokens":1166,"name":"55.jsnp"}
{"score":"85","reasoning":"Clear structure and intent with efficient StringBuilder usage. Minor issues include inconsistent indentation, mixed usage of this keyword, and an informal comment. Long lines in the conditional block slightly reduce readability. Overall easy to comprehend with room for minor stylistic improvements.","tokens":1523,"name":"64.jsnp"}
{"score":"88","reasoning":"Excellent Javadoc explains purpose and exceptions clearly. Descriptive method and variable names. Straightforward if-else logic with good use of final keywords. Minor deductions for verbose collection access pattern and slight mismatch between documented exception type and actual thrown exception. Very readable for Hibernate developers.","tokens":2182,"name":"102.jsnp"}
{"score":"55","reasoning":"Anonymous inner classes mix definition and usage reducing clarity. Implicit dependencies output and expected method require external context. Magic strings and overridden methods need parent class knowledge. Compact structure obscures Arrange-Act-Assert pattern. Decent variable names but overall moderate difficulty due to tight coupling and missing documentation.","tokens":1502,"name":"12.jsnp"}
{"score":"88","reasoning":"Standard equals() pattern with clear structure and early returns. Javadoc is mostly accurate but @return tag is incomplete omitting hour/day checks. Variable naming is conventional. Potential null safety issue with this.day.equals() not addressed. Very readable despite minor documentation and safety concerns.","tokens":1759,"name":"42.jsnp"}
{"score":"68","reasoning":"Method has clear intent but suffers from poor formatting. The HQL query with chained pagination methods is crammed into one long line reducing readability. Assertion logic is convoluted requiring removal of first element to test for duplicates. Contains a typo dublicated in message and commented debug code. Manual session management is acceptable for test context but try-with-resources would be better. Overall structure is compact but line breaks and clearer assertion approach would improve comprehension significantly.","tokens":1560,"name":"92.jsnp"}
{"score":"40","reasoning":"Code contains large blocks of commented-out logic with misleading indentation making actual execution path unclear. Variable runs is initialized to 0 and never incremented yet used in calculation suggesting incomplete refactoring. Inconsistent brace style and unclear helper methods title and opsPerMS reduce comprehension. Try-finally structure and trace logging are positive but overshadowed by clutter. Overall difficult to understand intent and actual behavior.","tokens":2912,"name":"172.jsnp"}
{"score":"75","reasoning":"The method uses a clear if-else chain with descriptive comments explaining the precedence logic for selecting a loader. Variable and method names are meaningful. However, the third condition is overly complex and dense, reducing immediate comprehension. Repetitive calls to createEntityLoader and necessary casting add slight cognitive overhead. Overall structure is sound but requires careful reading due to conditional complexity.","tokens":1540,"name":"107.jsnp"}
{"score":"45","reasoning":"Test lacks clarity due to unexplained magic numbers 15, 16, 17, heavy reliance on external state variables, and complex setup with nested constructors. The audit query logic is dense and array indexing with casting is cryptic. No comments explain the test phases or expected behavior. While variable names are decent and structure follows arrange-act-assert pattern, overall comprehension requires deep external context making it difficult to maintain.","tokens":1957,"name":"167.jsnp"}
{"score":"65","reasoning":"The code suffers from excessive method chaining making it hard to follow the object navigation. The exception variable name ok is unclear. However it uses proper try-finally for resource cleanup and has a descriptive assertion message. The boolean flag pattern is functional but verbose. Overall structure is logical but comprehension is hindered by the deep hierarchy traversal.","tokens":1173,"name":"145.jsnp"}
{"score":"68","reasoning":"Test method demonstrates JPA entity revision handling with clear sequential comments. Variable names like c3_1 and c3_2 are cryptic. Repetitive transaction boilerplate reduces readability but follows consistent pattern. Overall structure is logical and intent is clear for those familiar with Envers auditing, making it moderately easy to comprehend despite some naming issues.","tokens":1482,"name":"188.jsnp"}
{"score":"70","reasoning":"The test method has a clear name and uses descriptive assertions. However, it suffers from excessive repetition with 18 consecutive assertAnnotationNotPresent calls, creating a verbose block that hinders quick scanning. The hardcoded filename and implicit reader setup reduce clarity. While functional, the repetitive pattern significantly impacts readability and maintainability. Grouping assertions or using parameterized tests would improve comprehension.","tokens":2006,"name":"176.jsnp"}
{"score":"95","reasoning":"Clear Javadoc and standard serialization method. Descriptive variable names with consistent pattern. Simple sequential logic enhances comprehension. Repetitive structure is predictable and idiomatic for serialization. Length is justified and doesn\u0027t hinder readability. Follows Java conventions excellently.","tokens":1563,"name":"3.jsnp"}
{"score":"80","reasoning":"Well-structured method with clear naming and proper error handling. Logging aids debugging. Readability is slightly hampered by repeated long method chains and domain-specific terminology requiring framework knowledge. Type casting and nested conditionals are acceptable but could benefit from brief comments. Overall solid Java practices with descriptive variables and final modifiers.","tokens":1721,"name":"183.jsnp"}
{"score":"70","reasoning":"Test method demonstrates clear intent with consistent structure and good variable naming. However, severe code repetition across seven similar test cases violates DRY principles and reduces scanability. Magic constants lack context. Should use parameterized tests for better maintainability and comprehension. Whitespace handling in test cases is inconsistent without explanation. Overall pattern is understandable but unnecessarily verbose.","tokens":1882,"name":"26.jsnp"}
{"score":"78","reasoning":"Method name is overly verbose but descriptive. Multi-line comment effectively explains the complex HHH-2277 scenario involving bidirectional eager fetching and composite keys. Code structure is logical with clear setup and verification phases. Variable naming is adequate though session variable \u0027s\u0027 is terse. Test intent is clear and follows Hibernate testing patterns. Good readability for framework test case despite minor verbosity issues.","tokens":2464,"name":"175.jsnp"}
{"score":"55","reasoning":"Method name is excessively long and convoluted. Helper methods like checkEntities and checkEntityNames are too generic, providing no insight into specific assertions. Comment uses unexplained acronym AR and adds minimal value. While structure is clean and concise, the abstraction level is too high without descriptive naming, making test purpose unclear without diving into implementation details.","tokens":1335,"name":"187.jsnp"}
{"score":"88","reasoning":"Clear Javadoc explains purpose. Method name init() is generic but acceptable. Variable npf is slightly abbreviated. Code follows consistent pattern with aligned parameters. Commented line is minor distraction. Overall structure is logical and easy to follow. Class names are descriptive. Single responsibility is well maintained.","tokens":1174,"name":"5.jsnp"}
{"score":"72","reasoning":"Method name is clear and code is well formatted. Parameter j is ambiguous and session is unused which reduces clarity. Return value purpose is not obvious from method name. Comment references internal issue HHH-2236 which may be cryptic. Overall logic is straightforward and naming is consistent. Requires context about lazy property initialization to fully understand.","tokens":1613,"name":"104.jsnp"}
{"score":"92","reasoning":"Excellent readability with clear Javadoc documentation describing purpose and parameters. Method structure is linear and easy to follow: initialize context, process persistent classes in a simple loop, handle leftovers, finalize, and return result. Descriptive naming for methods and variables enhances comprehension. Minor deductions for slight Javadoc indentation inconsistency and a dense return statement, but overall highly maintainable and understandable.","tokens":1673,"name":"126.jsnp"}
{"score":"58","reasoning":"Code shows clear intent but suffers from excessive repetition violating DRY principle. Method names like getSawRegionModification are misleading as they appear to have side effects rather than being getters. While linear structure is simple to follow, maintenance would be cumbersome requiring 8 line changes per added region. Could be refactored with loops or helper methods to improve conciseness and reduce error-prone duplication.","tokens":1420,"name":"190.jsnp"}
{"score":"68","reasoning":"Clear method name and consistent assertion style but overly long with multiple test scenarios. Repetitive patterns and unexplained magic numbers hinder readability. No comments or blank lines separate logical blocks. While individual lines are understandable, the density and lack of structure make quick comprehension difficult. Would benefit from splitting into focused methods and introducing helper functions for common assertions.","tokens":3138,"name":"135.jsnp"}
{"score":"72","reasoning":"Generally readable with clear structure and intent. Main issues: commented-out code reduces maintainability; variable \u0027p\u0027 is too brief; unnecessary line break after getPropertyName(). Good aspects: helpful active comments, proper null check, consistent indentation. Logic is straightforward.","tokens":1591,"name":"11.jsnp"}
{"score":"55","reasoning":"Code suffers from inconsistent indentation and confusing naming (CompositeIdId, id2, getted). Repetitive session/transaction boilerplate adds noise. The long SQL string is difficult to read. While comments explain the test intent, the structure could be improved with helper methods and better formatting. Overall logic is followable but requires effort to understand.","tokens":1612,"name":"72.jsnp"}
{"score":"87","reasoning":"Clear BDD-style method name and well-structured AAA test pattern. Variable names are descriptive and Hamcrest assertions enhance readability. Minor deductions for broad throws Throwable declaration, dependency on undefined helper methods (signature, getStringValuesFromAssignments), and slightly dense constructor nesting. Overall excellent readability for developers familiar with JUnit/Hamcrest.","tokens":1289,"name":"159.jsnp"}
{"score":"72","reasoning":"The code shows consistent structure with clear revision comments and descriptive variable names. However constructor parameters lack clarity making entity initialization ambiguous. Long fully-qualified class names reduce readability. Method mixes data creation with table mapping retrieval which could be separated. Overall pattern is understandable but parameter meaning and class name verbosity hinder comprehension.","tokens":1357,"name":"189.jsnp"}
{"score":"65","reasoning":"Test method suffers from excessive repetition with many similar assertions verifying annotation properties. While the test name is descriptive and individual assertions are clear, the length and verbosity make it hard to grasp the core test intent quickly. Deep method chaining and magic numbers reduce readability. Could be improved by extracting helper methods or using parameterized tests to reduce duplication.","tokens":1973,"name":"177.jsnp"}
{"score":"50","reasoning":"Monolithic test method reuses translator variable across multiple scenarios, mixing return type and parameter type validation. Lacks comments explaining type inference logic. Repetitive assertions and embedded magic literals reduce clarity. While method name and assertion messages are descriptive, the structure requires careful reading to understand each case. Would benefit from splitting into separate methods or adding explanatory comments.","tokens":1872,"name":"88.jsnp"}
{"score":"35","reasoning":"Deep method chaining with embedded cast and long string literal makes code hard to follow. Lack of intermediate variables forces mental parsing of nested operations. While test name is clear, the implementation is overly compacted requiring careful reading to trace data flow from configuration to column name.","tokens":1222,"name":"199.jsnp"}
{"score":"75","reasoning":"Method name clearly describes purpose and structure is logical. Variable names are mostly descriptive. Core logic is straightforward: validate parameter count, create instance, inject fields. However uses deprecated newInstance(), verbose string concatenation for error messages, non-standard exception variable name iare, and throws generic Exception. Syntactic noise reduces readability but overall comprehension remains moderate with clear error handling.","tokens":1828,"name":"13.jsnp"}
{"score":"90","reasoning":"The code demonstrates good readability with clear variable names, logical structure, and descriptive error messages. The two-phase validation approach is easy to follow. Minor improvements could include renaming the loop variable \u0027each\u0027 to something more specific and adding a brief comment, but overall it\u0027s well-written and comprehensible.","tokens":1331,"name":"14.jsnp"}
{"score":"62","reasoning":"Method tests HQL parsing with multiple complex query strings. Lacks organization grouping related cases. Dense syntax-heavy strings reduce quick comprehension. Contains duplicate test case and unclear comment about uncertain tests. Inconsistent capitalization and commented-out tests add clutter. While structurally simple, the cognitive load of parsing each HQL statement makes it moderately difficult to understand. No explanatory comments for individual test cases.","tokens":2434,"name":"85.jsnp"}
{"score":"95","reasoning":"Excellent readability with highly descriptive method names. Simple constructor structure with a clear sequence of initialization calls. Minimal but adequate Javadoc. Self-documenting code with no complex logic. Easy to understand purpose and behavior even without full context. Method names transparently indicate registration categories.","tokens":1784,"name":"19.jsnp"}
{"score":"82","reasoning":"Clear AAA pattern with descriptive variable names. Comment and HQL query effectively demonstrate test purpose. Raw types require suppress warnings annotation. Method name is technical but precise. Well-structured session blocks separate setup, execution and cleanup logically. Easy to comprehend for developers familiar with Hibernate testing conventions.","tokens":2039,"name":"82.jsnp"}
{"score":"50","reasoning":"Excessive runtime casting (3 casts) creates fragility and comprehension difficulty. Long chained calls and parameter names reduce clarity. No null checks, documentation, or error handling. While brief with descriptive names, tight coupling to Hibernate types and multi-parameter calls signal poor API design. Requires deep domain knowledge, harming maintainability.","tokens":1425,"name":"148.jsnp"}
{"score":"70","reasoning":"The Javadoc and method signature are clear, but the CAS loops for min/max updates are dense and require advanced concurrency knowledge. The read lock rationale is non-obvious despite comments. While functional, the code prioritizes compactness over clarity, making it challenging for developers unfamiliar with atomic operation patterns. Proper try-finally usage is a positive aspect.","tokens":1241,"name":"62.jsnp"}
{"score":"70","reasoning":"Test uses legacy Hibernate Criteria API with anonymous inner classes creating verbosity. Multiple type casts and commented bug reference reduce clarity. Method name is descriptive and variable names are reasonable but nested structure makes flow harder to follow. Modern lambdas would improve readability significantly. Overall structure is understandable but dated.","tokens":1322,"name":"97.jsnp"}
{"score":"55","reasoning":"Method name is misleading (get vs process) and relies heavily on side effects modifying annotationList. Javadoc is overly technical without clear purpose. While helper methods have descriptive names, the method is too long and dense, making it hard to follow the overall logic. Requires deep domain knowledge to comprehend quickly.","tokens":2039,"name":"149.jsnp"}
{"score":"92","reasoning":"Excellent Javadoc clearly explains purpose parameters and return value. Good descriptive variable names and logical nested loop structure for category and series iteration. Input validation is properly handled. Minor improvements: loop variable \u0027item\u0027 could be \u0027categoryIndex\u0027 for clarity and the final null check logic is subtle. The comment explaining addition of negative values is helpful but indicates code could be slightly more self-explanatory. Overall highly readable professional code.","tokens":1889,"name":"41.jsnp"}
{"score":"78","reasoning":"Test method demonstrates good structure with clear naming conventions and final variables. The SQL strings are overly long reducing readability and the string concatenation for expected spans awkwardly across lines. Lacks comments explaining test purpose. Overall follows standard unit test patterns making intent understandable despite complex SQL syntax.","tokens":1259,"name":"24.jsnp"}
{"score":"45","reasoning":"The method constructs an Object array with unexplained null values that appear to be separators. The untyped return forces casting and lacks safety. Inconsistent naming getActionX vs getXActions creates confusion. No documentation clarifies intent or structure. While syntactically simple, these design choices severely hinder comprehension and maintainability.","tokens":1654,"name":"156.jsnp"}
{"score":"55","reasoning":"Poor formatting with awkward line breaks and inconsistent indentation. Repeated array access newActions[i] hurts readability. Uses unchecked cast and external static shortcutHash without context. Comments help but placement is poor. Logic is understandable but verbose. Extracting variables and reformatting would help.","tokens":2431,"name":"51.jsnp"}
{"score":"55","reasoning":"Method has clear intent but suffers from repeated method calls inside loop condition and body reducing readability and performance. The initPropertyPaths call passes seven parameters which is excessive and creates a long parameter list anti-pattern. While naming is consistent and descriptive, the code would benefit from caching array references before the loop and potentially refactoring parameters into a context object.","tokens":1327,"name":"105.jsnp"}
{"score":"25","reasoning":"Code shows poor readability due to cryptic naming conventions like caseSList _loop119 and _tokenSet_6 excessive whitespace inconsistent indentation unnecessary nested blocks and overly complex control flow using do-whiletrue with labeled break instead of simple while loop. Appears to be generated parser code with no consideration for human comprehension. The logic is obscured by anti-patterns making it hard to understand at a glance.","tokens":1408,"name":"115.jsnp"}
{"score":"75","reasoning":"Descriptive method name and clear variables follow AAA pattern. Requires Hibernate expertise. Long method chain, external serviceRegistry, and magic number 0 reduce clarity. Missing proper resource cleanup. Helpful assertion messages but domain complexity hinders general comprehension. Could use try-with-resources and explanatory comments.","tokens":1925,"name":"178.jsnp"}
{"score":"65","reasoning":"Method name clearly indicates purpose but annotation block is overly verbose. Code has inconsistent indentation mixing tabs and spaces. Contains System.out.println anti-pattern. Assertions are repetitive with unexplained trim() calls. Comment is too long. Follows Hibernate patterns but needs better structure and explanation of magic values. Moderately readable with room for improvement.","tokens":1546,"name":"138.jsnp"}
{"score":"50","reasoning":"Deep method chaining repeated four times creates verbosity. Three nearly identical iterator test blocks show excessive duplication. Unnecessary HashSet construction adds complexity without clarity. Descriptive naming is present but test intent remains obscure due to lack of comments or helper methods. Functional yet difficult to maintain.","tokens":2727,"name":"180.jsnp"}
{"score":"68","reasoning":"Code has clear naming and logical structure but suffers from inconsistent formatting with awkward line breaks. The thread.interrupt() placement within a null check is confusing. Uses dated generic syntax. Overall comprehension is moderate but requires careful reading due to layout issues.","tokens":1396,"name":"125.jsnp"}
{"score":"55","reasoning":"Method name is overly verbose. Empty catch block is confusing without comments. Dependencies on external variables (thrown, TIMEOUT) are unclear. throws Throwable is too broad. Magic number 50 lacks context. No inline comments explaining the unusual test flow. While the intent is discernible, the implementation requires significant mental effort to understand.","tokens":1618,"name":"160.jsnp"}
{"score":"78","reasoning":"Good Javadoc and inline comments explain purpose and non-obvious behavior. Parameter names are clear. Loop indexing pattern requires knowledge of EventListenerList internals which may confuse novices. Inconsistent indentation in event creation. Overall follows standard Java event patterns well.","tokens":1646,"name":"9.jsnp"}
{"score":"45","reasoning":"Code suffers from major readability issues. Highly repetitive type-checking if-statements violate DRY principle. Variable names like eo and me are cryptic. Uses raw type Vector. Logic is ambiguous: non-exclusive ifs may cause multiple removals and intent of oldOwned.contains(eo) is not immediately clear. Lack of comments exacerbates comprehension difficulty.","tokens":2134,"name":"119.jsnp"}
{"score":"55","reasoning":"The method uses guard clauses but suffers from readability issues. The first if lacks braces and its return is confusing - it doesn\u0027t negate the dirty check like other branches. The Hibernate method name is cryptic. Long chained method calls reduce clarity. While the method name and comments help, inconsistent patterns and missing braces hinder comprehension.","tokens":2719,"name":"111.jsnp"}
{"score":"58","reasoning":"Code uses nested anonymous classes which harms readability. Parameter p is non-descriptive and null arguments lack clarity. The double nesting requires careful tracing to understand flow. While method is compact and second override is simple, overall structure is dense and framework-specific knowledge is required. Magic values and service registry building are opaque. Test context helps but doesnt offset structural complexity.","tokens":1286,"name":"132.jsnp"}
{"score":"80","reasoning":"Code demonstrates clear purpose via Javadoc and logical field grouping with separators. Consistent addField pattern aids comprehension. However inconsistent indentation particularly around classifierScroll creation and single letter variable a reduce clarity. Complex nested instantiation could benefit from better formatting or decomposition. Overall structure is sound but minor formatting issues and ambiguous naming prevent higher score.","tokens":2476,"name":"158.jsnp"}
{"score":"90","reasoning":"Method is clear and focused with descriptive naming. Minor style issues include non-standard spacing inside parentheses and verbose fully-qualified class name. Uses pre-diamond operator syntax. Overall structure is excellent and logic is immediately understandable.","tokens":1821,"name":"16.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability through consistent formatting, clear method naming, and a straightforward repetitive pattern that maps Java SQL types to database-specific types. The Javadoc comment, while minimal, adequately explains the constructor\u0027s purpose. Each mapping is on a separate line making it easy to scan and maintain. The code requires minimal cognitive effort to understand its intent and functionality.","tokens":1186,"name":"25.jsnp"}
{"score":"50","reasoning":"The code suffers from raw type usage forcing explicit casts reducing type safety and clarity. A critical readability flaw is the dense multi-parameter method call with nested ternary operators making it hard to trace arguments. While the overall structure is logical and uses StringBuilder appropriately, these issues significantly hinder quick comprehension. Better formatting and generics would greatly improve maintainability.","tokens":2210,"name":"34.jsnp"}
{"score":"65","reasoning":"Code uses non-intuitive bit manipulation pattern requiring domain knowledge. Javadoc is minimal and vague. Magic numbers present. While consistent and functional, the left-then-right shift approach is unnecessarily complex compared to standard right-shift or ByteBuffer alternatives. Variable naming is clear. Method is short and focused. Requires mental effort to understand intent and endianness.","tokens":1867,"name":"113.jsnp"}
{"score":"55","reasoning":"Code suffers from deep nesting and repetition. The ANY_EVENT branch inconsistently handles only module and notation events, omitting generator events, which is confusing. Repeated instanceof checks and casts violate DRY principles. Range checks for event types add cognitive load. While variable names are clear, the structure makes it difficult to quickly understand the dispatch logic and risks bugs during maintenance.","tokens":1657,"name":"43.jsnp"}
{"score":"90","reasoning":"Well-documented method with clear Javadoc and straightforward logic. Exception handling is explicit but slightly verbose due to fully qualified names and instanceof checks. Minor formatting inconsistencies. Overall highly readable with good structure and meaningful naming.","tokens":1808,"name":"164.jsnp"}
{"score":"58","reasoning":"Method uses anonymous inner class causing deep nesting and boilerplate. Complex conditional logic with transactional flag and removeRegion parameter. Assertion logic is counter-intuitive requiring careful reading. Exception handling is inconsistent. Dependencies on external state cm/tm/KEY1 are unclear. Descriptive name but overall structure hinders quick comprehension. Could be refactored for clarity.","tokens":1508,"name":"173.jsnp"}
{"score":"68","reasoning":"Well-structured method with descriptive naming. The boolean logic for \u0027flush\u0027 is complex and requires careful parsing. Deep method chaining violates Law of Demeter, reducing clarity. Domain-specific concepts require contextual knowledge. The comment about exceptions is helpful but indicates underlying complexity. Moderately readable for framework developers.","tokens":1838,"name":"184.jsnp"}
{"score":"80","reasoning":"Clear JavaDoc and descriptive method naming provide good context. The lengthy method chain and complex negated boolean condition require careful reading. Proper exception handling with resource cleanup is exemplary. Five parameters are manageable due to clear names. Overall structure is logical and idiomatic for framework code.","tokens":2240,"name":"33.jsnp"}
{"score":"45","reasoning":"Poor variable naming src sel d and inconsistent indentation hinder readability. Logic appears buggy when d is set it gets immediately overwritten by sel in the final setTarget call. Unexpected side effect with numJumpToRelated increment. No comments explain intent. Raw Vector usage requires casting. Method name is vague. Functional but confusing and hard to maintain.","tokens":2101,"name":"10.jsnp"}
{"score":"85","reasoning":"Method is well-named with clear parameters and logical step-by-step flow. Minor issues: inconsistent spacing around parentheses, abbreviated variable \u0027jc\u0027, and lack of try-with-resources for InputStream makes resource management less explicit. Overall structure is straightforward and easy to comprehend for developers familiar with JAXB.","tokens":1670,"name":"194.jsnp"}
{"score":"85","reasoning":"Well-structured test with clear naming and logical flow. Deep assertion chain requires careful reading but is methodical. Very long class names slightly hinder readability. Domain knowledge needed. Overall clean and comprehensible for target audience.","tokens":1829,"name":"142.jsnp"}
{"score":"80","reasoning":"Clear formatting and naming but non-standard structure. Multiplying between fields instead of using the conventional pattern for each field creates asymmetry that may confuse experienced developers, requiring extra verification despite logical clarity.","tokens":2660,"name":"141.jsnp"}
{"score":"75","reasoning":"The code demonstrates clear logic with simple conditionals and proper formatting. The Javadoc comment contains confusing phrasing about line ends. Variable names hasLf and hasCr use non obvious abbreviations. Method name addChar is generic for line ending detection. Despite these issues the core functionality is easily comprehensible.","tokens":3128,"name":"6.jsnp"}
{"score":"92","reasoning":"The code demonstrates excellent readability with clear Javadoc, standard equals() implementation pattern, and explicit field comparisons. Each condition is separated for clarity, making it easy to follow. Minor improvement could be made to the return description in the comment, but overall it\u0027s highly comprehensible and well-structured.","tokens":1587,"name":"114.jsnp"}
{"score":"75","reasoning":"Method has clear purpose but suffers from inconsistent formatting including irregular indentation and parameter line breaks. Variable naming is acceptable but could be more descriptive. Logic flow is straightforward with proper resource cleanup in finally block though try-with-resources would be more modern. Overall structure is sound but visual presentation needs improvement for better readability.","tokens":1575,"name":"49.jsnp"}
{"score":"68","reasoning":"Test method shows Hibernate any mapping with clear setup but suffers from verbose session management, single-line HQL queries, detached variable declaration, and dense TODO comment. Lacks explicit assertions making intent unclear. SuppressWarnings indicates type safety issues. Logical structure but implementation details hinder comprehension for non-experts.","tokens":1927,"name":"80.jsnp"}
{"score":"60","reasoning":"Method has clear intent but suffers from poor practices. The type cast to SessionImplementor suggests API design issues. Deep method chaining reduces clarity. Catching and ignoring Throwable is a major anti-pattern that hides potential problems. Parameter abbreviation ps is unclear. Inconsistent spacing. While short and focused, these issues significantly impact maintainability and comprehension.","tokens":1419,"name":"95.jsnp"}
{"score":"72","reasoning":"Test method combines two scenarios causing length and duplication. Magic numbers like -1 lack context. Comments have typos but explain intent. Clear variable names and logical flow aid understanding. Splitting into separate methods and using constants would improve readability significantly.","tokens":2101,"name":"56.jsnp"}
{"score":"68","reasoning":"Poetic comment is unhelpful for documentation. Nonstandard modifier order static public. Constructor logic is verbose but clear. Good specific exception handling. Dependencies warning() and exceptionToString() are undefined. Variable scoping could be tighter. Cast at end suggests type safety issues. Functional but needs style and documentation fixes.","tokens":1751,"name":"2.jsnp"}
{"score":"72","reasoning":"Very long method name is hard to parse quickly. Positional parameters reduce readability versus named parameters. Test follows logical progression with minimal but helpful comments. Code is dense with generic variable names like \u0027result\u0027. Test data preparation is opaque. Positives include clear HQL query string and proper resource management. Would benefit from whitespace separation and more descriptive naming.","tokens":2296,"name":"91.jsnp"}
{"score":"72","reasoning":"Method name is descriptive and logic flow is sequential. Good use of guard clauses and clear variable names. However uses outdated instance check pattern, has hidden dependency on metadata field, and the tilde comment separator is noisy. The TODO comment is helpful but reveals the method handles a limited case. Could be improved by splitting into smaller methods.","tokens":1806,"name":"147.jsnp"}
{"score":"25","reasoning":"Code suffers from inconsistent naming, buggy null handling risking NPEs, overly complex single-line logic, commented-out fragments, and inconsistent this usage. Manual byte array comparison is redundant and custom array access is fragile. These issues severely hinder readability and comprehension.","tokens":2993,"name":"74.jsnp"}
{"score":"45","reasoning":"The code suffers from excessive method chaining and repeated casting making it hard to follow. Anonymous inner class adds unnecessary nesting. While intent is clear from method name and comments, the implementation is overly verbose and violates principle of least astonishment. Modern Java features like lambdas could improve readability significantly. Resource management is properly handled but the core logic is buried in complexity.","tokens":1298,"name":"94.jsnp"}
{"score":"90","reasoning":"Method name and initial comment clearly explain the purpose: testing keyword usage as identifiers. Structure is simple and repetitive, making it easy to follow. Each test case is isolated on its own line. While the HQL strings are intentionally confusing, the test code itself is clean and straightforward. Good naming and minimal complexity enhance readability.","tokens":1312,"name":"86.jsnp"}
{"score":"65","reasoning":"The code defines an inner class within the test method which reduces clarity. Variable naming is inconsistent queue is actually a Stack. The AST traversal uses manual stack management with nested loops making logic harder to follow. Comments are minimal but helpful. Test intent is clear from HQL strings. Overall structure is functional but could be more readable with better separation and modern Java features.","tokens":3884,"name":"87.jsnp"}
{"score":"82","reasoning":"Clear Javadoc and helpful comments explain design decisions. Complex generic type parameter with multiple interface bounds hinders quick comprehension. Nested try-finally blocks are correct but add structural complexity. Variable names are descriptive. Logic flow is sound with proper cleanup patterns. TODO provides good performance context.","tokens":2417,"name":"110.jsnp"}
{"score":"35","reasoning":"Excessive duplication with 11 nearly identical lines. Inconsistent formatting reduces clarity. Hardcoded boolean arrays lack descriptive names or comments, obscuring test intent. No parameterization or abstraction. While method signature is clear, the repetitive structure makes it difficult to understand what each combination tests and painful to maintain.","tokens":2218,"name":"59.jsnp"}
{"score":"68","reasoning":"Follows standard equals pattern but suffers from verbosity. Very long class name reduces readability. Uses nested null checks instead of Objects.equals. Super.equals call may be redundant. Properly formatted and logically correct but shows outdated patterns. Understandable yet could be modernized for better clarity.","tokens":1531,"name":"169.jsnp"}
{"score":"70","reasoning":"The code has clear structure and logical grouping with decent variable names. However it suffers from magic numbers without explanation duplicate autoResizeMode call minimal Javadoc and implicit dependencies on superclass fields and static managers. Hardcoded strings and lack of null checks reduce comprehension. Overall moderately readable for Swing developers but requires external context for full understanding.","tokens":1764,"name":"118.jsnp"}
{"score":"80","reasoning":"Excellent Javadoc with context and examples. Clear names and simple logic. Main issues: duplicated loops violating DRY, outdated raw Vector requiring casts, and magic number -10. These practices hinder maintainability and slightly reduce readability despite strong documentation.","tokens":2730,"name":"121.jsnp"}
{"score":"80","reasoning":"Clear test name and structure with setup execution and teardown phases. Descriptive comments explain the issue and expected behavior. Meaningful variable names and test case descriptions aid comprehension. Minor deductions for dense comment block and reliance on external context like checkCounts method and domain knowledge of Hibernate implicit joins.","tokens":1955,"name":"78.jsnp"}
{"score":"70","reasoning":"Clear test intent but nested method calls and overly long fully qualified class name hinder readability. The deep nesting requires mental parsing. Extracting intermediate variables and using a constant for the class name would improve comprehension. Formatting attempts clarity but remains dense.","tokens":1338,"name":"165.jsnp"}
{"score":"88","reasoning":"Code shows excellent readability with descriptive naming and clear JavaDoc. Method name precisely indicates purpose. Anonymous inner class is concise and focused. While dependent on external context like base class and fNotifier field, it follows standard JUnit patterns. Slightly verbose syntax from pre-Java 8 style but remains easy to comprehend for developers familiar with testing frameworks.","tokens":1547,"name":"53.jsnp"}
{"score":"90","reasoning":"Clear method name and descriptive parameters. Well-named variables (eachClass, eachMethod, eachField) enhance readability. Good comment explains deterministic ordering requirement. Parallel structure for methods/fields makes logic easy to follow. Minor deductions for external dependencies (fClass, addToAnnotationLists) and verbose generic signature, but overall highly comprehensible.","tokens":1654,"name":"52.jsnp"}
{"score":"58","reasoning":"Variable naming is cryptic and inconsistent (child_1_1, child_2_1) with unclear patterns. String identifiers like achild1-1 are confusing. Save order differs from creation order without explanation. No comments clarify intent. While structure is logical, these issues significantly hinder comprehension. Method could be improved with clearer naming, comments, or helper methods.","tokens":1628,"name":"76.jsnp"}
{"score":"65","reasoning":"Descriptive name and comments explain HHH-1631 context well. However structure is monolithic with many similar test cases lacking clear grouping. Distinction between checkIterate and checkAll is unclear. Contains duplication and hardcoded test data. Requires external domain knowledge. Moderately readable but needs better organization.","tokens":2083,"name":"79.jsnp"}
{"score":"75","reasoning":"Clear test structure and descriptive naming show good intent but overly verbose boolean variables hinder readability. Hardcoded method name strings and imperative loop style could be improved with constants and functional approach. Assertion messages are helpful. Overall decent readability with room for conciseness improvements.","tokens":1891,"name":"161.jsnp"}
{"score":"30","reasoning":"Severe inconsistent indentation and confusing logic that contradicts its own comments make this code very hard to follow. Misleading debug messages and duplicated structure further hinder comprehension. Variable names are clear but cannot offset the fundamental readability problems.","tokens":3309,"name":"27.jsnp"}
{"score":"62","reasoning":"Poor variable naming (cidDetailID) is confusing and inconsistent. Complex ternary operators for null checks require careful mental parsing instead of using clearer Objects.equals() method. While it follows standard equals pattern, the implementation is unnecessarily verbose and cryptic, reducing immediate comprehension. Proper naming and modern Java utilities would significantly improve readability.","tokens":1400,"name":"70.jsnp"}
{"score":"72","reasoning":"The code demonstrates solid structure with clear method naming and logical flow. However, deep method chaining (e.g., getCollectionReferenceAliases().getCollectionColumnAliases().getSuffix()) and framework-specific type casting increase cognitive load. The many-to-many conditional block is well-isolated. While readable to ORM-experienced developers, the dense nested calls and required domain knowledge moderately impact general comprehension. Good indentation and consistent formatting partially offset these concerns.","tokens":1844,"name":"182.jsnp"}
{"score":"95","reasoning":"Code demonstrates excellent readability with clear naming consistent formatting and logical grouping. The repetitive registration pattern is explicit and easy to follow. Blank lines separate transaction factory types effectively. Intent is immediately obvious making it very accessible for developers familiar with the strategy pattern.","tokens":1694,"name":"171.jsnp"}
{"score":"72","reasoning":"Clear test structure with logical flow from setup through cleanup. Readability impacted by verbose anonymous inner class for doWork, inconsistent spacing, and lengthy annotation comment. SQL string concatenation with dialect quotes adds noise. Modern lambda syntax would improve clarity. Magic numbers and conditional dialect-based assertions create minor cognitive overhead. Understandable for Hibernate developers but could be more concise.","tokens":2279,"name":"69.jsnp"}
{"score":"30","reasoning":"Extremely poor variable naming with single letters b-g provides zero context. No comments explain the complex relationship breaking logic or deletion order. Method mixes concerns: breaks relationships, merges entities, then deletes them. Requires deep domain knowledge to understand purpose. While syntactically correct and following a consistent pattern, the code is opaque and maintenance would be very difficult.","tokens":1705,"name":"200.jsnp"}
{"score":"78","reasoning":"Code demonstrates clear intent with descriptive naming but lacks self-containment due to undefined fMax field. Anonymous inner class adds verbosity; lambda syntax would be cleaner. Uses outdated generic declaration style. Test flow is logical and assertion is clear, requiring moderate JUnit familiarity to comprehend.","tokens":1872,"name":"124.jsnp"}
{"score":"65","reasoning":"The method has readability issues due to inline comments breaking the if-condition flow, awkward line breaks, and convoluted nested logic. The exception message concatenation is poorly formatted. While the method name and parameter names are clear, the overall structure requires extra mental effort to understand the classification logic and edge cases.","tokens":2190,"name":"29.jsnp"}
{"score":"55","reasoning":"Code uses raw Iterator type requiring manual cast, inconsistent indentation creates visual noise, and verbose exception handling obscures test logic. Assertions inside loop with comments mix concerns. Manual resource management and magic strings reduce clarity. Test name and assertion messages are clear, but outdated patterns and formatting issues significantly hinder readability.","tokens":2106,"name":"137.jsnp"}
{"score":"68","reasoning":"Method tests two scenarios in one test making it overly long. Variable reuse like cache and cacheCfg reduces clarity. Property setup is verbose but straightforward. Assertions are clear but duplicated for entity and collection regions. Better separation into two tests and improved variable naming would enhance readability. Overall structure is logical with proper cleanup.","tokens":1495,"name":"130.jsnp"}
{"score":"65","reasoning":"Test method has clear JPA spec documentation and issue tracking. Variable names are adequate. Main readability issue is the overly complex chained assertion navigating bidirectional relationships. Test name is excessively long. Session management boilerplate is verbose but standard for Hibernate tests. Overall understandable for domain experts but challenging for newcomers due to complex navigation in assertion.","tokens":1754,"name":"134.jsnp"}
{"score":"35","reasoning":"Dense monolithic test method executes 20+ HQL queries without comments or assertions. Reusing results variable prevents tracking outcomes. Unclear what each query validates. SuppressWarnings indicates unused code issues. While setup/teardown is proper and method name is clear, lack of documentation and verification makes comprehension difficult. Should be split into focused tests with explanatory comments and result checks.","tokens":1903,"name":"83.jsnp"}
{"score":"65","reasoning":"Test method demonstrates JPA Criteria API correlated subquery pattern. Variable names are descriptive and structure is logical, but Criteria API verbosity and complex generic syntax reduce readability. Correlated subquery concept requires advanced JPA knowledge. Single comment helps but underlying SQL intent is obscured by API mechanics. Moderate comprehension difficulty for non-experts.","tokens":1476,"name":"163.jsnp"}
{"score":"30","reasoning":"Deep nesting with 5 levels of indentation makes logic flow hard to follow. Poor variable names like nod and comp reduce clarity. Complex split conditions with inline comments hinder readability. Redundant else if encloser \u003d\u003d null check. Method mixes two unrelated concerns: setting component instances and managing figure layers. Contains dead code and TODO indicating unresolved design issues. Static Model calls create hidden dependencies. Overall structure violates single responsibility principle and lacks clear separation of concerns.","tokens":2197,"name":"155.jsnp"}
{"score":"72","reasoning":"Clear variable names but repetitive ternary operators with verbose generics reduce readability. Three similar statements require careful comparison to spot differences. While the defensive copying pattern is understandable, the compact format is denser than if-else blocks. Consistent structure helps, but extracting a helper method would improve clarity and reduce duplication.","tokens":1552,"name":"196.jsnp"}
{"score":"78","reasoning":"Well-commented Hibernate test with clear intent and logical flow. Very long method name hampers readability. Domain-specific concepts require prior knowledge but comments explain key details effectively. Good setup-execute-verify-cleanup structure. Try-catch block clearly defines expected IllegalStateException. Readable for target audience despite inherent complexity.","tokens":2169,"name":"75.jsnp"}
{"score":"88","reasoning":"Code demonstrates excellent naming conventions with descriptive listener variables and follows a consistent pattern. Structure is logical with clear separation between initialization and registration. Minor readability deduction for the slightly verbose casting line retrieving EventListenerRegistry. Overall highly readable with predictable repetitive pattern that aids comprehension.","tokens":1549,"name":"139.jsnp"}
{"score":"78","reasoning":"The method has clear Javadoc and logical structure with descriptive variable names. Inline comments explain key decisions. However the for-each loop line is overly long and complex reducing scanability. The IdentityMap.concurrentEntries usage adds domain-specific complexity. The commented-out iter.remove line is slightly distracting. Overall well-structured for framework internals but could be more approachable.","tokens":1731,"name":"66.jsnp"}
{"score":"68","reasoning":"Test method is overly monolithic and repetitive, combining multiple scenarios into one long method. The verbose casting chain adds noise. While variable names are clear and the pattern is consistent, the lack of helper methods or comments explaining JPA-to-Hibernate cache mode mappings reduces readability. Splitting into focused test methods would significantly improve comprehension.","tokens":1752,"name":"162.jsnp"}
{"score":"75","reasoning":"The method uses a clear switch structure with helpful comments explaining each SQL state code. However it relies on magic numbers that require comments to understand, has multiple paths returning null which can be confusing, uses string literals with escaped quotes that reduce visual clarity, and silently catches NumberFormatException. The TODO comment indicates incomplete implementation. Overall the pattern is consistent and intent is clear but these issues reduce readability.","tokens":1425,"name":"22.jsnp"}
{"score":"68","reasoning":"Test method has clear structure but suffers from ambiguous intent. The final line calls getFlushMode() without using its return value, creating confusion about its purpose. Test name testImplicitJoining does not clearly describe the actual scenario being tested. While individual statements are readable, the overall test logic and expected outcome are not immediately apparent. The chained session creation is dense but acceptable. Lacks comments to clarify intent.","tokens":1235,"name":"128.jsnp"}
{"score":"85","reasoning":"Well documented with clear Javadoc explaining purpose parameters and exceptions. Method signature is descriptive and exception handling is appropriate. Logic is simple linear if-else chain easy to follow. TODO comment provides useful context about temporary nature. Minor readability issue uses Yoda notation null \u003d\u003d mode instead of conventional mode \u003d\u003d null. Overall structure is clean concise and highly comprehensible.","tokens":1214,"name":"32.jsnp"}
{"score":"78","reasoning":"Method is concise with clear purpose and simple linear flow. Parameter names are domain-standard but slightly abbreviated. Class names are overly verbose hurting quick comprehension. Minor formatting inconsistency with indentation. Overall structure follows clear strategy and builder patterns making it understandable for those familiar with ORM frameworks.","tokens":1172,"name":"143.jsnp"}
{"score":"55","reasoning":"Code lacks generics using raw types Set and HashSet. Returns null instead of empty set. Inconsistent indentation and formatting. No documentation comments. Uses static facade pattern making testing difficult. Parameter name parent is vague. However method structure is simple and facade method names are descriptive making basic comprehension possible. Overall poor modern Java practices reduce readability significantly.","tokens":1484,"name":"123.jsnp"}
{"score":"70","reasoning":"The code uses an anonymous inner class to run a test in a separate thread, which is verbose compared to modern lambda syntax. The comment explains the inlined logic, aiding comprehension. The try-finally block ensures proper cleanup. However, the variable name \u0027t\u0027 is terse and the outer class reference syntax is clunky. Overall, it\u0027s functional but shows outdated patterns that reduce readability.","tokens":1668,"name":"1.jsnp"}
{"score":"85","reasoning":"Clear Javadoc and formatting with each parameter on its own line. Good use of named constants for numeric values. Constructor delegation is a standard Java pattern. Significant deduction for boolean literals requiring inline comments for clarity instead of named constants. Despite this flaw, overall structure remains clean and comprehension is straightforward.","tokens":2852,"name":"4.jsnp"}
{"score":"70","reasoning":"Code follows Hibernate test patterns with descriptive naming and contextual annotations. Lacks inline comments explaining HHH-2045 and purpose of empty IN clause. Repetitive session management creates noise. Query syntax appears invalid which may confuse readers. Requires external knowledge for full comprehension despite clear structure.","tokens":1514,"name":"77.jsnp"}
{"score":"70","reasoning":"Code demonstrates pre-Java 5 style with raw types and Enumeration API. Indentation is inconsistent in the first if-block. Variable names are somewhat vague lists and abbreviated chlist. Javadoc effectively explains the caching strategy despite a typo. Logic is clear but requires careful reading due to interface matching. Comments are helpful but informal. Overall structure is sound but dated syntax and minor formatting issues reduce clarity.","tokens":2047,"name":"44.jsnp"}
{"score":"82","reasoning":"Well documented with clear Javadoc and descriptive variable names. Logical flow uses early returns effectively. Main readability issue is the long constructor call with unnamed boolean literals reducing clarity. Inconsistent logging style (tracef vs concatenation) is minor. The generic metadata handling is complex but appropriate for framework code. Overall good readability with room for minor improvements.","tokens":1725,"name":"84.jsnp"}
{"score":"60","reasoning":"Method mixes setup and test logic with heavy Hibernate-specific SQL syntax. Dialect-specific query construction reduces clarity. Inconsistent indentation and generic variable names like list hinder readability. While functional it requires deep framework knowledge to understand the test intent and TimesTen workaround. Structure is logical but could be cleaner with better separation of concerns.","tokens":3158,"name":"71.jsnp"}
{"score":"40","reasoning":"Code lacks generics making types unclear. Uses outdated Vector with unhelpful comment. Poor variable names like res cr aer reduce clarity. Redundant Object cr assignment. Inconsistent indentation. Verbose Iterator loop instead of for-each. No Javadoc. Static Model.getFacade() hides dependencies. Method mixes raw List return with Vector implementation. Overall structure is understandable but multiple readability issues hinder comprehension.","tokens":1579,"name":"120.jsnp"}
{"score":"95","reasoning":"Excellent readability with clear Javadoc, standard serialization method pattern, and consistent SerialUtilities calls. Descriptive field names and straightforward sequential structure make it easy to understand. Each call on separate lines enhances scanability. Follows Java conventions perfectly with no complexity or confusing elements.","tokens":1717,"name":"38.jsnp"}
{"score":"70","reasoning":"Test method with clear intent and logical flow. Heavy casting syntax reduces readability. Repetitive assertions are acceptable in test context but make it verbose. The getFlushMode side-effect calls are cryptic despite the comment. Requires deep framework knowledge. Overall structure is sound but implementation details hinder comprehension.","tokens":1772,"name":"127.jsnp"}
{"score":"48","reasoning":"Non-standard naming with underscores and abbreviations. Unused variable _saveIndex and unnecessary blocks add noise. Requires ANTLR domain knowledge. Inconsistent formatting. Switch structure clearly shows hex digit matching logic but overall readability is poor due to boilerplate and style issues typical of generated code.","tokens":1897,"name":"117.jsnp"}
{"score":"85","reasoning":"The method has a descriptive name and clear test purpose. Variable names are meaningful. The nested try-catch-finally structure, while functional, adds slight complexity. Using try-with-resources would improve modern readability. The cleanupData() call lacks immediate context. Overall, it\u0027s well-structured for Hibernate testing patterns and comprehensible to framework users.","tokens":1527,"name":"129.jsnp"}
{"score":"62","reasoning":"Code shows moderate readability issues from three-level nesting and parameter reassignment. Long method chains lack intermediate variables making logic harder to trace. Conditional structure is clear but the specific normalization sequence needs explanation. Extracting helper methods and avoiding parameter mutation would improve clarity. Functional but requires careful reading to understand all paths.","tokens":2119,"name":"30.jsnp"}
{"score":"58","reasoning":"Deep nesting (4 levels) and broad try-catch block hinder readability. Unconventional loop syntax (i !\u003d args.length) and multiple exit points add confusion. Dependencies on unseen instance variables (parserErrors, filter) and methods (copyArray) make comprehension difficult. Break statement effect is unclear. Variable names are decent but overall structure is complex.","tokens":1943,"name":"15.jsnp"}
{"score":"85","reasoning":"The method is straightforward with clear indentation and descriptive parameter names. Visual separators enhance readability. Minor issues include a long line that could be split, use of System.out instead of a logger, hardcoded formatting strings, and a method name that suggests a return value rather than printing output. Overall structure is simple and intent is immediately understandable.","tokens":1788,"name":"144.jsnp"}
{"score":"65","reasoning":"Code uses clear lazy initialization with descriptive naming. Main issues: raw type Vector without generics, repetitive addElement calls, legacy synchronized collection, missing static field declaration, and thread-safety concerns. Modern practices like parameterized List and static initialization would improve readability. Understandable but shows outdated patterns that hinder comprehension for contemporary developers.","tokens":1592,"name":"45.jsnp"}
{"score":"60","reasoning":"The code suffers from multiple negations, unsafe downcasting, verbose factory calls with null parameters, and a complex nested condition. The method handles multiple responsibilities without comments, making logic harder to follow. Variable names are clear but structure could be improved with helper methods or a builder pattern for better comprehension.","tokens":1828,"name":"109.jsnp"}
{"score":"65","reasoning":"Code has clear method signature and logical flow but suffers from raw types, side effects on instance fields, magic strings, and nested conditionals. Uses instance fields _scratchBindings and _strBuf for temporary operations which reduces clarity. Mixed responsibilities of evaluation, transformation and string building. Understandable but requires careful reading due to these anti-patterns.","tokens":1553,"name":"8.jsnp"}
{"score":"82","reasoning":"Well-structured test with excellent comments explaining the bug scenario and clear two-phase transaction separation. The assertion message provides meaningful context. Main readability issue is the non-descriptive variable name \u0027it\u0027. Requires Hibernate domain knowledge but that\u0027s expected for this specialized test. Overall easy to follow despite testing complex caching behavior.","tokens":1768,"name":"179.jsnp"}
{"score":"48","reasoning":"The code suffers from a confusing while-loop structure with redundant null checks and manual resource management that risks leaks, making it non-idiomatic and harder to trust. Terse variable names like f, fr, mAry and inefficient string concatenation further reduce clarity. While the core parsing logic is eventually understandable, these anti-patterns demand extra scrutiny and indicate potential bugs.","tokens":2719,"name":"48.jsnp"}
{"score":"72","reasoning":"Method shows clear naming and structure but suffers from readability issues due to recursive calls to overloaded methods not shown in snippet. Uses outdated isInstance syntax instead of instanceof. Mixes entity key resolution with state hydration which could be separated. Requires external context for full comprehension despite decent local clarity.","tokens":1814,"name":"197.jsnp"}
{"score":"90","reasoning":"The code demonstrates excellent readability with clear Javadoc, standard equals method structure, and logical flow. Variable names are meaningful, indentation is proper, and null handling is explicit. Minor improvements could include more descriptive return documentation and using Objects.equals() for conciseness, but overall it\u0027s highly comprehensible and follows Java conventions perfectly.","tokens":2329,"name":"40.jsnp"}
{"score":"40","reasoning":"Code suffers from critical bugs using \u003d\u003d for string comparison instead of equals(), poor variable naming (mee, tr, eName), magic strings, code duplication, inconsistent brace style, and repeated casting. TODO comment indicates uncertainty. Block comment is helpful but overall comprehension is hindered by these issues. Lacks null safety checks and mixes UI threading with business logic.","tokens":2180,"name":"154.jsnp"}
{"score":"75","reasoning":"Method has clear naming and logical flow. Uses descriptive variables and early return effectively. However it suffers from verbosity with redundant boolean assignments and repetitive conditional blocks. Style inconsistencies in spacing and could leverage modern Java features like diamond operator. Overall logic is easy to follow but could be more concise and DRY. Good readability but not exemplary.","tokens":1721,"name":"195.jsnp"}
{"score":"55","reasoning":"Inconsistent indentation and commented-out code reduce readability. Deep nesting in tooltip logic is hard to follow. Repeated getJComponent() calls are verbose. Variable naming is inconsistent. However method structure is logical and purpose is clear. Needs refactoring for better maintainability.","tokens":2506,"name":"122.jsnp"}
{"score":"40","reasoning":"Extremely long entity names severely reduce readability. Non-standard formatting with misaligned parentheses creates visual confusion. Repetitive structure lacks abstraction. While the pattern is consistent and intent is discernible, these issues demand high cognitive effort. Missing context for ID variables further hampers comprehension.","tokens":2100,"name":"185.jsnp"}
{"score":"55","reasoning":"Code has excessive tilde separators creating visual noise. A comment contradicts the actual assertion causing confusion. Redundant session casting adds clutter. Despite these issues the repetitive test pattern clearly shows incrementing behavior making core logic understandable but requires effort to parse.","tokens":2289,"name":"17.jsnp"}
{"score":"62","reasoning":"Confusing method name collision where getSqlTypeCode calls getSqlTypeCode makes logic hard to follow. Broad Exception catching is problematic. String concatenation is awkwardly formatted. Grammatical error in message. Despite clear variable names and good error context, the naming issue severely impacts comprehension.","tokens":2455,"name":"37.jsnp"}
{"score":"78","reasoning":"The code uses clear method chaining with StringBuilder and descriptive field names making intent obvious. Each field is on its own line which aids readability but creates verbosity. The pattern is consistent and easy to follow for any Java developer. However it could be more concise using String.format or ToStringBuilder. No null handling is shown. Overall a solid traditional implementation with minor readability friction from length.","tokens":2256,"name":"63.jsnp"}
{"score":"75","reasoning":"Clear intent with descriptive constants and helpful error messages. The lengthy if-else chain reduces readability versus a switch statement. Minor issues include duplicated validation logic, a leftover comment, and inconsistent string quote usage. Consistent patterns across branches make it easy to follow overall.","tokens":2750,"name":"108.jsnp"}
{"score":"90","reasoning":"The method uses a straightforward if-else chain to handle different Test types explicitly, which is easy to follow. Logic is clear with recursive processing for TestSuite and TestDecorator. Variable names are generally descriptive and the fallback case includes a helpful comment. While the instanceof checks are verbose, they enhance readability in this factory context. Minor improvements could rename the \u0027made\u0027 variable, but overall structure and comprehension are excellent.","tokens":2362,"name":"54.jsnp"}
