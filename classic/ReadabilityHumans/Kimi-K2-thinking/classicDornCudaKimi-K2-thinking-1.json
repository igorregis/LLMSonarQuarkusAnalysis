{"score":"72","reasoning":"Code shows consistent CUDA kernel launch patterns with proper error checking. Function names are descriptive but error messages are inconsistent. Good documentation exists for texture binding but missing for other functions. Magic numbers like +2 in shared memory calculation and 16 in alignment lack explanation. Repetitive error handling could be refactored. Overall readable for CUDA developers but needs improvement in documentation consistency and clarity of calculations.","tokens":1990,"name":"47.jsnp"}
{"score":"35","reasoning":"Code is incomplete missing kernel launch. Unused variable idnx creates confusion. Type mismatch between double and cudafloat. No comments explaining parameters or algorithm. Hardcoded block size without justification. Poor parallel design with each thread processing entire row. No bounds checking. While structure is simple critical issues severely hinder comprehension.","tokens":1756,"name":"106.jsnp"}
{"score":"58","reasoning":"Code shows basic CUDA launch pattern with grid calculation but suffers from poor variable naming (B,G), a critical typo in d_jont_hist, commented-out code without context, and lacks explanatory comments. While CUDA_SAFE_CALL indicates error awareness and d_ prefix convention is good, the snippet is incomplete missing function signature and variable declarations. Overall comprehension is hindered by these issues requiring extra effort to understand.","tokens":1519,"name":"103.jsnp"}
{"score":"70","reasoning":"Code demonstrates CUDA setup for kernel launch with repetitive texture binding calls using overly verbose variable names mixed with terse ones like B1 G1. The macro CUDA_SAFE_CALL hides control flow but provides consistent error handling. Dense single-line statements reduce readability. Grid calculation is clear but split awkwardly. Overall understandable to CUDA developers but challenging for newcomers due to inconsistent naming and lack of comments.","tokens":1617,"name":"67.jsnp"}
{"score":"88","reasoning":"Excellent descriptive naming makes the rendering pipeline clear. Function is concise with logical flow: prepare resources, render, cleanup. Single-line conditionals are slightly dense but acceptable. Self-documenting code reduces need for comments. Minor ambiguity about cleanup timing but overall highly readable.","tokens":1492,"name":"57.jsnp"}
{"score":"45","reasoning":"Code shows moderate readability. Initial comments help but complex nested conditions, magic numbers like c_Binning offsets, and cryptic texture indexing with c_Binning*c_Binning reduce clarity. Deep nesting of loops and if statements makes flow hard to follow. NaN checks are obscure. Variable reuse and lack of comments on mathematical operations hinder understanding. Overall structure is logical but needs refactoring for better comprehension.","tokens":2053,"name":"81.jsnp"}
{"score":"45","reasoning":"Poor readability due to cryptic abbreviations idnx uiWA etc. Misspelling Euclidean indicates carelessness. Complex indexing logic is hard to follow. Comments help but don\u0027t offset naming issues. Kernel launch structure is clear. Requires undue effort to comprehend.","tokens":1745,"name":"101.jsnp"}
{"score":"45","reasoning":"Code fragment lacks function signature and context. Poor variable naming with verbose identifiers and double pointer indirection reduces clarity. Magic numbers and inconsistent indentation hinder readability. Minimal comments explain what but not why. Heavy reliance on external macros and CUDA-specific constructs requires deep domain knowledge. Texture binding uses deprecated style. Grid calculation is clear but overall structure is fragmented and hard to follow without surrounding code.","tokens":1965,"name":"89.jsnp"}
{"score":"35","reasoning":"The code suffers from poor readability due to an extremely long unbroken function signature, inconsistent naming conventions (cryptic idnx/idny, Hungarian notation), lack of comments, and inconsistent spacing. The incomplete snippet makes full comprehension impossible. While the thread index calculation is standard, overall structure hinders quick understanding and maintainability.","tokens":1678,"name":"58.jsnp"}
{"score":"35","reasoning":"Code exhibits poor readability due to cryptic variable names like Tx_x and xFirst lacking semantic meaning. Repetitive pattern without comments makes understanding purpose difficult. No spacing between logical blocks. While consistent formatting and vector operations are positive, the code requires domain knowledge and significant effort to comprehend. Texture fetch suggests GPU optimization context that is not documented. Overall maintainability is low.","tokens":1940,"name":"50.jsnp"}
{"score":"10","reasoning":"Code snippet is part of a macro definition with line continuations. Features extremely long parameter lists with cryptic single-letter and numbered variable names. Uses preprocessor token pasting for dynamic function names. Lacks comments and context. First line is incomplete. Formatting is inconsistent. Clearly performance-optimized cryptographic GPU code that sacrifices all readability principles. Nearly impossible to comprehend without full macro context and domain expertise.","tokens":1871,"name":"98.jsnp"}
{"score":"35","reasoning":"Heavily macro-dependent code with cryptic names iw, M, outn, nSelAct and undefined CUDA_SIGMOID, CUDA_VALUE, BIAS. Magic number 32 unexplained. Complex indexing using NEURON, PATTERN, NUM_NEURONS lacks context. No comments for neural network operations. Warp reduction pattern is correct but helper functions are invisible. Logical structure exists but readability is poor due to opaque naming and missing definitions.","tokens":1980,"name":"61.jsnp"}
{"score":"25","reasoning":"Excessive parameter lists, cryptic variable names (b0-b15), macro-style line continuations, overly verbose constants, poor indentation, and dense domain-specific logic without comments make this extremely difficult to comprehend. The code structure is logical but implementation choices severely hinder readability.","tokens":2262,"name":"93.jsnp"}
{"score":"68","reasoning":"Stray closing bracket and inconsistent indentation. Missing definitions for Ray float3x4 and helper functions. Minimal comments. intersectBox contains dense nested minmax operations reducing clarity. Positive aspects include descriptive naming and provided algorithm reference. Moderately readable for graphics experts but less so for general audience.","tokens":2175,"name":"90.jsnp"}
{"score":"65","reasoning":"Code shows convolution pipeline with clear steps but suffers from inconsistent indentation making block structure hard to follow. Commented debug statements clutter the view. Variable names are decent but parameter lists are long and dense. cudaThreadSynchronize calls are misaligned. Overall logic is understandable for CUDA developers but formatting issues significantly hinder readability. Needs cleanup and consistent style.","tokens":2453,"name":"20.jsnp"}
{"score":"45","reasoning":"Parallel min reduction with severe repetitive structure that should be a loop. Hardcoded magic numbers and offsets reduce maintainability. Dense chained assignment hinders readability. EMUSYNC macro lacks clarity. No comments explain the algorithm. While functional for CUDA developers, it violates DRY principle making it error-prone. Volatile usage is appropriate but overall verbosity obscures the simple reduction logic.","tokens":2085,"name":"21.jsnp"}
{"score":"88","reasoning":"Simple list of descriptive strings with consistent formatting. Each element on its own line with trailing commas aids readability. Names are clear and follow logical grouping. Minor deduction for incomplete snippet missing opening bracket and lack of explanatory comment. Overall structure is clean and immediately understandable.","tokens":921,"name":"96.jsnp"}
{"score":"35","reasoning":"Heavy use of domain-specific abbreviations (mapQ, de, sa, mm, fnr) without context or type information. While some names are clear (n_seq_per_block), most require deep domain knowledge. Lack of comments and surrounding code makes purpose unclear. Consistent snake_case is a minor positive.","tokens":1257,"name":"35.jsnp"}
{"score":"40","reasoning":"Code snippet lacks context starting with closing braces. Heavy duplication in switch statement with magic block sizes. No comments explaining purpose or Inf/NaN handling logic. Variable naming is unclear. Missing default case. While operations are simple, the repetitive structure and lack of documentation make it difficult to understand intent and maintain. Could be refactored with template metaprogramming.","tokens":3149,"name":"36.jsnp"}
{"score":"45","reasoning":"Code demonstrates basic CUDA memory operations but suffers from significant readability issues. Unused headers and commented code create confusion. Missing error checks for cudaMemcpy, resource leaks (backPtr and devPtr not freed), incomplete cleanup on failure paths, and inconsistent formatting hinder comprehension. Magic numbers lack explanation. The incomplete structure missing return statement and closing brace further reduces clarity. Only understandable to experienced C/CUDA developers.","tokens":2906,"name":"31.jsnp"}
{"score":"25","reasoning":"Poor indentation and formatting with inconsistent spacing. Variable names are cryptic (po, n_bin, echan, bchan). Lacks meaningful comments and contains clutter from commented-out code. Nested loops without braces reduce clarity. Function is incomplete, cutting off mid-loop. Uses static variables without clear justification. Memory allocation lacks error checking. Parameter outfile is unused. Magic numbers appear without explanation. Overall structure makes logic difficult to follow.","tokens":3098,"name":"112.jsnp"}
{"score":"50","reasoning":"Code mixes C and C++ styles poorly. Constructor signature missing. Manual memory management with inconsistent free functions and missing null checks. Minimal comments. Uses printf instead of iostreams. Unused variables. Potential memory safety issues. Variable names are somewhat descriptive but inconsistent. Overall hard to maintain and prone to bugs.","tokens":3037,"name":"73.jsnp"}
{"score":"65","reasoning":"Code shows inconsistent spacing and indentation. The verbose logging line is overly dense and complex with nested parentheses. Variable names are clear and logic is simple. Comment is helpful. Overall decent but stylistic issues hinder quick comprehension.","tokens":1372,"name":"65.jsnp"}
{"score":"68","reasoning":"Clear variable names and logical CUDA memory transfer structure. Good error handling for allocation but missing for cudaMemcpy calls. Inconsistent brace style and redundant casts reduce readability. Missing device memory cleanup and context about variable declarations. Commented code sections are helpful but overall lacks high-level documentation. Initialization pattern is unclear without explanation.","tokens":1772,"name":"39.jsnp"}
{"score":"70","reasoning":"Code structure is clear with descriptive naming and concise functions. Lacks thread safety for static members missing error handling for cuRAND calls and ambiguous Fill() method. Redundant atexit calls and absent class definition reduce comprehension. Good basic design but needs improvements for robustness and clarity.","tokens":1558,"name":"116.jsnp"}
{"score":"65","reasoning":"CUDA reduction code with repetitive structure. Uses classic tree reduction pattern but lacks abstraction. The switch to volatile pointers for warp-synchronous execution is not explained, making it cryptic for beginners. No comments, missing context due to leading brace. Variable names are clear and indentation is consistent. Understandable for experienced CUDA developers but opaque for others. Repetitive conditionals could be templated or looped.","tokens":2123,"name":"99.jsnp"}
{"score":"72","reasoning":"Code demonstrates consistent error handling patterns and clear function naming. Variable names are meaningful. However snippet is incomplete with inconsistent spacing alignment and abrupt startend. The recv loop pointer arithmetic requires careful reading. Overall structure is sound but formatting issues and lack of comments reduce immediate comprehension. Suitable for experienced C developers.","tokens":1618,"name":"102.jsnp"}
{"score":"55","reasoning":"The code snippet lacks context with undefined globals inArgs and outArgs. The multi line comment explains threading rationale well despite a typo. Function logic is simple but incomplete with no error handling for semaphore operations. Formatting is inconsistent. Overall comprehension is hindered by missing declarations and abrupt ending, though the core intent is discernible through comments.","tokens":2037,"name":"60.jsnp"}
{"score":"65","reasoning":"Code shows moderate readability with clear variable names and logical structure. However inconsistent indentation missing closing braces and truncated return statement hinder comprehension. Uses deprecated cutilSafeCall macro and unclear pointer arithmetic with magic number 2 for kernel separation. Comments are helpful but FIXME distracts. Overall understandable for CUDA developers but needs formatting fixes and completion to be truly readable.","tokens":2033,"name":"68.jsnp"}
{"score":"60","reasoning":"The code has several readability issues. The calculation of largest_tmin and smallest_tmax uses redundant comparisons making it non-idiomatic and confusing. The kernel function contains unnecessary variable copies that add noise. Inconsistent naming conventions and a generic function name mul reduce clarity. The incomplete snippet also hampers full comprehension. These factors make the code require careful study to understand.","tokens":2615,"name":"28.jsnp"}
{"score":"35","reasoning":"Code suffers from severe formatting inconsistencies, extremely dense nested ternary operators in exponential crossover case, and reliance on undefined macros. Variable names are cryptic and comments are minimal. The snippet is incomplete, starting and ending abruptly, making full comprehension impossible without broader context. Overall structure is poor with improper indentation and spacing.","tokens":2167,"name":"46.jsnp"}
{"score":"30","reasoning":"Excessive macros with commented alternatives create confusion. Undefined macros KERNEL HMATRIX CUDA_VALUE obscure intent. Variables x y tx lack descriptive names. Complex shared memory loading with manual bounds checks and double-loading pattern is difficult to follow. No comments explain the tiled algorithm. While functional the heavy obfuscation makes comprehension very difficult.","tokens":2302,"name":"7.jsnp"}
{"score":"50","reasoning":"Code shows inconsistent formatting with semicolon-separated statements and misaligned indentation. Variable names like B1/G1 are non-descriptive. Comments are duplicated incorrectly. Matrix conversion logic is dense without helper functions. Memory management is manual and error-prone. Kernel launch parameters use undefined constants. Overall structure lacks clear separation of concerns making maintenance difficult.","tokens":2457,"name":"23.jsnp"}
{"score":"35","reasoning":"Code suffers from poor readability due to inconsistent formatting, unused macros, commented includes adding clutter, C-style memory management without error checking, magic number 12, hardcoded matrix element copying, poor variable naming, and lack of documentation. Mixed C/C++ style and missing const correctness further reduce clarity. Logical structure is present but implementation is error-prone and difficult to maintain.","tokens":2668,"name":"100.jsnp"}
{"score":"60","reasoning":"Variable names are descriptive with clear CUDA memory prefixes (g_, s_). Core algorithm is understandable for imaging domain. However, severe indentation inconsistencies and incomplete context make control flow difficult to follow. Commented-out code adds clutter. Block structure is unclear without seeing opening braces. Formatting issues significantly impact readability despite clear intent.","tokens":1269,"name":"12.jsnp"}
{"score":"35","reasoning":"Poor variable naming (lg, lgn, i) lacks clarity. No comments explain complex bit manipulation reduction pattern or pointer arithmetic. Magic numbers and unexplained +1 offset create confusion. Incomplete code block and inconsistent __syncthreads() usage. Algorithmic intent is obscured despite recognizable parallel reduction structure. Requires deep CUDA and domain knowledge to comprehend.","tokens":1989,"name":"18.jsnp"}
{"score":"65","reasoning":"Code relies on undefined macros IMUL BETTER_THAN MAXIMIZE and function cropPosition requiring external context. Magic numbers -0.1f and 0.2f lack explanation. Complex 2D grid indexing scheme. sa_selection kernel missing closing brace. Descriptive variable names and clear separation of concerns partially offset these issues. Moderately readable for experienced CUDA developers but challenging for others.","tokens":2476,"name":"0.jsnp"}
{"score":"15","reasoning":"Extremely poor readability due to macro concatenation (##), functions with 20+ cryptic parameters (b0-b15, p0-p15), meaningless variable names (a,b,c,d), no comments, and line continuations. Requires deep domain knowledge to comprehend. Represents anti-patterns in clean code.","tokens":1383,"name":"92.jsnp"}
{"score":"68","reasoning":"Code shows logical structure with clear CUDA conventions (_d/_h suffixes) and error handling via CUDA_SAFE_CALL. However readability suffers from heavy reliance on externally defined symbols textures and block sizes without context. Minimal comments mixed indentation and use of deprecated cudaThreadSynchronize() reduce comprehension. High parameter count and domain-specific terminology require specialized knowledge.","tokens":2688,"name":"64.jsnp"}
{"score":"38","reasoning":"Code uses non-standard IMUL macros and template metaprogramming which adds complexity. Inconsistent naming conventions mix cryptic abbreviations with clear names. Heavy reliance on external files without context. Preprocessor directives split logic flow making comprehension difficult. Unused parameters and incomplete snippet further reduce readability. Comments are minimal and sometimes misleading. Overall structure follows CUDA patterns but implementation choices significantly hinder understanding.","tokens":2006,"name":"42.jsnp"}
{"score":"80","reasoning":"The code is straightforward with clear variable names and logical structure. Comments adequately explain function purposes. However, printf statements use excessive hardcoded tabs for alignment making them brittle to maintain. The separator line is crude. Overall easy to comprehend but minor formatting issues prevent higher score.","tokens":1448,"name":"107.jsnp"}
{"score":"15","reasoning":"Code exhibits severe readability issues. Macros SH and SVW are misused for array declarations instead of indexing, causing confusion. Inconsistent index transposition between active and commented versions creates uncertainty. Cryptic naming and lack of documentation make intent unclear. The pattern suggests experimentation without cleanup, severely hindering comprehension.","tokens":1454,"name":"11.jsnp"}
{"score":"32","reasoning":"Poor readability due to empty if block, excessive 18 parameters with cryptic names b0 to b15, inconsistent naming conventions, and unnecessary line continuation characters. The code structure is confusing and lacks clarity despite simple underlying logic. Fragment context missing.","tokens":1808,"name":"55.jsnp"}
{"score":"48","reasoning":"Poor variable naming (p, i, j) and cryptic struct field access. Redundant comment for pointer increment. Heavy use of magic numbers in array indexing and memcpy parameters. Complex CUDA memcpy call lacks clarity on purpose of parameters. Missing context from surrounding loops. Experienced C/CUDA programmers can infer intent but code is not self-documenting.","tokens":1539,"name":"85.jsnp"}
{"score":"48","reasoning":"Long parameter lists with cryptic names J and I lack clarity. No comments explaining logic. Preprocessor directives disrupt flow. Nested conditions add complexity. Second kernel is incomplete. Inconsistent naming with W B A suffixes. Poor abstraction and missing documentation make comprehension difficult without deep context.","tokens":1992,"name":"3.jsnp"}
{"score":"60","reasoning":"Code suffers from inconsistent indentation mixing tabs and spaces unclear variable names like pixelNumber and index magic constant BLOCK undefined in snippet commented-out code reduces clarity and unnecessary return statement. While brevity and some comments help overall structure requires domain knowledge of CUDA and backprojection algorithms making it moderately difficult to comprehend for newcomers.","tokens":1982,"name":"104.jsnp"}
{"score":"60","reasoning":"Short CUDA code fragment with standard kernel launch and synchronization pattern. Commented-out code is distracting and lacks explanation. Variable names like G1, B1 are cryptic. Missing context due to closing brace suggests incomplete snippet. While core operations are clear to CUDA developers, dead code and lack of documentation reduce overall readability. Macro definition not visible in snippet.","tokens":1562,"name":"72.jsnp"}
{"score":"65","reasoning":"Code shows CUDA reduction pattern but lacks context being a snippet. Heavy template usage and repetitive switch cases hurt readability. Magic number 32 appears without explanation. Conditional compilation for FERMI architecture adds complexity. No comments explaining warp-level synchronization or reduction strategy. Function names are descriptive but overall structure requires deep CUDA knowledge to understand quickly.","tokens":1633,"name":"51.jsnp"}
{"score":"35","reasoning":"The code suffers from dense bit manipulation without abstraction, cryptic variable names, unexplained magic numbers, and a goto statement that disrupts flow control. Comments are sometimes defensive rather than explanatory. Missing context makes logic hard to follow. While functional and performance-oriented, it requires deep domain knowledge to comprehend, making maintenance difficult.","tokens":1804,"name":"19.jsnp"}
{"score":"45","reasoning":"Code snippet lacks context showing loop or function start. Variable names t tstep pos step are cryptic and non-descriptive. No comments explain purpose of __syncthreads barrier or increment logic. While structure is simple and follows common CUDA patterns experienced developers may recognize the indentation appears inconsistent. Overall comprehension requires significant inference about intent and domain meaning.","tokens":1062,"name":"62.jsnp"}
{"score":"65","reasoning":"Code has inconsistent formatting with mixed spacing and casting. Variable naming is ambiguous: htod, dtoh, dtod, wc are unclear. Uses outdated Hungarian notation iRetVal. Missing opening brace suggests incomplete snippet. Comment blocks are verbose. Logical structure but needs modernization for clarity.","tokens":2063,"name":"5.jsnp"}
{"score":"35","reasoning":"Poor readability due to missing context macro definitions IMUL BETTER_THAN and undeclared s_addends t_texFitnesses. Critical __syncthreads() commented out causing race conditions. Parameter g_localBestIDs documented but unused. Complex toroidal ring indexing is convoluted with magic numbers. Despite Doxygen comments and memory prefixes the code has serious documentation mismatches and bugs requiring deep CUDA knowledge.","tokens":2654,"name":"26.jsnp"}
{"score":"48","reasoning":"MAX macro uses unsafe ternary operator without parameter parentheses risking side effects. Includes deprecated CUDA headers cutil_inline.h and custom _tt_common.h with reserved naming. Commented sys/time.h indicates unmaintained legacy code. No documentation or comments. Lacks modern C++ practices and clarity.","tokens":1962,"name":"88.jsnp"}
{"score":"35","reasoning":"Code uses cryptic abbreviated variable names like regH0 regE0 regF that lack semantic meaning. Comments are minimal inconsistent and use different terminology than variables. Operations are domain-specific sub_sat cudaGapOE requiring deep knowledge of CUDA and bioinformatics algorithms. Logic density is high with no clear separation of concerns. Understanding requires expertise in vectorized dynamic programming kernels.","tokens":1508,"name":"97.jsnp"}
{"score":"45","reasoning":"Code uses cryptic variable names p101 w010 etc requiring pattern decoding. Highly repetitive weight calculations and manual 3D indexing lack abstraction. No comments explain trilinear interpolation logic. Dense formatting hinders scanning. While consistent pattern aids experts, poor naming and verbosity create significant comprehension barrier for maintainability.","tokens":2277,"name":"82.jsnp"}
{"score":"35","reasoning":"Code shows inconsistent indentation and cryptic variable names like idnx/idny. Lacks comments explaining kernel purpose. Most critically, the function is incomplete, ending after variable declarations, preventing full comprehension. License header is verbose. While standard CUDA patterns are recognizable, overall readability is severely hampered by incompleteness and formatting issues.","tokens":1946,"name":"111.jsnp"}
{"score":"25","reasoning":"Heavy macro usage with backslash continuations and name concatenation. Excessive scalar variables p0-p15 and b0-b15 instead of arrays create extreme verbosity. Functions have 20+ parameters reducing clarity. Magic numbers lack context. No comments. Mixed naming conventions. Helper functions are opaque. Structure indicates performance-focused auto-generated code with poor human readability.","tokens":2130,"name":"24.jsnp"}
{"score":"50","reasoning":"Poor variable naming h_o h_h ppc lacks clarity. No bounds checking for bins/channels division. Magic number ppc/2 appears without clear context. Simple loop structure is readable but cryptic names require extra effort to understand. Comment helps but insufficient. Potential integer division issues.","tokens":1478,"name":"119.jsnp"}
{"score":"72","reasoning":"Good variable naming and helpful comments for CUDA kernel. However, snippet is incomplete with undefined MAX_STEPS macro, unused parameters, and missing function context. First part lacks signature and variable definitions. Structure is clear but needs completeness and better documentation for full comprehension.","tokens":2521,"name":"14.jsnp"}
{"score":"65","reasoning":"The code performs 3D convolution on gradient data using CUDA. While the core logic is clear, readability suffers from cryptic 3D-to-1D index calculations, reliance on unexplained global constants, and absence of comments. Variable names are partially descriptive but the texture memory usage and bounds checking logic require domain knowledge. The algorithm structure is sound but not self-documenting, making it challenging for newcomers to grasp quickly.","tokens":1830,"name":"9.jsnp"}
{"score":"50","reasoning":"Code shows inconsistent formatting with mixed indentation and statements on same lines. Variable names like t_m_a_h are cryptic. Contains a bug copying t_m_b_h to t_m_c symbol. Magic numbers 65335 and 65535 lack explanation. Comments have typos and minimal detail. Redundant memSize calculation. Grid dimension logic is convoluted. Overall structure is understandable for CUDA developers but maintenance is difficult due to these issues.","tokens":2407,"name":"115.jsnp"}
{"score":"20","reasoning":"Code suffers from extreme parameter count 50+ cryptic variables p0-p47 b0-b15 heavy macro usage with token pasting and line continuations. No comments descriptive names or clear logic flow. Repeated macro calls indicate complex code generation. While structurally consistent the code is nearly write-only requiring deep CUDA and cryptography knowledge to comprehend.","tokens":1904,"name":"16.jsnp"}
{"score":"75","reasoning":"Good structure and comments make the ray-box intersection logic clear. Variable names are mostly descriptive. However, the incomplete function hinders full comprehension. The final lines contain a probable bug (duplicate tmin.x and tmax.x parameters) causing confusion. Minor issues include single-letter struct members (o, d) and unclear suffix _bk. Overall decent but flawed.","tokens":3014,"name":"13.jsnp"}
{"score":"65","reasoning":"Code is concise but suffers from an unused BLOCK macro causing confusion. The single dense line with inline size calculation reduces readability. Parameter naming is clear but lack of error checking and comments makes comprehension harder. The void cast is necessary but adds visual noise. Overall functional but not easily scannable.","tokens":1947,"name":"105.jsnp"}
{"score":"35","reasoning":"Code suffers from opaque macro calls without definitions, misleading comment stating copy to host while actual code copies to device constant memory, unused threadId parameter, and suspicious size calculation MAX_CHARSET_LENGTH*charsetLength. Heavy reliance on external symbols and constants reduces comprehension. Function is short but requires extensive context to understand correctly.","tokens":1488,"name":"43.jsnp"}
{"score":"90","reasoning":"Functions and parameters are clearly named. Comments effectively document purpose. Logic is simple and linear with explicit error handling. Compact and consistent style. Minor deductions for missing const-correctness and generic error messages, but overall highly readable and easy to understand for C developers.","tokens":2625,"name":"41.jsnp"}
{"score":"35","reasoning":"Code suffers from heavy macro dependency (NUM_NEURONS, NEURON, OUTPUT_NEURON, KERNEL) without definitions, making logic opaque. Complex shared memory pointer arithmetic lacks documentation. Variable names like rmsF, bRMS, lg are cryptic. Abrupt ending prevents full comprehension. No comments explain intent or memory layout. Thread indexing scheme is unclear without context. While shared memory usage shows optimization intent, overall structure requires extensive external knowledge, severely hindering readability.","tokens":2034,"name":"87.jsnp"}
{"score":"65","reasoning":"Code shows mixed readability. Positive aspects include clear function naming, consistent indentation, and some descriptive variables. However, cryptic abbreviations like htod, dtoh, dtod require domain knowledge. Inconsistent variable initialization patterns and reliance on external enums and macros reduce clarity. The snippet is incomplete which limits full assessment. Overall structure is logical but needs better naming and completeness for optimal readability.","tokens":1615,"name":"74.jsnp"}
{"score":"48","reasoning":"Mixed variable naming: clear terms like proportionRandomValuesUsed alongside cryptic single-letter variables w,b,h,v,a,I,J. Dense ternary operators and pointer arithmetic hinder comprehension. Conditional kernel selection is logical but potential misnaming of ComputeStatusVisibleUnitsSmallRBM in hidden unit path creates confusion. ContrastiveDivergence is overly compact. Lacks comments explaining RBM logic and CUDA optimization choices.","tokens":2174,"name":"33.jsnp"}
{"score":"35","reasoning":"Extremely long single-line parameter list severely harms readability. Poor naming conventions with inconsistent abbreviations like rmsF and bRMS plus non-descriptive single-letter variable r. No comments explaining purpose or parameters. Shared memory loading without visible synchronization suggests incomplete code. While namespace usage is good, overall structure is poorly formatted and difficult to comprehend.","tokens":2193,"name":"6.jsnp"}
{"score":"88","reasoning":"Code is concise and well-formatted with clear const-correctness. Function names are descriptive but grammatically awkward, slightly hindering immediate comprehension. Assert statement effectively documents preconditions. Overall structure is simple and easy to follow.","tokens":1673,"name":"91.jsnp"}
{"score":"58","reasoning":"The code has a descriptive function name but suffers from a long parameter list with pointer-to-pointer types heavy reliance on external symbols and textures minimal comments inconsistent indentation and magic constants like Block_reg_getVoxelBasedNMIGradientUsingPW. While the logical flow is clear for CUDA developers the lack of context and documentation makes it difficult for newcomers to comprehend.","tokens":2920,"name":"34.jsnp"}
{"score":"72","reasoning":"Code has clear structure with section comments and consistent error handling via CUDA_SAFE_CALL. However, extremely long variable names reduce readability, CUDA-specific syntax like triple angle brackets and texture binding with magic number 0 require domain knowledge. Mixed naming conventions from verbose to single-letter variables and pointer-to-pointer dereferencing add cognitive load. Overall moderately readable for CUDA developers but challenging for general audience.","tokens":2280,"name":"25.jsnp"}
{"score":"50","reasoning":"Code uses cryptic abbreviated variable names like regP regT requiring domain knowledge to decipher. Comments are minimal and only state obvious operations not the algorithmic intent. High repetition of similar logic for vector components w x y z reduces clarity despite being performance-motivated. Overall structure is consistent but demands significant effort to comprehend without context. CUDA-specific operations and incomplete snippet further hinder readability.","tokens":2983,"name":"113.jsnp"}
{"score":"50","reasoning":"Code shows poor readability due to reversed gridblock variable naming B1 for grid G1 for block causing major confusion. Excessive long similar variable names like Block_reg_convertNMIGradientFromVoxelToRealSpace make it hard to distinguish. Repetitive boilerplate without abstraction. Uses deprecated cudaThreadSynchronize and legacy texture binding. Inconsistent function signatures and missing context. Debug prints are helpful but conditionally compiled. Overall structure is understandable but requires significant mental effort to parse correctly.","tokens":2272,"name":"110.jsnp"}
{"score":"60","reasoning":"The code demonstrates CUDA kernel launch with synchronization and conditional debug output. Readability is hampered by an excessively long kernel name, dense printf formatting, and lack of comments. While error checking is present via CUDA_SAFE_CALL, the deprecated cudaThreadSynchronize and reliance on preprocessor directives add complexity. The single-line format without whitespace separation makes parsing difficult for maintainers.","tokens":1706,"name":"56.jsnp"}
{"score":"50","reasoning":"Code uses outdated C-style practices in C++ including manual memory management with free, raw pointers, C-style casts, and printf. Inconsistent formatting with mixed indentation and spacing reduces readability. Minimal error handling and incomplete comparison function cut off mid-implementation. Comments are sparse and occasionally misleading. Variable names are somewhat descriptive but could be improved. Overall structure is understandable but requires significant refactoring for maintainability.","tokens":1898,"name":"95.jsnp"}
{"score":"65","reasoning":"CUDA reduction pattern with repetitive structure. Uses volatile pointers for warp-level optimization but lacks comments explaining this critical design choice. Magic numbers appear without context. The code is functional but requires deep CUDA knowledge to understand synchronization behavior and compiler optimization prevention. Repetitive blocks hurt maintainability. Incomplete snippet limits full assessment. Clear variable names and consistent indentation help readability.","tokens":2006,"name":"59.jsnp"}
{"score":"55","reasoning":"Code has readability issues due to undefined variable tid, repetitive clamping logic, inefficient single-thread write pattern, and distracting commented-out code. The extra closing brace suggests syntax errors. While basic binning logic is clear, these issues significantly hinder comprehension and maintainability. Variable names are somewhat descriptive but the overall structure needs improvement.","tokens":1896,"name":"27.jsnp"}
{"score":"40","reasoning":"Code suffers from excessive repetition with long if-else chain launching templated kernels. Dense mathematical expression in getThreadNumForReduction lacks clarity. Inconsistent shared memory allocation and formatting reduce readability. Noisy comment separators and lack of explanatory comments make comprehension difficult. While function names are descriptive and error checking is present, the overall structure is hard to maintain and understand.","tokens":1839,"name":"78.jsnp"}
{"score":"65","reasoning":"Code follows CUDA conventions with d_ prefix and clear function name. However, contains a critical typo \u0027d_jont_hist\u0027 reducing professionalism. Lacks comments explaining logic. Incomplete error handling shown by commented line. Double pointer pattern for device arrays adds complexity without explanation. BLOCK constant is undefined. Overall structure is standard but these issues hinder quick comprehension.","tokens":1654,"name":"118.jsnp"}
{"score":"48","reasoning":"Code snippet shows poor indentation with misaligned braces making control flow unclear. Inconsistent spacing around operators reduces visual consistency. Commented-out line with magic numbers adds confusion. Lack of explanatory comments and missing function context hinder comprehension. Variable names follow CUDA conventions and are descriptive. Overall structure is simple but formatting issues significantly impact readability.","tokens":1797,"name":"2.jsnp"}
{"score":"40","reasoning":"Variable names h_h h_o ppc are cryptic and unclear. Complex array indexing makes logic hard to follow. Missing context from unmatched brace. No explanatory comments. Integer division may cause subtle bugs. Loop structure is standard but overall intent is not self evident. Requires domain knowledge to understand and maintain.","tokens":2470,"name":"80.jsnp"}
{"score":"70","reasoning":"Code has helpful comments explaining intent but suffers from inconsistent naming conventions, a typo in first comment, generic variable name array, no error handling for CUDA calls, and lacks context starting with closing brace. Logical grouping is good but abstraction is leaky making it moderately readable.","tokens":2192,"name":"49.jsnp"}
{"score":"28","reasoning":"Code exhibits poor readability with cryptic variable names b0-b15 p0-p15 excessive parameter lists macro heavy structure and magic numbers. Function names are descriptive but overshadowed by low level bit manipulation lacking comments. Generated code pattern makes comprehension difficult requiring deep GPU cryptography domain knowledge. While functional for high performance password cracking it violates general software engineering readability standards.","tokens":2998,"name":"114.jsnp"}
{"score":"15","reasoning":"The code uses cryptic macro calls MD5GG and MD5HH with numerous parameters including single-letter variables a,b,c,d and magic hex constants. Variable names like b0-b15 lack descriptive meaning. While step numbers are commented, the overall structure is opaque without deep MD5 algorithm knowledge. The MD5_Reverse function has an excessively long parameter list. This appears to be performance-optimized GPU code that severely sacrifices readability for brevity and speed, making it extremely difficult to comprehend for maintainers not already familiar with cryptographic implementations.","tokens":2292,"name":"53.jsnp"}
{"score":"55","reasoning":"Uses standard CUDA grid-stride loop pattern clear to experienced developers but variable names o w b are too short. The snippet is incomplete cutting off the else block. Lack of comments and undefined custom types cudafloat CUDA_VALUE require external context. Simple structure but poor naming and incompleteness hinder readability.","tokens":1681,"name":"52.jsnp"}
{"score":"20","reasoning":"Heavy macro usage with token pasting operators severely obscures actual code execution. Extremely verbose variable names create noise while cryptic short names lack clarity. No comments or documentation. Repetitive structure suggests code generation but makes logic hard to follow. Requires deep domain knowledge of MD4NTLM algorithms and GPU architecture to comprehend. Control flow is simple but intent is completely opaque.","tokens":2159,"name":"69.jsnp"}
{"score":"25","reasoning":"The code snippet is incomplete with missing function signatures and abrupt transitions. It uses cryptic variable names (x, g_idata) and dense formatting without comments. The bit manipulation pattern is non-obvious and requires specialized knowledge. The CUDA kernel definition lacks context. Overall poor readability due to missing structure, documentation, and clear intent.","tokens":1509,"name":"29.jsnp"}
{"score":"45","reasoning":"Code suffers from magic numbers and hardcoded matrix indices making layout unclear. Unnecessary heap allocation for temporary matrices adds complexity and requires manual cleanup. Comments are minimal and dont explain intent. Only 12 of 16 matrix elements are initialized potentially leaving garbage data. Naming is slightly confusing. Overall structure is functional but readability is significantly hindered by these issues","tokens":2712,"name":"94.jsnp"}
{"score":"30","reasoning":"Depends on undefined macros like COLUMNS_BLOCKDIM_X Y RESULT_STEPS and c_Kernel. Complex indexing and halo logic are hard to follow. The kernel array access pattern is confusing and non standard. Needs more comments and uses outdated error checking.","tokens":4135,"name":"10.jsnp"}
{"score":"35","reasoning":"Code fragment lacks context and comments. Uses non-descriptive single-letter variables and magic number 16. Depends on undefined WMATRIX macro. Inconsistent indentation. The dual-update pattern with x+\u003d16 is unclear without domain knowledge. CUDA __syncthreads requires understanding of parallel execution. Overall difficult to comprehend without extensive surrounding code and GPU programming expertise.","tokens":1223,"name":"66.jsnp"}
{"score":"58","reasoning":"Mixed indentation and undefined BLOCK constant reduce clarity. Commented-out code creates noise. Confusing dimension mapping uses dim[1] and dim[3] but skips dim[2] for grid calculations. Non-descriptive variable names B1/G1. Missing comments on function purpose and parameters. While CUDA_SAFE_CALL usage is good and structure follows logical pattern, these issues significantly hinder readability for maintenance and debugging.","tokens":2528,"name":"79.jsnp"}
{"score":"35","reasoning":"Inconsistent formatting and indentation. Poor variable naming with unclear abbreviations. Manual memory management is error-prone. compar_ascent function is incomplete. Lacks error handling. Uses outdated C-style practices in C++. Minimal comments. Logical flow exists but readability is severely compromised.","tokens":2337,"name":"76.jsnp"}
{"score":"60","reasoning":"Code uses extremely short variable names n m r V W H requiring domain knowledge. CUDA kernel launches with undocumented helpers like KernelSumW reduce clarity. Minimal comments explain algorithm steps. Structure is logical with clear separation between H and W updates. Readable only for experts familiar with NMF and CUDA patterns. Lacks explanatory context for broader audience.","tokens":1922,"name":"75.jsnp"}
{"score":"30","reasoning":"Poor readability due to hardcoded repetitive operations with magic numbers 9-15 and cryptic macros AS BS. Dense expressions and unclear variable names like Csub idnx idny hinder understanding. Inconsistent indentation and missing kernel context are issues. Minimal comments help slightly but major refactoring into loops with better naming is essential.","tokens":3103,"name":"86.jsnp"}
{"score":"50","reasoning":"Code fragment lacks context and completeness. Inconsistent naming conventions mix camelCase and snake_case. Linked list structure missing next pointer. Comments are minimal and inconsistent. Pointer syntax spacing is irregular. Missing typedef for cleaner syntax. Overall structure suggests purpose but requires significant domain knowledge to understand. Not production-ready due to incomplete implementation and style inconsistencies.","tokens":2049,"name":"70.jsnp"}
{"score":"30","reasoning":"Poor readability due to dense formatting without spaces, useless decorative comments, inconsistent indentation, unused parameter array_d, and lack of explanatory comments. Function name is descriptive but code is incomplete and requires deep CUDA knowledge to understand. The macro CUDA_SAFE_CALL is good practice but overall structure is cryptic.","tokens":1558,"name":"1.jsnp"}
{"score":"60","reasoning":"Code demonstrates inconsistent formatting with mismatched brace styles and unnecessary blank lines. Variable naming is poor: count suggests element count but represents bytes. Repeated uint8_t casting reduces clarity. Missing malloc error check and memory leaks on cuda errors. No comments explaining the test purpose. Despite logical structure, these issues significantly hinder readability and maintenance.","tokens":1693,"name":"22.jsnp"}
{"score":"50","reasoning":"Code snippet lacks context and uses cryptic NaN checks without comments. The repetitive condition is verbose and could be simplified. While variable names are descriptive, inconsistent formatting and missing surrounding code hinder comprehension. The NaN equality check idiom is unclear to inexperienced developers.","tokens":1289,"name":"77.jsnp"}
{"score":"65","reasoning":"Code performs coordinate transformation and texture sampling. Variable names are mostly clear but matrix multiplication is duplicated three times reducing readability. Formatting is inconsistent with awkward alignment. Magic numbers like -1 and 0.5f lack explanation. Redundant texture fetches occur. Logic is understandable for CUDA developers but requires unnecessary effort due to DRY violations and suboptimal structure.","tokens":2197,"name":"71.jsnp"}
{"score":"40","reasoning":"Cryptic variable names (vd, vr, hd, hr, deltaW) lack semantic meaning. No comments explain algorithm. Complex indexing without context hinders comprehension. Fragment nature missing function signature reduces understandability. While synchronization is clear, poor naming and missing documentation make it hard to decipher without domain knowledge.","tokens":1758,"name":"44.jsnp"}
{"score":"48","reasoning":"Code suffers from cryptic single-letter variable names W V H aux and unclear deltaH vs deltaH2 distinction. Commented-out lines create clutter. Lack of inline comments explaining mathematical operations and side effects of ReplaceByTranspose called twice is confusing. Magic numbers like 0.001 lack context. While structurally logical for matrix updates, significant domain knowledge is required to comprehend data flow and intent.","tokens":1645,"name":"32.jsnp"}
{"score":"30","reasoning":"Thirty repetitive MD5 CUDA kernel macro calls. Pattern is obvious but violates DRY principle severely. No comments explain purpose or parameters. Manual enumeration is error prone and hard to maintain. Macro name is descriptive but hides implementation details. Lacks design context. Should use loop or code generation instead.","tokens":2231,"name":"83.jsnp"}
{"score":"30","reasoning":"Macro-based kernel generation reduces clarity. Critical naming inconsistency: MD5 functions used in SHA1 kernel. Cryptic variable names b0-b15 a-e lack context. Heavy reliance on undefined external constants. No comments. Complex logic without explanation. Pointer casting and magic numbers reduce safety. Overall very difficult to understand and maintain.","tokens":2391,"name":"38.jsnp"}
{"score":"35","reasoning":"CUDA kernel snippet with severe readability issues. Cryptic single-letter variables vd hd vr hr u d a b lack meaning. Starts with sync and ends mid-calculation. Complex thread conditions iIJ jIJ threadIdx.y unexplained. Minimal comments. Only positive is consistent UpdateLearningRateUpdateWeight pattern. Requires extensive external context to understand. Very difficult to comprehend in isolation.","tokens":1959,"name":"48.jsnp"}
{"score":"65","reasoning":"Simple structure with clear header comment and reasonably named constants. However the MAX macro lacks proper parentheses around parameters and entire expression creating potential precedence bugs. THRESHOLD is overly generic without context. Commented include with reserved-style naming is questionable. Overall comprehension is easy but contains notable C programming anti-patterns.","tokens":1184,"name":"109.jsnp"}
{"score":"52","reasoning":"Missing includes for stdlib stdio and cuda_runtime hinder comprehension. Commented out mlock sections are distracting. Magic number 126 is unexplained. Inconsistent formatting unused includes and lack of cudaMemcpy error checking reduce clarity. Good variable names are overshadowed by these issues making the code harder to follow.","tokens":3070,"name":"4.jsnp"}
{"score":"50","reasoning":"Poor variable naming (a, b, idnx, idny), magic number 16, inconsistent formatting, missing comments, incomplete snippet, and potential bug in grid calculation. While the Euclidean distance intent is clear, the code lacks clarity and CUDA best practices. Error handling is absent and context is missing, making it hard to understand for anyone beyond the original author.","tokens":1768,"name":"15.jsnp"}
{"score":"70","reasoning":"Code shows clear pattern for X Y Z derivative calculation but suffers from duplication. Variable naming is mixed: some descriptive (jointEntropyDerivative_X) others terse (temp, c_NMI). Reusing temp variable is slightly confusing. Comments like O\u003ct\u003cbin are cryptic without loop context. Logic is straightforward for CUDA developers familiar with vector types. Overall structure is understandable but could be more concise and self-documenting.","tokens":2057,"name":"117.jsnp"}
{"score":"70","reasoning":"CUDA setup with decent variable names but no comments. Magic numbers like +1 lack explanation. Clean structure but requires domain knowledge. Dimension assignments are clear. Shared memory purpose is ambiguous. Readable for CUDA experts but not for general developers.","tokens":1485,"name":"8.jsnp"}
{"score":"30","reasoning":"Code snippet shows poor readability due to inconsistent indentation, lack of comments, and critical logical error where memory allocation null check occurs after pointer dereferencing. Mixed concerns, global variables, and unclear variable names further reduce comprehension. The formatting issues and missing context make it difficult to understand the code\u0027s purpose and flow.","tokens":1701,"name":"37.jsnp"}
{"score":"35","reasoning":"Snippet lacks documentation and comments. Uses deprecated CUDA headers cutil_inline.h and cutil_math.h. Poor naming conventions with cryptic _tt_backproject_ray_gpu.h. MAX_STEPS macro is unexplained magic number. Inconsistent header ordering. These issues severely impact code comprehension and maintainability.","tokens":1655,"name":"40.jsnp"}
{"score":"40","reasoning":"Code suffers from cryptic single-letter variable names (v,h,w,a,b,I,J) and inconsistent conventions (Kernel prefix vs KERNEL macro). Kernel launches have overly long parameter lists. Heavy reliance on undefined class members and preprocessor directives adds complexity. Dense expressions lack inline comments. While some helper functions exist, overall comprehension requires deep contextual knowledge making it difficult for external readers.","tokens":2955,"name":"30.jsnp"}
{"score":"78","reasoning":"Clear function names and consistent error handling pattern improve readability. Good comments for key operations. Variable names are mostly descriptive. Point deductions for incomplete net_recv function, magic numbers (listen backlog\u003d1, ip buffer\u003d128), inconsistent spacing in declarations, and questionable use of exit() in what appears to be library-style functions. Overall structure is logical and easy to follow for network programming code.","tokens":1751,"name":"17.jsnp"}
{"score":"30","reasoning":"Fragment with severe readability issues. Commented-out if statement creates misleading indentation hiding unconditional fprintf execution. Inconsistent indentation levels obscure block structure. Missing context for variables and functions. TODO explains removed fclose but adds visual clutter. Control flow is confusing and requires careful analysis to understand.","tokens":1451,"name":"54.jsnp"}
{"score":"65","reasoning":"CUDA kernel launch code with grid size calculation. Uses deprecated cudaThreadSynchronize API and non-standard CUDA_SAFE_CALL macro. Pointer dereferencing in kernel arguments is non-idiomatic and confusing. Variable name typo d_jont_hist hurts readability. Lacks comments for grid calculation logic. Recognizable pattern but multiple friction points slow comprehension.","tokens":1614,"name":"63.jsnp"}
{"score":"45","reasoning":"Macro name is excessively long and redundant. No comments explain purpose or why values 8-16 are used. Repetitive pattern is clear but represents boilerplate. Requires knowledge of macro definition to understand. Poor naming and lack of documentation severely reduce readability despite simple structure.","tokens":1963,"name":"45.jsnp"}
{"score":"15","reasoning":"Extremely poor readability due to cryptic variable names (b0-b15, p0-p15), excessive parameter lists, and heavy macro usage with token pasting (##length##). Functions modify many variables by reference creating unclear data flow. Lack of comments, backslash continuation suggests macro context missing. CUDA syntax adds complexity without explanation. Structure indicates performance-optimized generated code with no consideration for human comprehension.","tokens":2670,"name":"108.jsnp"}
{"score":"40","reasoning":"Heavy macro usage obscures core logic. Cryptic variable names a,b,c,d,e and magic bit operations reduce clarity. Long constant names are unwieldy. No comments. While overall structure is logical, significant domain knowledge is required. Code appears to be part of a larger macro definition which makes isolated evaluation difficult.","tokens":3848,"name":"84.jsnp"}
