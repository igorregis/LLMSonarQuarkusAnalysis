{"score":"58","reasoning":"The code demonstrates a polling pattern for Selenium element visibility but suffers from readability issues. The infinite for loop with empty catch block and magic numbers (90, 1000) without constants makes comprehension difficult. While class and method names are descriptive, the verbose wait mechanism lacks abstraction and comments, requiring prior knowledge of legacy Selenium patterns. Modern explicit waits would improve clarity significantly.","tokens":1350,"name":"212.jsnp"}
{"score":"68","reasoning":"Code snippet is incomplete with missing opening and closing braces making full context unclear. Methods are short and focused with clear naming conventions. Good use of specific exceptions and consistent null checking. Underscore prefix for private fields is dated. Lack of comments and incomplete try block at the end reduce comprehension. Overall structure is reasonable but fragmentation hinders readability.","tokens":1399,"name":"131.jsnp"}
{"score":"30","reasoning":"Empty catch block swallows exceptions preventing debugging. Generic XPath lacks context. Missing loop structure obscures logic. Poor error handling and unclear intent significantly reduce readability.","tokens":1251,"name":"192.jsnp"}
{"score":"85","reasoning":"Simple and concise methods with clear naming conventions. The constructor contains unexplained commented code reducing clarity. The orphaned closing brace suggests incomplete context. Overall structure is clean and the getIcon method is straightforward with proper resource referencing.","tokens":1294,"name":"181.jsnp"}
{"score":"35","reasoning":"Code suffers from empty catch blocks swallowing exceptions, magic numbers without context, incomplete loop structure, and deprecated Selenium RC API usage. Manual polling with Thread.sleep instead of proper waits creates race conditions. Hardcoded locators and lack of comments reduce maintainability. Overall structure is confusing and error-prone.","tokens":1413,"name":"146.jsnp"}
{"score":"72","reasoning":"Code suffers from excessive vertical spacing reducing scanability. Incomplete snippet lacks context like try block opening and method signature. Variable names are clear and descriptive. Logic is straightforward with proper logging guards. String concatenation in logs is verbose but acceptable. Overall structure is understandable for Java developers familiar with Liferay patterns.","tokens":1707,"name":"103.jsnp"}
{"score":"98","reasoning":"Clean and well organized import statements following Java conventions. Grouped logically with Liferay portal kernel utilities separated from standard Java library imports. Descriptive class names make purpose clear. Minimal cognitive load with standard explicit imports. No complexity or anti patterns. Lacks context as isolated snippet but excels in readability for its purpose.","tokens":1426,"name":"208.jsnp"}
{"score":"30","reasoning":"Code contains empty catch block swallowing exceptions making debugging impossible. Poor indentation obscures structure. Magic number 1000 lacks context. Hardcoded XPath and awkward line breaks reduce clarity. Silent failure pattern severely impacts maintainability and comprehension.","tokens":1423,"name":"174.jsnp"}
{"score":"45","reasoning":"Code suffers from inconsistent indentation and formatting particularly visible in super.remove call. Missing class context and field declarations for _app and _listener. Questionable logic placing setPreferredSize in paintComponent method. Inconsistent revalidate placement between addImpl and remove methods reduces clarity. Override annotations absent. Overall structure is recognizable but significant issues hinder comprehension.","tokens":1507,"name":"170.jsnp"}
{"score":"50","reasoning":"Code uses undefined macro BETTER_THAN hiding comparison logic. Variables dif posBetter negBetter lack context or initialization. Magic numbers 0.2f 0.4f in bias formulas are unexplained. Nested conditional structure is somewhat clear but overall purpose is obscure without external context. Variable names are partially descriptive but insufficient for standalone comprehension.","tokens":1605,"name":"112.jsnp"}
{"score":"72","reasoning":"Code shows simple getter methods with clear naming but suffers from inconsistent brace style and indentation. The equals method lacks braces for single-line if statements reducing readability. Underscore prefix in field names is dated. Incomplete first line without method signature hampers context. hashCode and equals are standard but formatting could be improved. Overall decent readability with notable style inconsistencies.","tokens":1670,"name":"150.jsnp"}
{"score":"68","reasoning":"Code shows clear naming conventions and logical structure but suffers from unconventional formatting with line breaks in class/method declarations, wildcard imports reducing clarity, and inconsistent indentation. The dependency warning comment is helpful. Overall logic is straightforward despite older Java style patterns. Missing complete method body limits full assessment.","tokens":1736,"name":"151.jsnp"}
{"score":"60","reasoning":"Code suffers from inconsistent parameter naming mixing aPrefixed and plain names. Default constructor passes five nulls without explanation causing confusion. Javadoc is incomplete for md parameter and aTableName. Getter and setter comments are minimal. Indentation is inconsistent. While main constructor has decent documentation these issues significantly impact readability.","tokens":1797,"name":"221.jsnp"}
{"score":"58","reasoning":"The code has readability issues including broad exception handling catching generic Exception which may hide bugs inconsistent structure with early returns and incomplete method at the end missing return statement potential null pointer risk despite early exit lack of comments and unnecessary else clause make comprehension harder logic flow is somewhat jumpy","tokens":1779,"name":"101.jsnp"}
{"score":"65","reasoning":"Code uses raw Map type instead of generics reducing type safety. Contains commented-out code and empty Javadoc clutter. Variable sID uses Hungarian notation. Broad exception handling hides errors. Magic number -1 lacks context. Static cache in instance class is questionable. Despite these issues the core caching logic is understandable and method names are descriptive.","tokens":1941,"name":"166.jsnp"}
{"score":"68","reasoning":"Code shows clear service layer pattern with consistent naming. Methods are short and focused. However first method has incomplete signature and poor indentation hurting readability. Repetitive but typical for Liferay pattern. Structure is logical and follows framework conventions making it moderately easy to understand for experienced developers.","tokens":1789,"name":"153.jsnp"}
{"score":"50","reasoning":"Fragmented code with indentation issues. First line incomplete, serveResource method body not indented. Variable names are descriptive and logic is simple, but lack of context and inconsistent formatting reduce readability. Ends abruptly, hindering full understanding.","tokens":1876,"name":"186.jsnp"}
{"score":"75","reasoning":"Clear naming for class and method with Javadoc. Incomplete snippet ends abruptly. Heavy reliance on parent class members reduces self-contained comprehension. Hardcoded URL and generic Exception are minor issues. Simple structure but requires external context to fully understand.","tokens":1844,"name":"191.jsnp"}
{"score":"60","reasoning":"Incomplete first line with )); creates confusion. If-block has clear intent but excessive nesting and inconsistent indentation hurt readability. Good constants and safe check-then-get pattern are positives. Casting and GetterUtil usage is idiomatic but dense.","tokens":1867,"name":"133.jsnp"}
{"score":"45","reasoning":"Legacy Java code with raw types lacking generics causing type safety issues. Poor variable naming uses unclear abbreviations like dm, am, lp. Contains magic strings and duplicate logic adding parameters to multiple lists. Inconsistent formatting and mixed responsibilities reduce clarity. Some comments help but overall structure is confusing especially with snippet starting mid-method. Modern practices would significantly improve readability.","tokens":2478,"name":"106.jsnp"}
{"score":"38","reasoning":"Code suffers from severe repetition of clickwaitload patterns, brittle Thread.sleep polling with magic numbers 90 and 1000, empty exception handling, hardcoded xpaths and file paths, and lacks abstraction or comments. The flat structure and old Selenium RC API make intent unclear and maintenance difficult. Modern WebDriverWait and page object pattern would greatly improve readability.","tokens":1445,"name":"198.jsnp"}
{"score":"82","reasoning":"Clear JavaBean method signatures with descriptive names. Good Javadoc for getter but missing for setter creates inconsistency. Minor grammar issue in comment. Simple structure easily understood by Java developers. Annotations properly used.","tokens":1204,"name":"168.jsnp"}
{"score":"90","reasoning":"Clear class name and structure. Good use of internationalization via StringManager. Nested i18n interface elegantly groups constants. Follows consistent naming conventions. Simple constructor. Minor points: static prefix notation is dated and i18n interface pattern may be unfamiliar to some developers, but overall highly readable and maintainable.","tokens":1491,"name":"172.jsnp"}
{"score":"45","reasoning":"Poor indentation and inconsistent formatting severely impact readability. Methods contain repetitive boilerplate code violating DRY principles. The logging pattern _log.error(e, e) is non-standard and confusing. While method names are descriptive and the try-catch pattern is simple, the lack of abstraction and formatting issues make it difficult to read and maintain.","tokens":1463,"name":"140.jsnp"}
{"score":"100","reasoning":"Code demonstrates exemplary readability through consistent JavaBean naming conventions, clear Javadoc comments for each method, proper formatting and indentation. The simple getter and setter pattern is immediately comprehensible to any Java developer. No complexity or ambiguity exists. This represents textbook quality Java code with excellent documentation and structure.","tokens":1521,"name":"136.jsnp"}
{"score":"70","reasoning":"The code follows standard JUnit patterns with clear naming, making it easy to understand as a test suite aggregator. However, it lacks documentation, has a cryptic version number in the class name, and is incomplete. The simple structure aids readability but missing context reduces comprehension.","tokens":1240,"name":"176.jsnp"}
{"score":"70","reasoning":"The code demonstrates clear variable naming and logical flow but suffers from a lengthy parameter list in the service call making it difficult to track arguments. The null parameter and framework-specific patterns reduce general comprehension despite decent structure.","tokens":1322,"name":"135.jsnp"}
{"score":"88","reasoning":"Clear method names and consistent permission-checking pattern make this highly readable. Methods are short and focused. Minor deduction for unused List import and Liferay-specific concepts requiring domain knowledge. Overall structure is clean with good exception handling and descriptive parameters.","tokens":1609,"name":"175.jsnp"}
{"score":"25","reasoning":"Incomplete code snippet with missing method calls and switch structure. Uses label and continue as goto creating confusing control flow. Heavy reliance on magic strings and numbers without context. Poor variable naming with numeric suffixes. Inconsistent formatting. Contains potentially incorrect regex pattern. No comments explaining intent. Repetitive code blocks without clear purpose. Overall very difficult to comprehend.","tokens":1886,"name":"193.jsnp"}
{"score":"55","reasoning":"Code suffers from severe duplication of nullcheck and logging logic across methods reducing maintainability. Inconsistent return strategies null vs emptyList. Snippet is incomplete missing method signatures and cut off. Positive aspects include clear naming simple logic and proper logging guards.","tokens":2016,"name":"116.jsnp"}
{"score":"30","reasoning":"Code suffers from heavy use of magic strings and XPath locators making UI interactions cryptic. Control flow with switch case labels and continue statements is confusing and poorly structured. Repetitive patterns lack abstraction. No comments explain intent. Incomplete snippet adds to comprehension difficulty. Variable names are somewhat descriptive but insufficient to offset other issues.","tokens":2137,"name":"152.jsnp"}
{"score":"30","reasoning":"The code uses an archaic while-switch-label pattern resembling goto statements, making control flow extremely confusing. It contains an empty catch block that silently swallows exceptions, magic numbers for timeouts, and a brittle Thread.sleep polling mechanism. The infinite for loop with manual counter is non-idiomatic. While basic test structure exists, these anti-patterns severely hinder readability and maintainability.","tokens":1949,"name":"102.jsnp"}
{"score":"58","reasoning":"The code shows a simple Java bean structure with constructors, getters, and setters. However, readability suffers from inconsistent naming: indexed methods use plural names (getArchiveFiles(int)) instead of singular per Java conventions. Missing field declarations and repeated verbose fully-qualified class names reduce clarity. The underscore prefix in parameters is non-standard. Javadoc comments are present but incomplete. Overall structure is understandable but violates common practices.","tokens":1687,"name":"188.jsnp"}
{"score":"80","reasoning":"Code demonstrates good readability with descriptive method names and clear test purposes. Structure is logical and focused. Minor issues include excessive vertical whitespace in helper method, some overly long lines, and incomplete snippet boundaries. Framework-specific APIs are used idiomatically. Overall well-written test code that would be easily understood by developers familiar with the persistence framework.","tokens":2291,"name":"204.jsnp"}
{"score":"75","reasoning":"Code shows clear repetitive setter pattern that is easy to understand despite being verbose. Method names are descriptive and formatting is consistent. The compareTo method is unnecessarily verbose with redundant initialization and return statements. While functional, the comparison logic appears incomplete as it only compares names. Overall straightforward but could be more concise and robust.","tokens":1845,"name":"183.jsnp"}
{"score":"35","reasoning":"Severe repetition violates DRY principles with hardcoded magic strings and numbers throughout. Empty catch block hides errors. Uses deprecated Selenium RC API with inefficient polling loop. No abstraction or comments make intent unclear. High cognitive load required. Extremely difficult to maintain.","tokens":1989,"name":"167.jsnp"}
{"score":"85","reasoning":"Clear descriptive naming follows Command pattern effectively. Constructor and execute method are simple and focused. However inconsistent spacing around parentheses reduces visual cleanliness and standard formatting. Missing visibility modifiers and class context slightly limit full comprehension but overall intent remains obvious.","tokens":1475,"name":"104.jsnp"}
{"score":"25","reasoning":"Hardcoded fragile locators repetitive patterns magic numbers and antiquated Selenium RC API create poor readability. Label based control flow is confusing. Lack of abstraction makes maintenance difficult. Magic strings and incomplete structure further reduce comprehension. While basic actions are traceable severe anti patterns severely impact understanding.","tokens":2217,"name":"157.jsnp"}
{"score":"88","reasoning":"Clear test suite aggregation pattern with descriptive naming. Simple structure follows standard JUnit conventions making intent obvious. Code is incomplete missing closing braces but core logic is extremely readable and easy to understand for Java developers familiar with testing patterns.","tokens":1043,"name":"207.jsnp"}
{"score":"30","reasoning":"The header comment contains copy-paste errors (referring to \u0027Foobar\u0027 instead of project name), outdated HTML formatting with excessive br tags, and redundant paragraph tags. The @author tag includes email incorrectly. While imports are clear, the overall presentation shows lack of attention to detail, significantly reducing readability and comprehension. The license text confusion makes it hard to understand the project\u0027s actual licensing status.","tokens":1424,"name":"190.jsnp"}
{"score":"35","reasoning":"The code snippet has severe readability issues. A stray method call getLeecherCount() appears without context. The Javadoc comment is separated from the method it describes by a blank line. The method signature is unnecessarily split across two lines. The @return tag is empty, providing no information about the return value. While the comment text is clear, the overall structure is fragmented and confusing, making it difficult to comprehend quickly.","tokens":1373,"name":"126.jsnp"}
{"score":"50","reasoning":"Inconsistent formatting and alignment hurt visual scanning. Mixed naming conventions snake_case and camelCase create confusion. Javadoc is boilerplate without useful descriptions. Inline comments in signatures add clutter. Method name suffix 2 indicates legacy design. Parameter names are clear but overall structure shows technical debt. Understandable with effort but not easily comprehensible.","tokens":1557,"name":"201.jsnp"}
{"score":"50","reasoning":"Code shows Selenium test with poor practices: magic numbers (90, 1000), empty catch block, unconventional infinite loop, hardcoded strings, and overly long package name. The 3 suffix suggests duplication. While functional, these anti-patterns reduce maintainability and clarity for new developers. Lacks comments explaining intent. Overall structure is simple but implementation choices hinder readability.","tokens":1673,"name":"209.jsnp"}
{"score":"30","reasoning":"Outdated Selenium RC API with magic strings and numbers. Empty catch block silences exceptions. Busy-wait loop with Thread.sleep instead of proper waits. Poor formatting and unclear control flow using case labels outside switch context. Complex hardcoded XPath expressions. Lacks comments and meaningful variable names. Structure is confusing and unmaintainable.","tokens":2374,"name":"107.jsnp"}
{"score":"58","reasoning":"Poor variable naming (q, list, sql is actually JPQL) and magic boolean parameters hinder readability. Duplicated QueryUtil.list() calls with subtle differences create confusion. Finally block mixes cleanup and caching logic unexpectedly. Missing method context and comments make understanding harder. While try-catch-finally structure is proper, these issues significantly reduce overall clarity.","tokens":1554,"name":"202.jsnp"}
{"score":"85","reasoning":"Clear constant naming following Java conventions. Descriptive names indicate purpose. Lacks class-level documentation explaining overall context and usage. Numeric values appear arbitrary without explanation. Simple structure makes it easy to comprehend despite minor documentation gaps.","tokens":1104,"name":"189.jsnp"}
{"score":"48","reasoning":"Code suffers from unconventional formatting with line breaks in method signatures, unclear variable naming (find, match, value), complex regex patterns for XML manipulation, incomplete method implementation, hardcoded formatting strings, and commented debug code. While methods are small and somewhat focused, the overall structure and naming choices significantly hinder comprehension. The snippet lacks context about class fields and related methods, making full evaluation difficult.","tokens":1856,"name":"177.jsnp"}
{"score":"82","reasoning":"Clear test organization with descriptive naming and logical setup-to-teardown sequence. JUnit 3 style is dated but consistently applied. Missing return statement in suite() method hinders complete comprehension. Minimal documentation and lengthy class name are minor drawbacks. Overall structure is simple and intent is easily discernible for those familiar with test suite patterns.","tokens":1560,"name":"199.jsnp"}
{"score":"45","reasoning":"Incomplete snippet missing signature and closing braces. Counterintuitive logic: null cache result unregisters defaultObjectName while found only removes from cache without unregistering. Non-standard underscore prefix naming. No comments explaining intent. Variable relationships unclear. Simple structure but poor overall comprehension due to these issues.","tokens":1300,"name":"156.jsnp"}
{"score":"30","reasoning":"Code suffers from inconsistent indentation and formatting with arbitrary line breaks. Contains magic numbers like 30000 without explanation. Uses redundant hardcoded strings and unclear Unicode characters. Variable naming is vague especially label. Most critically the snippet is incomplete ending abruptly inside an if block preventing full comprehension. No comments explain intent. Overall structure is confusing without context.","tokens":1402,"name":"149.jsnp"}
{"score":"35","reasoning":"Code suffers from severe duplication of wait loops, extensive use of magic numbers (90, 1000, 30000, 5000), hardcoded strings and XPaths, empty exception handling blocks, and abrupt incomplete ending. Poor maintainability and violates DRY principles. Thread.sleep usage indicates legacy patterns. Minimal comments. Overall difficult to comprehend intent and flow.","tokens":2982,"name":"145.jsnp"}
{"score":"35","reasoning":"Unconventional line breaks between return type and method name violate Java formatting standards. While method names are descriptive and consistent, the split signatures force readers to mentally reconstruct declarations, unnecessarily hindering quick comprehension. Standard single-line format would significantly improve readability.","tokens":1120,"name":"158.jsnp"}
{"score":"35","reasoning":"The code snippet has significant readability issues. It begins mid-condition with incomplete context. Multiple empty catch blocks silently ignore exceptions (UnsupportedOperationException, NoSuchFileEntryException). Deep nesting makes flow hard to follow. Generic Exception catch is used. Resource management is unclear. No comments explain logic. While method extraction is decent and some naming is clear, the poor exception handling and lack of context make it difficult to comprehend and maintain.","tokens":1820,"name":"180.jsnp"}
{"score":"72","reasoning":"The code has clear structure and descriptive variable names but lacks comments explaining the test scenario. Method parameters in getRecurrence are unclear without context, and it heavily depends on inherited methods and static imports not shown. The assertRecurrenceEquals method name is slightly ambiguous. While logically organized, understanding requires inference about the recurrence pattern being tested.","tokens":2048,"name":"159.jsnp"}
{"score":"50","reasoning":"Code demonstrates poor exception handling practices using generic catch blocks with instanceof checks and exceptions for control flow. Contains duplicated error handling logic and magic strings. Missing context at start reduces comprehension. While variable names are decent and structure is recognizable, anti-patterns significantly hinder readability and maintainability. Requires deep domain knowledge to understand role-based exception logic.","tokens":1572,"name":"111.jsnp"}
{"score":"35","reasoning":"Code suffers from major anti-patterns. Empty catch block silently swallows all exceptions making error handling opaque. Magic number 1000 lacks context. Generic XPath //section is non-descriptive. Missing loop context reduces comprehension. While basic polling intent is discernible, these issues severely hinder readability and maintainability.","tokens":1201,"name":"105.jsnp"}
{"score":"68","reasoning":"Code snippet shows inconsistent indentation mixing tabs and spaces with misaligned closing braces making structure unclear. Test methods have non-standard Java brace placement and excessive whitespace. While method names and test intent are clear, the formatting issues significantly hinder readability. Missing context of enclosing method/class also reduces comprehension. Exception handling is acceptable but error message is overly long.","tokens":1650,"name":"178.jsnp"}
{"score":"45","reasoning":"Lacks context for continue statement. Uses non-standard underscore prefix. Magic constant obscures logic. Inefficient array handling with empty initialization. Redundant else clause. No comments. Inconsistent formatting. Undefined helper method. Multiple anti-patterns hinder readability.","tokens":2602,"name":"187.jsnp"}
{"score":"30","reasoning":"Missing context for switch and loop structures. Heavy use of magic numbers and strings (3, 90, 1000, _125_status). Empty catch block silently ignores errors. Outdated Selenium RC API with manual sleep-based waiting instead of proper WebDriver waits. Confusing control flow using label and continue. Selector duplication and poor error handling make maintenance difficult. Fragmented and hard to understand without surrounding code.","tokens":2182,"name":"217.jsnp"}
{"score":"20","reasoning":"Code snippet has severe readability issues: incomplete context, magic numbers (90, 1000, 30000, li[6]), empty catch block swallowing exceptions, poor loop structure, duplicated XPath expressions, no comments, inconsistent formatting, and appears to contain syntax errors. Uses outdated Selenium patterns making comprehension difficult.","tokens":1899,"name":"215.jsnp"}
{"score":"52","reasoning":"Selenium test with clear naming but major readability issues. Infinite loop syntax is confusing. Magic numbers 90 and 1000 lack context. Empty catch block hides errors. Hardcoded strings and URLs reduce maintainability. Polling pattern is recognizable but poorly implemented with anti-patterns that obscure intent and make debugging difficult.","tokens":1588,"name":"203.jsnp"}
{"score":"80","reasoning":"Clear descriptive naming and logical property grouping enhance readability. Consistent setter pattern is easy to follow. Minor issues include repetitive verbosity and inconsistent line breaks that disrupt visual flow. Conditional block is clear. Overall straightforward and comprehensible for Java developers, though minor formatting improvements would help.","tokens":2006,"name":"148.jsnp"}
{"score":"90","reasoning":"Excellent readability with clear naming conventions and straightforward logic. Method signature clearly defines generic type bounds. The filtering process is easy to follow with descriptive variable names. Code is well-formatted and self-documenting. Minor point: static service call is framework-specific but doesn\u0027t hinder comprehension.","tokens":1409,"name":"119.jsnp"}
{"score":"40","reasoning":"Code exhibits multiple readability issues: inconsistent indentation and spacing, non-standard Java naming conventions (library_path, temp), inefficient string concatenation in loop instead of StringBuilder, poorly formatted comments, and incomplete final statement. Variable names lack descriptiveness. While basic logic is traceable, these problems significantly hinder comprehension and maintainability.","tokens":1665,"name":"115.jsnp"}
{"score":"40","reasoning":"Code uses anti-patterns that hinder readability: magic numbers (90, 1000, 30000), empty catch block silently ignoring exceptions, duplicate polling loops without abstraction, hardcoded locators and strings, no comments explaining intent. While the sequential flow is clear, these issues make maintenance and comprehension difficult. Outdated Selenium RC style with manual sleeps instead of explicit waits.","tokens":1947,"name":"220.jsnp"}
{"score":"70","reasoning":"Clean Java interface with standard formatting and package structure. Javadoc is present but overly brief, failing to clearly explain purpose or usage. Interface name is somewhat descriptive but ambiguous. GPL license header adds visual noise. Overall structure is simple and readable, but lacks substantive documentation for full comprehension.","tokens":1765,"name":"160.jsnp"}
{"score":"88","reasoning":"Well documented Java interface with clear method signatures and descriptive parameter names. Follows standard cryptographic API patterns. Minor issues include inconsistent indentation, redundant public modifiers, a typo in doFinal comment, and missing summary line for one update method. Overall structure is clean and comprehension is high despite minor formatting inconsistencies.","tokens":1321,"name":"184.jsnp"}
{"score":"35","reasoning":"Code suffers from severe formatting issues with excessive whitespace and inconsistent indentation. Variable names are cryptic (c, i, bit, quote). Complex boolean logic lacks parentheses for clarity creating potential precedence bugs. The snippet is incomplete cutting off mid-condition. No comments explain intent. Escape handling appears incomplete. Overall structure is confusing making comprehension very difficult.","tokens":1254,"name":"164.jsnp"}
{"score":"78","reasoning":"Method signatures are pristine Java with clear naming. The Javadoc comment is subpar with confusing class p k spacing and redundant descriptions but doesn\u0027t severely impair understanding of the simple setter. The overall structure is minimal and straightforward.","tokens":1224,"name":"141.jsnp"}
{"score":"78","reasoning":"Code demonstrates good readability with clear descriptive method names and simple delegation pattern. Formatting is consistent and proper. However fully qualified class names make signatures unnecessarily verbose reducing quick scanability. Missing Javadoc comments would help clarify purpose parameters and return values for new developers. Overall structure is clean but verbosity and lack of documentation slightly impact comprehension.","tokens":1405,"name":"214.jsnp"}
{"score":"92","reasoning":"Code shows excellent readability with clear descriptive method names following Java conventions. Copy constructor and simple getter are immediately understandable. The magic number 8 for ICMP header length is acceptable as it\u0027s a fixed protocol constant, though a named constant could slightly improve maintainability. No complexity or confusing patterns. Clean minimal structure.","tokens":1110,"name":"213.jsnp"}
{"score":"58","reasoning":"The code uses unconventional vertical formatting with method signature split across multiple lines making it harder to scan. The first line appears incomplete causing confusion. However the Javadoc comment is clear and well-written and the method name is descriptive. Overall readability suffers primarily from non-standard formatting choices.","tokens":1008,"name":"118.jsnp"}
{"score":"30","reasoning":"Code contains critical anti-patterns: empty catch block hides failures, magic numbers lack context, infinite loops are unclear, verbose XPaths reduce readability, and duplicate timeout logic suggests poor abstraction. Hardcoded strings and inconsistent formatting further hinder comprehension. Overall structure is fragile and difficult to maintain.","tokens":1723,"name":"113.jsnp"}
{"score":"35","reasoning":"Malformed first method missing signature. Inconsistent formatting with arbitrary line breaks. No documentation comments. Non-descriptive parameter names. Unclear semantics between empty methods and notSupported() calls. Method overloading lacks explanation. While method names are somewhat meaningful, the overall structure is poor and significantly hinders readability and comprehension.","tokens":1978,"name":"138.jsnp"}
{"score":"35","reasoning":"Fragmented code with inconsistent indentation and unclear context. Underscore naming convention is non-standard and confusing. Static send method suggests singleton but implementation is hidden. Observer pattern update method is cryptic, only toggling a connection flag. No documentation or comments. Overall structure requires significant effort to comprehend due to missing pieces and poor formatting.","tokens":1554,"name":"132.jsnp"}
{"score":"35","reasoning":"The code shows poor readability due to cryptic naming with ambiguous \u00271\u0027 suffix, outdated Selenium RC patterns, and a manual timeout loop with magic number 90. The incomplete snippet lacks context and break conditions. No comments or constants explain the purpose. The infinite loop pattern is error-prone and not immediately clear to developers unfamiliar with this anti-pattern.","tokens":1445,"name":"114.jsnp"}
{"score":"85","reasoning":"Code shows excellent readability with clear naming and concise methods. Each method has single responsibility and is easy to follow. Whitespace usage is effective. Minor points deducted for unseen _METHOD_NAME constant and generic throws Exception. Well organized Sharepoint integration code following Java patterns.","tokens":2054,"name":"125.jsnp"}
{"score":"35","reasoning":"Code uses outdated Selenium patterns with magic numbers 90 1000 30000 lacking context. Empty catch blocks hide exceptions. Duplicate polling loops violate DRY principles. Hardcoded locators and Thread.sleep make it brittle. No comments or method extraction. While sequential flow is clear anti-patterns severely impact maintainability and comprehension.","tokens":1945,"name":"110.jsnp"}
{"score":"70","reasoning":"Code shows clear structure and descriptive naming but suffers from outdated Hungarian notation with underscore prefixes reducing modern Java readability. Missing Override annotations on interface methods decreases clarity. Unused field _myscrolledPanel creates confusion. Inconsistent API pattern with getter for hint but no setter. Empty methods lack explanatory documentation. Overall logic is simple but style issues hinder comprehension.","tokens":1934,"name":"147.jsnp"}
{"score":"30","reasoning":"Severe readability issues: duplicate loops with magic numbers, empty catch blocks, repeated complex XPaths, hard-coded paths, no abstraction or comments. Brittle structure makes intent unclear and maintenance difficult. Code appears incomplete with syntax error.","tokens":2477,"name":"173.jsnp"}
{"score":"92","reasoning":"Standard Java setter with clear descriptive naming. Method signature and implementation are straightforward and easy to understand. Javadoc is present but somewhat redundant, merely restating the method purpose. Parameter placed on separate line is unconventional but acceptable. Overall excellent readability with minor documentation verbosity.","tokens":1441,"name":"161.jsnp"}
{"score":"40","reasoning":"Code snippet lacks context starting with closing brace. Variable string is undefined. toString method uses magic character without explanation and has potential charset issues with new String constructor. Abstract method declaration is clear but overall implementation is incomplete and confusing. Method naming is acceptable but variable naming is generic. Requires more context and comments for better readability.","tokens":1765,"name":"169.jsnp"}
{"score":"35","reasoning":"Code suffers from poor readability due to empty catch blocks swallowing exceptions, magic numbers and hardcoded locators without context, duplicated polling logic, and lack of comments. The mix of implicit waits and hardcoded timeouts makes maintenance difficult. While the sequential flow is clear, the implementation details obscure intent and error handling.","tokens":1940,"name":"210.jsnp"}
{"score":"50","reasoning":"Code uses outdated Selenium patterns with manual timeout loop and empty catch block reducing clarity. Magic numbers 90 and 1000 lack context. XPath is hardcoded without explanation. Class and method names are vague. While functional, these anti-patterns make it difficult to understand intent and maintain. Modern WebDriverWait would greatly improve readability.","tokens":1430,"name":"219.jsnp"}
{"score":"78","reasoning":"Code snippet shows clear intent with standard Java patterns. The for-each loop is readable and conversion logic is straightforward. However missing method signature and variable declarations reduces context. Array conversion could use modern idiom. Empty constructor formatting is terse. Overall simple but lacks completeness and modern practices.","tokens":1224,"name":"171.jsnp"}
{"score":"15","reasoning":"Empty catch block swallows all exceptions making debugging impossible. Poor structure with invisible loop context. Uses Thread.sleep instead of proper Selenium waits. Magic string and number without constants. Indentation is unclear. Overall a brittle anti-pattern that is very hard to understand and maintain.","tokens":1114,"name":"218.jsnp"}
{"score":"35","reasoning":"Code shows poor readability due to repetitive exception handling blocks violating DRY principles, non-standard method naming with underscores, excessive fully qualified class names cluttering lines, and confusing proxy invocation pattern requiring domain knowledge. The exception logic is convoluted catching Throwable then rethrowing with misleading messages. While methods are short and parameter names are clear, the overall structure suggests generated code lacking human-friendly design.","tokens":1942,"name":"165.jsnp"}
{"score":"60","reasoning":"The code has a clear structure and method purpose, but suffers from a critical copy-paste error: logger and StringManager use DeleteAliasAction.class instead of AliasAction.class. This inconsistency severely impacts comprehension and suggests maintenance issues. Variable naming (tw) could be more descriptive. Otherwise, exception handling and i18n usage are appropriate.","tokens":1377,"name":"137.jsnp"}
{"score":"20","reasoning":"Code snippet lacks context starting mid-statement. Contains major anti-patterns: empty catch block swallowing exceptions, Thread.sleep for timing, and brittle XPath expressions. Uses poor control flow with label and continue statements. Hardcoded magic values and strings reduce maintainability. No comments explain intent. Overall structure is difficult to follow and debug.","tokens":2276,"name":"121.jsnp"}
{"score":"90","reasoning":"Clear, descriptive naming conventions with logical method grouping. Simple interface structure with straightforward method signatures. Minimal but adequate Javadoc. Method names are self-documenting, making purpose easily understandable. Lacks extensive documentation explaining source/dest concepts in detail, but overall highly readable.","tokens":1517,"name":"200.jsnp"}
{"score":"75","reasoning":"Code demonstrates clear naming conventions and straightforward logic. However, significant duplication between methods violates DRY principle, reducing maintainability. The else-if structure stops validation on first error which may be intentional but limits comprehensive error reporting. Overall structure is simple to follow but could be refactored into a generic method to improve readability and reduce maintenance overhead.","tokens":1377,"name":"206.jsnp"}
{"score":"68","reasoning":"The code demonstrates consistent structure but suffers from excessive repetition and cryptic naming conventions. The numbered tags (1Tag1, 2Tag2, 3Tag3) and lettered tags (ATag, BTag, CTag) lack descriptive clarity about their purpose. While the pattern is easy to follow, the boilerplate nature and ambiguous test names reduce comprehension. Improved naming or a loop-based approach would enhance readability significantly.","tokens":1454,"name":"155.jsnp"}
{"score":"94","reasoning":"Extremely simple and readable Java exception class with clear naming. Minimal Javadoc provides author info. Code structure is clean and immediately comprehensible. Lacks detailed documentation and additional constructors but readability is excellent. Perfect example of straightforward, maintainable code.","tokens":1878,"name":"182.jsnp"}
{"score":"35","reasoning":"Code uses switch/label as goto creating confusing control flow. Contains magic numbers/strings, silent exception swallowing, no comments, and cryptic selectors. Poor abstraction makes intent unclear and maintenance difficult.","tokens":1670,"name":"205.jsnp"}
{"score":"78","reasoning":"Clear naming and consistent null-check pattern, but suffers from repetitive logic for date fields that should be extracted to a helper method. Long.MIN_VALUE sentinel lacks explanation. Inconsistent null handling: dates use MIN_VALUE while empty name becomes null. Unnecessary \u0027name\u0027 temporary variable adds minor cognitive overhead. Logical structure but could be more concise and maintainable.","tokens":2935,"name":"142.jsnp"}
{"score":"20","reasoning":"Poor readability due to empty catch block swallowing exceptions, hardcoded fragile XPath string, magic number sleep value, inconsistent indentation, and no comments. Uses Thread.sleep instead of proper Selenium waits causing flakiness. Incomplete snippet lacks context making flow unclear. Anti-patterns reduce maintainability and comprehension.","tokens":1774,"name":"124.jsnp"}
{"score":"20","reasoning":"Syntax error on first line, extremely brittle hardcoded XPath expressions, duplicated timeout loops, empty catch blocks, magic values, no comments or abstraction. Uses deprecated Selenium RC API. Nearly impossible to understand test intent or maintain. Very poor readability.","tokens":3177,"name":"194.jsnp"}
{"score":"92","reasoning":"Simple POJO with clear method names and straightforward logic. Exception and result handling is explicit. Underscore prefix for fields is consistent but slightly dated. Excellent naming conventions make intent obvious. No complex logic or nested structures. Self-documenting code requires minimal explanation. Perfect example of a readable data carrier class.","tokens":1302,"name":"163.jsnp"}
{"score":"95","reasoning":"Perfectly structured Java header with logically grouped imports following standard conventions. Descriptive naming provides clear context despite Liferay\u0027s enterprise verbosity. Lacks implementation code but demonstrates excellent organizational readability. Copyright header is standard boilerplate.","tokens":1708,"name":"134.jsnp"}
{"score":"40","reasoning":"Excessive fully qualified names create extreme verbosity. Complex reflection pattern with nested try-catch blocks and reliance on external constants reduces readability. Liferay-specific infrastructure adds cognitive load. While parameter names are descriptive, the boilerplate nature and lack of context make comprehension difficult without domain knowledge. Typical generated service code prioritizing consistency over human readability.","tokens":1506,"name":"162.jsnp"}
{"score":"35","reasoning":"Deep nesting with 4 closing braces reduces readability. Non-standard method signature formatting with line breaks is unconventional. Inconsistent spacing and variable naming peer_ip violates Java camelCase. Method name isBuddy lacks clarity. Incomplete snippet but visible style hinders comprehension.","tokens":1055,"name":"117.jsnp"}
{"score":"72","reasoning":"Java interface with clear method names and parameters showing good design patterns. However extensive use of fully qualified class names in return types and throws clauses creates excessive verbosity reducing readability. Annotations are consistent and helpful. Overall structure is logical and follows conventions but the visual clutter from long package names makes it harder to scan quickly.","tokens":1569,"name":"144.jsnp"}
{"score":"80","reasoning":"Clear wrapper pattern with descriptive naming. Methods are short and delegate cleanly. The reset logic is straightforward. Minor deductions for missing field declarations and underscore naming convention which is non-standard in modern Java. Overall structure is simple and very easy to comprehend.","tokens":1663,"name":"139.jsnp"}
{"score":"45","reasoning":"Incomplete code snippet lacking context and proper structure. Contains repetitive method calls with magic string literals and inconsistent formatting. Missing comments, constants, and clear separation of concerns. The abrupt transition between permission updates and database operations reduces comprehension. While method names are descriptive, the overall structure needs improvement for better readability.","tokens":1616,"name":"127.jsnp"}
{"score":"94","reasoning":"Clear JavaBean signatures with descriptive names and mostly comprehensive Javadoc. Follows standard patterns. Minor deduction for missing Javadoc on setCompanyId breaking consistency. Simple and highly comprehensible for Java developers.","tokens":1802,"name":"130.jsnp"}
{"score":"30","reasoning":"Poor indentation and line breaking make structure unclear. Empty catch block swallows exceptions severely hindering debugging. Hard-coded Thread.sleep indicates brittle timing logic. Deprecated link\u003d locator syntax reduces clarity. Overall poor practices create maintenance burden and obscure intent despite simple logic.","tokens":1436,"name":"143.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear naming conventions and proper structure with descriptive interface name IPortalPropertiesFile. Annotations are appropriately used and imports are well-organized. However the snippet is incomplete ending abruptly with an open brace and lacks comprehensive Javadoc beyond author tag limiting full comprehension of the interface\u0027s purpose.","tokens":1105,"name":"179.jsnp"}
{"score":"78","reasoning":"Clear naming and logical Swing structure make the test UI purpose obvious. Excessive blank lines reduce code density and hinder quick scanning. Minimal Javadoc adds no value. Magic numbers for dimensions lack context. Despite style flaws the straightforward flow ensures good comprehension for experienced developers.","tokens":1852,"name":"123.jsnp"}
{"score":"35","reasoning":"The code snippet is incomplete starting with a string literal missing its preceding context. It uses magic strings and numbers without explanation. The RuntimeVariables.replace method call is cryptic. Lack of comments and poor variable naming make the logic unclear. The continue statement\u0027s purpose is ambiguous without loop context. Overall structure is confusing and requires significant effort to understand.","tokens":1195,"name":"129.jsnp"}
{"score":"72","reasoning":"Method names are descriptive and parameters clearly typed. However, the snippet shows an incomplete first method signature reducing context. Inconsistent naming pattern between URL and Url capitalization. Generic throws Exception clause lacks specificity but keeps signatures simple. Overall structure is straightforward for Liferay developers but requires domain knowledge.","tokens":947,"name":"195.jsnp"}
{"score":"35","reasoning":"Code snippet is syntactically incomplete missing closing brace. Lacks Javadoc documentation and encapsulation with package-private fields. Uses wildcard import java.awt.* reducing clarity. Non-standard 3-space indentation. No constructor or methods provided. While field names are descriptive, the incomplete structure and absence of context make it difficult to understand purpose and usage.","tokens":1799,"name":"128.jsnp"}
{"score":"70","reasoning":"Java test methods with clear naming conventions but verbose implementation. Repetitive setter calls reduce brevity. testUpdateNew method is incomplete and lacks validation. Assertions are straightforward and method purposes are evident. Variable names are descriptive though overly long. Overall structure is logical and easy to follow despite verbosity.","tokens":1816,"name":"120.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear patterns with explicit field handling and descriptive naming. String construction is verbose but straightforward, showing each field name and value. The entity conversion method is linear and easy to follow. Minor issues include inconsistent null checking and dated StringBundler usage, but overall logic is simple and highly comprehensible for any Java developer.","tokens":1295,"name":"197.jsnp"}
{"score":"45","reasoning":"Code has readability issues: method name typo _proccessAttributes, misleading variable name optionsJSON for a HashMap, non-standard underscore prefix for private methods, incomplete snippet ends abruptly, lacks comments, uses inefficient Collections.EMPTY_LIST, and has unclear logic flow with side effects on parameters. Overall structure is confusing and modern Java conventions are not followed.","tokens":2003,"name":"211.jsnp"}
{"score":"90","reasoning":"Clear and concise code with logical flow. Uses standard Java conventions and meaningful naming. Exception message is descriptive. Minor points deducted for incomplete context requiring inference and slightly dated underscore prefix in _value. Overall highly readable and easy to understand.","tokens":1323,"name":"109.jsnp"}
{"score":"78","reasoning":"Clear Swing UI construction with descriptive Hungarian notation names. Linear flow and standard BorderLayout usage make it easy to follow. i18n comment is cryptic but functional. Relies on external instance variables requiring context. Inconsistent indentation and minor spacing issues slightly reduce readability.","tokens":2395,"name":"196.jsnp"}
{"score":"88","reasoning":"Code is concise with clear naming and simple logic. Minor issues include unnecessary blank lines inside the if block, unconventional parentheses around return values, and opaque null parameters lacking context. Overall structure is clean and intent is easily understood despite small formatting quirks.","tokens":1146,"name":"185.jsnp"}
{"score":"72","reasoning":"Clear interface structure with descriptive method names and mostly good Javadoc. However, raw Map type without generics significantly reduces type safety and self-documentation. Missing Javadoc on getName() and outdated I-prefix naming convention also detract from modern readability. Overall decent but needs modernization for better comprehension.","tokens":1560,"name":"216.jsnp"}
{"score":"82","reasoning":"The code has clear structure and descriptive naming making the flow easy to follow. However it lacks null checks for FacesContext and ViewRoot which raises questions about edge cases. The debug message is incomplete missing a closing brace. The partial implementation pattern throwing UnsupportedOperationException requires additional context to fully understand. Overall readable but has minor issues affecting robustness and clarity.","tokens":1629,"name":"154.jsnp"}
{"score":"88","reasoning":"Well-structured class with clear Javadoc comments describing purpose parameters and return values. Method implementations are straightforward and easy to follow. Minor deductions for using legacy Enumeration type instead of modern collections and slightly abbreviated variable name ecP. Overall excellent readability with consistent formatting and logical flow.","tokens":1733,"name":"122.jsnp"}
{"score":"50","reasoning":"Code fragment lacks context starting mid-method. Inconsistent naming uses outdated Hungarian notation lSequenceNo. Typo in toString PlaformMessage. Magic number 32767 unexplained. Ambiguous cn prefix and sendAZID method name. String concatenation poorly formatted. Javadoc is minimal. Basic getter structure is clear but overall readability suffers from multiple issues requiring cleanup.","tokens":1625,"name":"108.jsnp"}
