{"score":"85","reasoning":"The code is well-structured with clear Javadoc comments and descriptive variable names, enhancing readability. Standard Java conventions are followed, making it easy to comprehend the class purpose and methods.","tokens":1367,"name":"221.jsnp"}
{"score":"75","reasoning":"The code is well-structured with clear method overrides, but lacks comments and context for undefined variables like _app and _listener, making it slightly hard to comprehend in isolation.","tokens":1209,"name":"170.jsnp"}
{"score":"85","reasoning":"The code is highly readable with clear method names and straightforward logic. It uses standard Java patterns and persistence layers, making it easy to understand the operations on poll questions.","tokens":1297,"name":"153.jsnp"}
{"score":"90","reasoning":"The code is highly readable with clear method names and structure. The commented line in the constructor is a minor distraction but does not significantly hinder comprehension.","tokens":1281,"name":"181.jsnp"}
{"score":"75","reasoning":"The code has clear variable names and comments, but uses raw types which reduce clarity. The structure is logical, though the anonymous class adds some complexity. Overall, it is moderately readable.","tokens":1733,"name":"106.jsnp"}
{"score":"65","reasoning":"The code uses descriptive names and follows standard structure, but lacks comments and is incomplete, making full comprehension challenging without additional context.","tokens":1457,"name":"186.jsnp"}
{"score":"75","reasoning":"Code has clear naming and structure but lacks comments and requires framework familiarity for full comprehension","tokens":1328,"name":"191.jsnp"}
{"score":"85","reasoning":"The code uses clear variable names and logical structure for easy comprehension. Magic numbers and an undefined macro slightly hinder readability.","tokens":1492,"name":"112.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear method names and comments. However, the commented-out log statement and static cache map slightly reduce clarity. Overall easy to follow.","tokens":1622,"name":"166.jsnp"}
{"score":"35","reasoning":"Incomplete code snippet with empty catch block and unclear control flow makes it difficult to comprehend","tokens":1350,"name":"192.jsnp"}
{"score":"55","reasoning":"The code uses clear Selenium commands but has empty catch blocks and hard-coded waits with magic numbers, reducing readability and maintainability.","tokens":1459,"name":"146.jsnp"}
{"score":"75","reasoning":"Code has clear variable names and follows standard Java practices, but lack of comments and incomplete structure may hinder full comprehension for some readers.","tokens":1827,"name":"103.jsnp"}
{"score":"90","reasoning":"The code is highly readable with standard Java getter methods and well-documented overrides for hashCode and equals. Variable names are descriptive and the logic is straightforward, making it easy to comprehend.","tokens":1697,"name":"150.jsnp"}
{"score":"85","reasoning":"The code uses clear variable names and standard Java practices with proper error handling. However, the lack of comments and use of domain-specific terms may require additional context for full comprehension.","tokens":1676,"name":"131.jsnp"}
{"score":"75","reasoning":"The code has clear naming and comments, following Java conventions for readability. However, the incomplete method reduces ease of full comprehension.","tokens":1845,"name":"151.jsnp"}
{"score":"40","reasoning":"The code is incomplete and starts with closing braces, making it hard to follow. Empty catch block and hard-coded sleep reduce readability. Selenium call is specific but clear if familiar with the framework.","tokens":1600,"name":"174.jsnp"}
{"score":"75","reasoning":"The import statements are well-organized and clear, enhancing readability. However, without any functional code, the overall comprehension of the snippet\u0027s purpose is limited.","tokens":1601,"name":"208.jsnp"}
{"score":"70","reasoning":"Clear naming and structure, but infinite loop and empty catch block hinder readability. Javadoc provides some context.","tokens":1881,"name":"212.jsnp"}
{"score":"65","reasoning":"Code has descriptive names and proper indentation, but the first line is incomplete, reducing clarity. Standard Java constructs are used, yet lack of comments and context may limit understanding.","tokens":1971,"name":"133.jsnp"}
{"score":"75","reasoning":"The code is readable with clear method names and consistent exception handling. However, repetition across methods reduces maintainability and could be improved with refactoring.","tokens":1285,"name":"140.jsnp"}
{"score":"75","reasoning":"The code uses descriptive variable names and has a logical structure, but it lacks comments and is incomplete, which reduces overall comprehension.","tokens":1317,"name":"193.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear naming and comments. Internationalization is handled neatly. However, reliance on external frameworks might require prior knowledge for full comprehension.","tokens":1383,"name":"172.jsnp"}
{"score":"65","reasoning":"The code is structured sequentially but lacks comments and uses hard-coded strings, making it less readable. Repetitive patterns and complex XPath locators reduce ease of comprehension.","tokens":1739,"name":"198.jsnp"}
{"score":"90","reasoning":"The code is straightforward with clear naming and a helpful Javadoc comment. It follows standard patterns for test suites, making it easy to comprehend.","tokens":1180,"name":"176.jsnp"}
{"score":"65","reasoning":"The code uses descriptive variable names but lacks comments and has complex control flow with labels. Hardcoded XPaths and repetitive patterns reduce readability. The incomplete snippet adds to comprehension difficulty.","tokens":1762,"name":"152.jsnp"}
{"score":"55","reasoning":"Code uses unclear control flow with while and switch. Empty catch block hides errors. Variable names are not descriptive. However, indentation is good and purpose is somewhat clear from context.","tokens":1519,"name":"102.jsnp"}
{"score":"75","reasoning":"Well-organized code with clear method names, but absence of comments and reliance on external framework knowledge slightly hinder understanding","tokens":1702,"name":"204.jsnp"}
{"score":"95","reasoning":"Standard Java getters and setters with clear Javadoc comments and descriptive names ensure high readability and easy comprehension.","tokens":1781,"name":"136.jsnp"}
{"score":"75","reasoning":"The code has clear naming and consistent patterns, making it mostly readable. However, code duplication in null checks and an incomplete method reduce ease of comprehension. It is understandable but needs improvement.","tokens":1857,"name":"116.jsnp"}
{"score":"85","reasoning":"The code uses descriptive names and has a logical flow, making it easy to follow. However, the parameter is is ambiguous and the absence of comments slightly reduces clarity.","tokens":1547,"name":"135.jsnp"}
{"score":"85","reasoning":"The code has clear structure and descriptive method names, making logic easy to follow. Permission checks are consistent, but lack of comments may require some domain knowledge for full understanding.","tokens":1603,"name":"175.jsnp"}
{"score":"90","reasoning":"The code uses clear and descriptive method names with straightforward setter calls and a simple compareTo method, making it easy to understand and follow.","tokens":1463,"name":"183.jsnp"}
{"score":"80","reasoning":"The code uses clear method names and standard Java syntax. setGadgetKey lacks a Javadoc comment, reducing readability, but getServiceName is well-documented, aiding comprehension.","tokens":1678,"name":"168.jsnp"}
{"score":"65","reasoning":"The code has clear variable names and logical flow but lacks comments and has repetitive method calls. Complex XPath selectors and an incomplete loop structure hinder full comprehension.","tokens":1688,"name":"157.jsnp"}
{"score":"55","reasoning":"The code uses descriptive method names and assertions but lacks comments and has unconventional label-based flow. The wait loop with empty catch block and hard-coded timeouts reduces readability. Overall structure is messy and hard to follow.","tokens":1640,"name":"107.jsnp"}
{"score":"85","reasoning":"The code has clear naming and Javadoc comments, enhancing readability. However, the field archiveFiles is not declared in this snippet, which may confuse readers about its definition.","tokens":1544,"name":"188.jsnp"}
{"score":"75","reasoning":"The code uses clear variable names and has a logical flow but lacks comments and has repetitive calls to wait and load modules, reducing ease of comprehension.","tokens":1702,"name":"167.jsnp"}
{"score":"65","reasoning":"The code has clear variable names and structure but is incomplete and lacks comments. Exception handling ignores errors, making it harder to understand the full intent.","tokens":1450,"name":"145.jsnp"}
{"score":"80","reasoning":"Descriptive variable names and clear logic. Missing return statement in getSettingsProperties method slightly reduces readability.","tokens":3088,"name":"101.jsnp"}
{"score":"75","reasoning":"Code uses descriptive names and standard test structure, but the busy-wait loop and empty catch block hinder readability and debugging.","tokens":1520,"name":"209.jsnp"}
{"score":"85","reasoning":"Code has descriptive names and simple structure, making it readable. Lack of comments may need context for full understanding.","tokens":1458,"name":"104.jsnp"}
{"score":"75","reasoning":"The code has clear variable names and uses constants for better maintainability. However, it lacks comments and has some redundancy in condition checks. The logic is easy to follow but could be more concise.","tokens":1448,"name":"187.jsnp"}
{"score":"75","reasoning":"The code has clear structure with error handling but lacks comments and uses short variable names. It is readable for experienced developers but relies on framework context.","tokens":1289,"name":"202.jsnp"}
{"score":"60","reasoning":"Method names are clear and the comment for getBadNATCount is descriptive, but the floating getLeecherCount call is confusing and the lack of overall structure reduces readability.","tokens":1592,"name":"126.jsnp"}
{"score":"85","reasoning":"The code uses descriptive names and follows common testing conventions, making it easy to understand. The Javadoc comment adds clarity.","tokens":1249,"name":"207.jsnp"}
{"score":"60","reasoning":"Code is well-structured with descriptive names, but incomplete Javadoc comments hinder full understanding. Overloaded methods are clear.","tokens":1564,"name":"201.jsnp"}
{"score":"85","reasoning":"The code is well-structured with descriptive class and method names, making it easy to understand the test suite assembly. The Javadoc comment adds minimal value but does not hinder readability. Overall, it is highly readable and straightforward.","tokens":1209,"name":"199.jsnp"}
{"score":"90","reasoning":"Constants are well-named following Java conventions and Javadoc provides authorship. The code is straightforward and easy to read, but the snippet is incomplete.","tokens":1149,"name":"189.jsnp"}
{"score":"70","reasoning":"Good use of comments and logical flow, but regex complexity and non-standard formatting reduce ease of comprehension.","tokens":1614,"name":"177.jsnp"}
{"score":"65","reasoning":"The code has clear variable names but lacks context with switch case. Manual timeout handling and silent exception catching reduce readability. No comments provided.","tokens":1436,"name":"217.jsnp"}
{"score":"85","reasoning":"The code is well-structured with descriptive names and clear test logic. Constants enhance readability. Some context dependency on framework methods, but overall easy to comprehend.","tokens":1650,"name":"159.jsnp"}
{"score":"70","reasoning":"Code has clear structure and descriptive names with proper error handling, but lacks comments and relies on undefined methods, making it harder to understand fully.","tokens":1604,"name":"180.jsnp"}
{"score":"90","reasoning":"The snippet has clear import statements and an informative header, but the lengthy license comment may slightly reduce readability.","tokens":1905,"name":"190.jsnp"}
{"score":"85","reasoning":"The code is highly readable with clear variable names and straightforward setter operations. The logic is easy to follow without complexity.","tokens":1622,"name":"148.jsnp"}
{"score":"75","reasoning":"The code uses clear variable and method names and standard exception handling. However, the lack of comments and incomplete context may hinder full comprehension. Logic is straightforward but could benefit from better documentation.","tokens":1572,"name":"111.jsnp"}
{"score":"55","reasoning":"Code snippet is incomplete hindering full understanding. Variable names are clear and synchronization is correctly implemented. Lack of comments reduces readability.","tokens":1526,"name":"156.jsnp"}
{"score":"55","reasoning":"Incomplete code snippet with inconsistent formatting hinders understanding, but test methods are logically structured and well-named, aiding partial comprehension.","tokens":1691,"name":"178.jsnp"}
{"score":"70","reasoning":"Code has good structure and naming, but uses inefficient wait loop and lacks explanatory comments, making it less accessible without context.","tokens":1421,"name":"203.jsnp"}
{"score":"75","reasoning":"The method names are descriptive and standard, but the multi-line formatting for simple declarations reduces readability and ease of comprehension.","tokens":1170,"name":"158.jsnp"}
{"score":"65","reasoning":"The code has clear variable names and standard Selenium usage, but custom methods and undefined variables reduce comprehension. The Unicode escape and incomplete snippet add confusion.","tokens":1883,"name":"149.jsnp"}
{"score":"65","reasoning":"The code is structured well but has an empty catch block and hard-coded values which reduce readability. No comments make intent unclear.","tokens":2117,"name":"215.jsnp"}
{"score":"50","reasoning":"Empty catch block hides errors, hard-coded sleep time, and missing context reduce readability and comprehension.","tokens":1327,"name":"105.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear method names and simple logic. It uses standard Java practices and is easy to follow. However, the undefined constant _METHOD_NAME might cause slight confusion.","tokens":1499,"name":"125.jsnp"}
{"score":"90","reasoning":"The code has excellent documentation with clear Javadoc comments explaining its purpose. The interface name is descriptive, and the structure follows standard Java conventions, making it highly readable and easy to understand.","tokens":1489,"name":"160.jsnp"}
{"score":"85","reasoning":"The code is straightforward with clear method names and delegation. Fully qualified class names add verbosity but do not hinder understanding significantly.","tokens":1268,"name":"214.jsnp"}
{"score":"85","reasoning":"The code is well-structured with descriptive names and clear logic. Generics are used appropriately. The first method is easy to understand, but the second method is incomplete, which slightly reduces comprehensibility.","tokens":1558,"name":"119.jsnp"}
{"score":"95","reasoning":"The code is highly readable with clear Javadoc comments, descriptive method names, and standard Java interface structure, making it easy to understand the MAC algorithms intended behavior","tokens":1462,"name":"184.jsnp"}
{"score":"85","reasoning":"The code is straightforward with clear variable names and simple logic. Repetitive date handling could be improved, but overall it is easy to understand and follow.","tokens":1331,"name":"142.jsnp"}
{"score":"60","reasoning":"The code uses descriptive method names but lacks comments and proper error handling. Infinite loops and magic numbers reduce readability, though the sequential flow is logical.","tokens":2348,"name":"220.jsnp"}
{"score":"35","reasoning":"The code is incomplete and fragmented, making it hard to understand the full context. Indentation is inconsistent, and naming conventions use underscores which are not standard in Java. However, method names like send and update are descriptive.","tokens":1484,"name":"132.jsnp"}
{"score":"55","reasoning":"Inconsistent indentation and undeclared variable changed reduce readability. Logic is clear but string concatenation in loop is inefficient. Comments are present but vague. Incomplete code affects overall comprehension.","tokens":2182,"name":"115.jsnp"}
{"score":"45","reasoning":"Code has inconsistent formatting and unclear conditions. Missing context and comments make it hard to understand the purpose.","tokens":1916,"name":"164.jsnp"}
{"score":"60","reasoning":"The code uses descriptive variable names but infinite loops and ignored exceptions reduce clarity. Long XPaths and no comments hinder understanding.","tokens":2010,"name":"113.jsnp"}
{"score":"85","reasoning":"The code is highly readable with clear method names and a descriptive comment for setClassPK. The methods are simple getters and setters, making it easy to understand their purpose. However, the abbreviation PK might be ambiguous without context, but overall comprehension is straightforward.","tokens":1934,"name":"141.jsnp"}
{"score":"60","reasoning":"Code uses Selenium for web automation with clear steps but has no comments, empty exception handling, and hard-coded values. Duplicated wait loops could be refactored for better readability.","tokens":2012,"name":"194.jsnp"}
{"score":"75","reasoning":"The code is readable with descriptive names, but the infinite for loop for timeout is unclear and the snippet is incomplete, reducing comprehension.","tokens":1460,"name":"114.jsnp"}
{"score":"60","reasoning":"Code has good naming and structure but poor comments, magic numbers, and empty catches, making it moderately readable.","tokens":2225,"name":"173.jsnp"}
{"score":"95","reasoning":"The code is simple and clear with descriptive method names and standard Java inheritance. It is easy to understand its purpose without additional context.","tokens":1417,"name":"213.jsnp"}
{"score":"45","reasoning":"Code has poor readability due to empty exception handling, hard-coded waits, and complex XPath without comments. Structure is unclear with labels and continues.","tokens":1508,"name":"121.jsnp"}
{"score":"95","reasoning":"The code is a standard Java setter method with clear Javadoc documentation. The method name and parameter are descriptive, following common conventions. It is easy to understand for anyone familiar with Java.","tokens":1223,"name":"161.jsnp"}
{"score":"50","reasoning":"Method names are descriptive, but formatting inconsistencies and unclear method implementations hinder readability and understanding.","tokens":2487,"name":"138.jsnp"}
{"score":"60","reasoning":"Code has clear intent with descriptive methods but suffers from duplicated loops, ignored exceptions, and inefficient waiting, reducing ease of comprehension.","tokens":1910,"name":"110.jsnp"}
{"score":"65","reasoning":"The code has descriptive method names but starts with a closing brace indicating poor formatting. Exception handling is repetitive and uses long fully qualified class names. No comments reduce clarity. Overall readable but could be improved.","tokens":1514,"name":"165.jsnp"}
{"score":"80","reasoning":"The code is straightforward with clear method purposes and simple logic. However, non-standard variable naming with underscores reduces Java idiomatic readability. Comments are present but could be more informative.","tokens":2152,"name":"147.jsnp"}
{"score":"60","reasoning":"The code snippet is incomplete and starts with a closing brace, confusing readers. The abstract method is clear, but the string variable in toString is undefined, reducing comprehensibility. It is readable for context-aware individuals but not self-contained.","tokens":1730,"name":"169.jsnp"}
{"score":"45","reasoning":"The code has descriptive method names but suffers from empty catch blocks, magic numbers, and duplicated loop structures, reducing readability and ease of comprehension.","tokens":1981,"name":"210.jsnp"}
{"score":"90","reasoning":"The code is highly readable with clear class naming and inheritance. The constructor is simple and easy to understand. Minimal code enhances comprehension, though it lacks extensive documentation.","tokens":1307,"name":"182.jsnp"}
{"score":"40","reasoning":"The code has an empty catch block that hides errors and uses hard-coded sleep reducing reliability. The logic for waiting on element visibility is clear but practices are poor.","tokens":1330,"name":"124.jsnp"}
{"score":"95","reasoning":"The code is highly readable with clear method names and a descriptive interface purpose. Simple structure and adequate comments make it easy to understand.","tokens":1538,"name":"200.jsnp"}
{"score":"60","reasoning":"Code has good naming and structure, but the empty catch block diminishes readability and could hide errors.","tokens":1763,"name":"219.jsnp"}
{"score":"85","reasoning":"The code has clear naming conventions and good structure with proper error handling. Comments are helpful but one is placed unusually. It assumes some framework knowledge but remains comprehensible overall.","tokens":1611,"name":"137.jsnp"}
{"score":"85","reasoning":"Code methods have clear names and JavaDoc comments for easy understanding. The initial incomplete line causes minor confusion but overall readability is high.","tokens":2292,"name":"118.jsnp"}
{"score":"85","reasoning":"The code is highly readable with clear descriptive class names and a consistent repetitive structure that is easy to understand","tokens":1479,"name":"155.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear method names and follows the wrapper pattern, but non-standard variable naming with underscores and lack of comments slightly reduce readability.","tokens":1393,"name":"139.jsnp"}
{"score":"90","reasoning":"The code uses descriptive variable names and clear layout management. The comment aids in understanding internationalization. It is straightforward and easy to follow for Java Swing developers.","tokens":1409,"name":"196.jsnp"}
{"score":"65","reasoning":"The code has descriptive names and standard structure, but verbose exception handling and framework-specific reflection make it less readable. The incomplete snippet adds to comprehension difficulty.","tokens":1655,"name":"162.jsnp"}
{"score":"95","reasoning":"Highly readable with clear package and import statements, standard license comment, and no complex code logic to hinder comprehension.","tokens":1740,"name":"134.jsnp"}
{"score":"90","reasoning":"The code uses descriptive variable names and standard Java patterns like for-each loops and list-to-array conversion making it straightforward to understand the model transformation process","tokens":1940,"name":"171.jsnp"}
{"score":"40","reasoning":"The code uses unconventional label based control flow making it hard to follow It has magic numbers and uses Thread sleep which is not best practice No comments and incomplete switch case reduce readability","tokens":1853,"name":"205.jsnp"}
{"score":"50","reasoning":"Empty catch block and Thread.sleep usage detract from readability. Simple logic is easy to follow but poor practices reduce comprehension.","tokens":1719,"name":"218.jsnp"}
{"score":"85","reasoning":"Code is well-structured with clear variable names and logical flow, making it easy to understand. However, the Javadoc comment is incomplete, which could be improved for better documentation.","tokens":1350,"name":"123.jsnp"}
{"score":"90","reasoning":"The code is an interface with clear method names and Javadoc comments for most methods, making it easy to understand. However, one method lacks a Javadoc comment, slightly reducing readability.","tokens":1811,"name":"130.jsnp"}
{"score":"85","reasoning":"The code uses descriptive variable names and simple logic, making it easy to understand. However, the repetitive structure and lack of method context for the first part slightly reduce clarity.","tokens":2186,"name":"206.jsnp"}
{"score":"85","reasoning":"The code uses clear method names and a consistent structure for permissions updates, making it easy to follow. However, the JDBC section uses abbreviated variable names and lacks comments, which slightly hinders comprehension for those unfamiliar with database access.","tokens":1576,"name":"127.jsnp"}
{"score":"35","reasoning":"Code uses empty catch block and Thread.sleep reducing readability. Incomplete snippet adds confusion.","tokens":1562,"name":"143.jsnp"}
{"score":"90","reasoning":"The code uses clear and descriptive names for the class and fields, making it easy to understand the purpose. The structure is straightforward with standard Java conventions, enhancing readability.","tokens":1567,"name":"128.jsnp"}
{"score":"75","reasoning":"The code has clear method names and structure, but some test methods lack assertions, reducing clarity on their purpose.","tokens":1656,"name":"120.jsnp"}
{"score":"80","reasoning":"Code is straightforward with good documentation, but lacks field declarations and has a suboptimal hasError implementation.","tokens":2327,"name":"163.jsnp"}
{"score":"65","reasoning":"The code uses clear method names and consistent annotations, but full package names for exceptions and return types add verbosity, reducing readability and ease of comprehension.","tokens":1751,"name":"144.jsnp"}
{"score":"35","reasoning":"The code has unclear variable names, uses a label and continue which can be confusing, and lacks context or comments, making it hard to understand its purpose.","tokens":1284,"name":"129.jsnp"}
{"score":"85","reasoning":"The code is readable with good structure and naming. Logic is clear, but no comments and reliance on JSF context may hinder understanding for some. Stubbed methods are appropriately handled.","tokens":1381,"name":"154.jsnp"}
{"score":"75","reasoning":"Code is readable with good structure and naming. Minor issues include a typo in method name and non-standard underscores. Overall easy to understand.","tokens":2146,"name":"211.jsnp"}
{"score":"85","reasoning":"The code uses clear variable names and standard error handling, making it easy to understand. However, as a partial snippet, some context is missing, which slightly reduces comprehensibility.","tokens":1356,"name":"109.jsnp"}
{"score":"90","reasoning":"The code is well-documented with Javadoc comments, method names are descriptive, and the logic is straightforward. It follows Java conventions and is easy to understand. Minor issue with raw Enumeration return type.","tokens":1570,"name":"122.jsnp"}
{"score":"85","reasoning":"The code uses descriptive names and simple logic with proper null handling. Some repetition in append statements slightly reduces readability but overall easy to understand.","tokens":1671,"name":"197.jsnp"}
{"score":"50","reasoning":"Incomplete code snippet hampers comprehension. Clear method name, but variable naming violates Java conventions and indentation may be inconsistent.","tokens":1864,"name":"117.jsnp"}
{"score":"75","reasoning":"Code is readable with good structure and naming. However, it is incomplete and relies on external framework knowledge.","tokens":1651,"name":"179.jsnp"}
{"score":"90","reasoning":"The code is highly readable with clear method names and comprehensive Javadoc comments. The interface is simple and well-structured. Minor issues include a raw Map type and missing Javadoc for getName method, but overall easy to comprehend.","tokens":1733,"name":"216.jsnp"}
{"score":"75","reasoning":"The code has clear method names and structure, but variable names like lSequenceNo and cn are ambiguous, and magic numbers reduce readability. Overall, it is easy to understand with minor improvements needed.","tokens":1723,"name":"108.jsnp"}
{"score":"85","reasoning":"The code is straightforward with clear variable names and simple logic, but non-standard parentheses in return statements and lack of comments slightly reduce readability.","tokens":1960,"name":"185.jsnp"}
{"score":"40","reasoning":"Incomplete method declaration hinders understanding. Other methods have descriptive names but lack comments and context for full comprehension.","tokens":2334,"name":"195.jsnp"}
