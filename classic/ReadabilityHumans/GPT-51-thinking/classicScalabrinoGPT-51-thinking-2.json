{"score":"92","reasoning":"Code is concise and well formatted, with clear method and function names, consistent indentation, and straightforward constructor logic. Registration calls are uniform and easy to scan. Javadoc is simple but adequate. Comprehension depends slightly on prior knowledge of the dialect and SQLFunctionTemplate, but overall readability is high.","tokens":717,"name":"21.jsnp"}
{"score":"95","reasoning":"Clear and concise JUnit test with a descriptive method name, straightforward sequence of operations, and consistent formatting. The logic is linear and easy to follow, and the domain types give context. Variable names are slightly terse but still understandable, resulting in high overall readability and ease of comprehension.","tokens":593,"name":"133.jsnp"}
{"score":"86","reasoning":"Readable JUnit style test with descriptive method name and clear assertion flow. The HQL query is concise and easy to understand. Anonymous inner classes are standard but add some boilerplate. Repeated casts and long assertion lines slightly hurt clarity, yet overall the code remains straightforward to follow.","tokens":951,"name":"98.jsnp"}
{"score":"92","reasoning":"The method is short, consistently formatted, and uses clear API calls with descriptive constant names, making it easy to follow. No complex logic or nesting is present. Minor improvements could include grouping related configuration lines or brief documentation, but overall readability and comprehension are high.","tokens":702,"name":"191.jsnp"}
{"score":"86","reasoning":"Well structured JUnit test with clear naming and consistent style. Control flow is straightforward and iterator usage is explicit. Inline comment explains nondeterministic ordering. Slightly verbose and domain specific names plus duplicated assertions reduce immediate scanability but overall readability remains high.","tokens":1077,"name":"181.jsnp"}
{"score":"82","reasoning":"Clear naming and straightforward control flow, with consistent indentation, makes the code easy to follow. Readability is slightly reduced by duplicated logic for null address handling, the use of a magic NULL token, and an empty branch for empty input. Refactoring repeated blocks into a helper would improve clarity further.","tokens":943,"name":"61.jsnp"}
{"score":"98","reasoning":"Very readable static factory method with clear name and parameters, concise logic, and good Javadoc. Code structure is simple and consistent, with no branching, making comprehension immediate. Could only be slightly improved by clarifying any nonobvious behavior in documentation if needed","tokens":771,"name":"67.jsnp"}
{"score":"88","reasoning":"The test method is clearly structured and follows a logical flow with setup, execution, and assertions. Variable and method names are descriptive and make intent clear. Use of Hibernate and session handling follows common patterns. Minor typos in strings and some duplicated cache eviction and session code slightly reduce clarity but overall readability is high.","tokens":1048,"name":"192.jsnp"}
{"score":"78","reasoning":"Code is concise and the intent of testing SQL no loss is clear. Method and helper names are descriptive and calls are consistently structured. Readability suffers because the SQL statements are long, densely packed single lines with complex conditions, making them harder to scan and maintain. Formatting queries or extracting them could improve clarity.","tokens":1304,"name":"101.jsnp"}
{"score":"85","reasoning":"Method is readable with clear names and straightforward control flow. Comment explains a design caveat. Minor issues include use of raw Iterator without generics, a long comment block breaking visual flow, and some compact one line conditionals, but overall the logic and intent are easy to understand.","tokens":1111,"name":"31.jsnp"}
{"score":"82","reasoning":"Clear Java method with descriptive names, consistent style and straightforward property mapping, making logic easy to follow. Main readability issue is the duplicated conditional blocks for customPersisterClassName using different class lookup contexts, which may confuse intent and suggest redundancy or a possible bug.","tokens":1261,"name":"146.jsnp"}
{"score":"83","reasoning":"Code is fairly readable with a clear method name, consistent formatting and focused assertions. Comments explain dialect specific behavior. However, complex negated if conditions with repeated dialect checks and long lines slightly reduce readability and make the logic harder to grasp quickly.","tokens":1324,"name":"89.jsnp"}
{"score":"90","reasoning":"Clear structure and naming, consistent indentation and limited logic make the snippet easy to understand. The anonymous Integrator is concise and both integrate overloads delegate to a shared helper, reducing complexity. Minor verbosity from the nested anonymous class and framework specific types slightly impacts instant readability.","tokens":863,"name":"174.jsnp"}
{"score":"95","reasoning":"Clear unit test with descriptive method name, helpful Javadoc and inline comments. Consistent formatting, explicit variable naming and simple control flow make the intent obvious. Minor duplication between the two dialect checks, but it actually reinforces understanding. Overall readability and ease of comprehension are excellent.","tokens":1019,"name":"57.jsnp"}
{"score":"90","reasoning":"Code is short, well indented, and follows common JUnit style. Method name and try catch structure clearly express intent. Variable names are acceptable for a small test, and the use of fail and a specific exception improves clarity. The long query string slightly reduces readability but still remains understandable.","tokens":1017,"name":"81.jsnp"}
{"score":"90","reasoning":"Clear Java test, consistent formatting and naming, logical flow with try finally, explicit assertions, and descriptive property keys. The long method name and many similar property lines add some visual noise but do not hinder understanding. Overall the intent and behavior are easy to grasp.","tokens":1268,"name":"131.jsnp"}
{"score":"88","reasoning":"Clear structured JUnit test with meaningful method and variable names, good indentation and an explanatory comment. Logic is straightforward and exception handling is explicit. Readability is slightly reduced by the nested anonymous inner class and long chained calls to Hibernate internals, but overall the code is easy to follow.","tokens":988,"name":"93.jsnp"}
{"score":"86","reasoning":"Readability is high due to simple unit test structure, consistent formatting and clear given when then style. Variable names for revisions are short but understandable. Extremely long entity class names and some repetition slightly hinder quick scanning, yet the overall logic remains easy to follow.","tokens":1142,"name":"186.jsnp"}
{"score":"85","reasoning":"Well structured Java method with clear control flow, meaningful identifiers and helpful comments. Indentation and spacing are consistent. Logic around implied optimistic locking is a bit dense and a typo in a helper name slightly reduces clarity, but overall it is easy to read.","tokens":1086,"name":"106.jsnp"}
{"score":"76","reasoning":"Code is fairly readable with consistent formatting and meaningful variable names. However, heavy use of magic numbers, bitwise operations without comments, and long debug print lines reduce clarity. Extracting helper methods and naming constants would improve overall comprehension.","tokens":1370,"name":"58.jsnp"}
{"score":"94","reasoning":"Code is highly readable. Method and variable names are descriptive, comments clarify behavior without being verbose, and control flow is straightforward with minimal nesting. Consistent formatting and limited branching make comprehension easy. Only minor potential improvement in reducing comment redundancy.","tokens":990,"name":"151.jsnp"}
{"score":"90","reasoning":"Clear naming and consistent formatting make the code easy to read. Logic branches for composite and non composite keys are straightforward, and comments clarify intent. Method is short and cohesive. Minor overhead from external helper methods and SQL placeholder handling, but overall comprehension remains high.","tokens":1180,"name":"112.jsnp"}
{"score":"90","reasoning":"Code is well structured and easy to follow, with clear method and variable names, consistent indentation and helpful comments. Control flow is linear and short with no deep nesting or complex logic. Domain specific calls reduce understanding slightly but overall readability and comprehension are high.","tokens":1371,"name":"170.jsnp"}
{"score":"96","reasoning":"Simple method with clear flow and conventional naming. Indentation and structure are standard, try catch is minimal and intent to ignore IOExceptions is obvious. Could be slightly improved with a brief comment or logging in the catch block, but overall readability and comprehension are high.","tokens":849,"name":"150.jsnp"}
{"score":"92","reasoning":"The equals method is clear and follows common Java patterns. Identity and type checks are straightforward, casting is explicit, and field comparisons are easy to follow. The null safe checks for name and surname are slightly verbose but still standard. Overall, the code is readable and understandable with minimal cognitive load.","tokens":546,"name":"60.jsnp"}
{"score":"86","reasoning":"Readable and easy to follow with clear variable names and consistent formatting. Logic for building rectangle anchor points is straightforward. However, the magic number 5 reduces clarity and could be replaced with xs.length, and brief documentation of ptClosestTo usage would further aid comprehension.","tokens":763,"name":"153.jsnp"}
{"score":"88","reasoning":"Clear concise Java method with meaningful names and simple control flow. Handles empty and single element cases explicitly, improving readability. Slight confusion from method name parserPrimaryKeyJoinColumnList instead of parsePrimaryKeyJoinColumnList and reliance on external helpers, but overall easy to understand.","tokens":620,"name":"193.jsnp"}
{"score":"95","reasoning":"Well structured Java constructor with clear intent, good naming, and consistent formatting. Type and function registrations are straightforward and easy to scan. Use of constants and helper methods aids comprehension. No complex logic or nesting. Minor improvement could be adding brief comments or grouping related registrations, but overall readability is high.","tokens":990,"name":"20.jsnp"}
{"score":"88","reasoning":"Clear method and variable names, good formatting and focused responsibility. Inline comments explain intent. However, it relies on framework specific knowledge and long chained calls, which slightly hinders quick understanding, so readability is high but not perfect.","tokens":763,"name":"103.jsnp"}
{"score":"90","reasoning":"Clear Java method with meaningful names and simple conditional logic. Indentation and line breaks are consistent and the intent of each branch is easy to follow. Use of helper methods addElementListener and removeElementListener aids comprehension. Minor issues are magic string property name and nested type checks but overall readability is strong.","tokens":852,"name":"47.jsnp"}
{"score":"82","reasoning":"Readable JUnit style test with meaningful method and variable names and logical structure. Anonymous inner classes are easy to follow. However, heavy casting, raw List use, unusual spacing with many parentheses, and a dense assertion block reduce clarity somewhat.","tokens":1015,"name":"96.jsnp"}
{"score":"88","reasoning":"Clear, concise JUnit test with consistent formatting and naming. Use of final and Properties is straightforward and assertions are easy to follow. The repeated password_enc property and the numeric prefixes in the property keys add minor visual noise, but overall the snippet remains highly readable and easy to comprehend.","tokens":795,"name":"35.jsnp"}
{"score":"90","reasoning":"Clear JUnit test with straightforward logic descriptive variable names and consistent indentation The loop and assertions are easy to follow Minor issues are magic numbers repetitive attribute access and a slightly awkward boolean name and message typo but overall readability remains high","tokens":1501,"name":"90.jsnp"}
{"score":"82","reasoning":"Code is generally clear with meaningful variable names and consistent formatting. Control flow is straightforward and the method is short. However the nested loops with complex casting and the use of multiple boolean state flags without explanatory comments make comprehension slightly harder. Overall readability is good but not exceptional.","tokens":994,"name":"50.jsnp"}
{"score":"74","reasoning":"Readable due to descriptive domain names and consistent style, but the single long test method mixes many concerns, uses nested conditionals and index++ bookkeeping, and relies on framework specific types, which makes the flow hard to follow and maintain. Extracting helper methods and clarifying assertions would improve comprehension.","tokens":1206,"name":"140.jsnp"}
{"score":"82","reasoning":"Code is well structured with clear naming and consistent indentation. Anonymous inner classes and long chained calls slightly reduce clarity, as do raw List and Map types and repeated casting. Overall logic is easy to follow for someone familiar with Hibernate and JUnit.","tokens":1186,"name":"99.jsnp"}
{"score":"40","reasoning":"Basic structure and early null or identity checks are clear, but the final return line is very hard to read. It uses deeply nested ternary operators and complex null checks for schema and catalog in one expression, with non obvious operator precedence. Splitting conditions into well named intermediate variables would greatly improve clarity.","tokens":1404,"name":"36.jsnp"}
{"score":"90","reasoning":"Clear and compact test, consistent indentation and straightforward flow. Use of helper methods and simple asserts makes behavior easy to follow. Readability is slightly reduced by cryptic names like ed1, ing2 and rev1 to rev5 and lack of comments about revision semantics, but overall it remains very easy to understand.","tokens":1216,"name":"166.jsnp"}
{"score":"95","reasoning":"Clear, concise equals implementation with standard identity, type, and superclass checks. Follows common Java style, good use of early returns, and well written Javadoc. Indentation and naming are consistent. Slight redundancy in the final return statement but it does not harm readability.","tokens":843,"name":"39.jsnp"}
{"score":"93","reasoning":"Clean well structured Java code with clear control flow and a standard threading pattern. Try finally makes behavior explicit and runFinished call is safely ensured. Naming and indentation are consistent. Commented legacy line adds minor noise but overall the snippet is concise and very easy to understand.","tokens":1128,"name":"73.jsnp"}
{"score":"86","reasoning":"Code is generally clear and easy to follow, with descriptive test name, understandable assertions, and straightforward control flow. Direct JDBC usage and raw types reduce readability slightly, as do manual resource management and string concatenation for SQL, but overall the intent and behavior remain easy to comprehend.","tokens":1011,"name":"136.jsnp"}
{"score":"92","reasoning":"Clear and concise JUnit test method with meaningful names and straightforward transaction handling. Indentation and structure are consistent and the logic is easy to follow. The only minor drawback is the unexplained numeric literal 123 used for country creation, but overall readability and comprehension are high.","tokens":600,"name":"168.jsnp"}
{"score":"75","reasoning":"Code flow is straightforward and method and type names are mostly descriptive. However use of raw Vector and Enumeration, lack of generics, repeated calls to Designer theDesigner, the unclear inline comment, and mixed indentation reduce readability and modern clarity.","tokens":1149,"name":"46.jsnp"}
{"score":"92","reasoning":"Very short method with clear naming and simple control flow. Indentation and spacing are consistent. Comment clarifies behavior. However, always returning null may surprise readers and lacks explanation, slightly reducing clarity.","tokens":786,"name":"65.jsnp"}
{"score":"88","reasoning":"Clear JUnit test with descriptive name and straightforward structure. The query and expected SQL are long but formatted and concatenated in a reasonably readable way. Use of final and helper method toRowSelection helps clarity. Readability could be slightly improved by extracting the long SQL into named constants or helper methods.","tokens":836,"name":"23.jsnp"}
{"score":"93","reasoning":"Code is clear and straightforward, with descriptive method and field names, and a conventional toString implementation using StringBuilder. The conditional block for region is easy to follow and the structure is logically ordered. Readability is high; minor improvement could be made by breaking long chained append calls into more visually separated lines.","tokens":602,"name":"64.jsnp"}
{"score":"68","reasoning":"Code is mostly clear and follows a simple flow. However readability suffers from very long method chains, repeated casting to SessionImplementor, lack of helper methods and no comments. Formatting and line breaking could be improved but overall the purpose is understandable.","tokens":1111,"name":"100.jsnp"}
{"score":"88","reasoning":"Code is concise and logically structured, with descriptive method and variable names and logging that clarifies behavior. Control flow is straightforward. Readability is slightly reduced by raw Iterator use and indentation with mixed tabs, but overall it is easy to understand.","tokens":1006,"name":"7.jsnp"}
{"score":"92","reasoning":"Code is short, consistently formatted and easy to scan. Method names and types are self explanatory and there is no complex control flow. All registrations follow the same pattern, aiding comprehension. Minor downsides are the long ungrouped list of calls and reliance on magic string literals without additional documentation.","tokens":1090,"name":"18.jsnp"}
{"score":"93","reasoning":"Clear and expressive Java code with detailed documentation, descriptive method and variable names, and straightforward control flow. Proper indentation and consistent style aid understanding. Slight verbosity and long identifier names add minor cognitive load but overall readability and comprehension are high.","tokens":1140,"name":"102.jsnp"}
{"score":"90","reasoning":"Code is clear and well structured, with descriptive method and variable names, consistent indentation and straightforward control flow. Switch grouping of related XML events improves readability and exception messages are informative. Minor concern is the long loop driven by nextEvent without explicit end element break, but it remains easy to follow.","tokens":1106,"name":"152.jsnp"}
{"score":"90","reasoning":"Clear structure with descriptive names and linear control flow. Use of annotations is straightforward and responsibilities are well separated. Ternary expressions and domain specific types add minor cognitive load, but overall the method remains concise and easy to understand.","tokens":1184,"name":"28.jsnp"}
{"score":"88","reasoning":"Clear JUnit test with descriptive method name and consistent indentation. Use of helper assertion methods makes intent obvious and code easy to follow. Readability is slightly reduced by the long sequence of nearly identical assertAnnotationNotPresent calls, which could be refactored into a loop or helper, but overall it remains very understandable.","tokens":866,"name":"176.jsnp"}
{"score":"86","reasoning":"The test method is well structured with clear variable names and consistent indentation, making the overall flow easy to follow. Assertions are straightforward and reflect the intent. Readability is slightly reduced by magic revision numbers, a raw List without generics, and a long chained query without intermediate variables or comments.","tokens":893,"name":"167.jsnp"}
{"score":"78","reasoning":"Readable Java method with clear naming and consistent indentation. Logic is straightforward but heavily nested if statements and repeated Model getFacade and getAggregationKind calls hurt clarity. Could be simpler with an if else chain or switch like structure and a small refactor to avoid repetition. Still easy to follow for most developers.","tokens":885,"name":"157.jsnp"}
{"score":"92","reasoning":"The test is clear and easy to follow, with consistent structure and descriptive method name. Variable names like fragment and template are understandable, and assertions show intent plainly. Minor repetition could be reduced with a parameterized test or helper method, and aligning casing and spacing consistently in expected strings would further improve readability.","tokens":841,"name":"26.jsnp"}
{"score":"92","reasoning":"Clear Java style with descriptive names, consistent indentation and logging. Control flow is straightforward with explicit error handling and limited nesting. Conditions are easy to follow and responsibilities are well separated. Only the framework specific types and terminology slightly reduce immediate accessibility for unfamiliar readers.","tokens":828,"name":"183.jsnp"}
{"score":"90","reasoning":"Java test method is well structured with consistent indentation, descriptive identifiers and meaningful comments explaining the complex mapping scenario. Control flow is straightforward and side effects are clear. Long method name and verbose comments slightly reduce brevity but not clarity, so overall readability is high.","tokens":1175,"name":"175.jsnp"}
{"score":"90","reasoning":"Clear structure and naming, consistent formatting, and a helpful comment make the method easy to follow despite some framework specific terminology. The nested if else logic is slightly verbose and the long conditional expression hurts readability a bit, but overall the code is straightforward and comprehensible.","tokens":1450,"name":"198.jsnp"}
{"score":"90","reasoning":"Code is clear and structured, naming is descriptive, and test logic flows linearly. Anonymous inner classes are simple and focused. Readability is high, though nested overrides and inline suite setup add slight cognitive load compared to extracting helper methods.","tokens":997,"name":"12.jsnp"}
{"score":"86","reasoning":"JUnit test is generally clear with descriptive method and variable names. Hibernate query and paging logic are understandable but compressed into a single long line, which hurts readability. Structure and assertions are straightforward, so overall comprehension remains high.","tokens":861,"name":"92.jsnp"}
{"score":"85","reasoning":"Code is readable with clear structure, consistent indentation, and descriptive comments marking each revision step. The transactional pattern is easy to follow, though somewhat repetitive. Names like ele1 and external references c3_1 and c3_2 are slightly unclear but do not greatly harm comprehension.","tokens":940,"name":"188.jsnp"}
{"score":"95","reasoning":"Very readable equals method with clear structure and early returns. Uses self explanatory field names and step by step comparisons, making intent obvious. JavaDoc is descriptive and aligned with implementation. Indentation and formatting are consistent. Minor verbosity in multiple if checks but this also helps clarity.","tokens":1171,"name":"42.jsnp"}
{"score":"92","reasoning":"Method is short and clear, with descriptive naming and limited parameters. Use of helper validate method and constructor call is straightforward. Comment is brief though TODO could be clearer. Overall very readable and easy to understand with consistent formatting.","tokens":795,"name":"55.jsnp"}
{"score":"90","reasoning":"Code is short, well indented, and uses clear method and parameter names. Logic is straightforward and side effects are obvious. The lazyProperty arrays and index j require some knowledge of surrounding context, which slightly reduces clarity, but overall the code remains easy to follow and maintain.","tokens":808,"name":"104.jsnp"}
{"score":"88","reasoning":"The test is concise and intention revealing, with clear setup, action, and assertion. Naming is good and exception handling logic is straightforward. Readability is slightly reduced by the long chained calls in a single statement and the boolean flag pattern instead of modern assertion helpers.","tokens":817,"name":"145.jsnp"}
{"score":"88","reasoning":"The code is short, well-indented, and uses descriptive method and variable names, making intent easy to understand. Separation of local and remote listeners is clear. However, there is some repetitive code that could be refactored and the getSaw method names are slightly confusing semantically.","tokens":625,"name":"190.jsnp"}
{"score":"96","reasoning":"Clear Java serialization code with good naming and documentation. Repeated calls follow the same pattern and there is no complex logic which makes it easy to read. Minor repetition is acceptable. Overall the method is very readable and self explanatory.","tokens":1075,"name":"3.jsnp"}
{"score":"90","reasoning":"Readable Java method with clear if else precedence chain, good naming and consistent formatting. Inline comments explain intent, despite minor grammar issues. One compound condition is a bit long, but overall logic remains easy to scan and understand.","tokens":1508,"name":"107.jsnp"}
{"score":"92","reasoning":"Clear JavaDoc, descriptive parameter names, consistent formatting and simple control flow make the method easy to follow. Context creation, iteration, cleanup and final construction are logically ordered. The long constructor call on the return line slightly hurts readability but overall comprehension remains very high.","tokens":943,"name":"126.jsnp"}
{"score":"78","reasoning":"Clear JUnit test with a simple structure and consistent parse calls. The intent of each line is obvious and domain naming is descriptive. However, long HQL strings with inconsistent case and spacing slightly hurt readability. Overall it remains easy to follow for someone familiar with Hibernate and query testing.","tokens":968,"name":"85.jsnp"}
{"score":"92","reasoning":"Clear naming, consistent formatting and straightforward control flow. Error handling uses descriptive messages that aid understanding. Reflection is used in a simple, linear way and variable names make roles obvious. Minor downsides are long exception messages and use of generic Exception, but overall readability and comprehension are high.","tokens":786,"name":"13.jsnp"}
{"score":"90","reasoning":"Code is short and well structured with meaningful names and consistent indentation. The purpose of the method is clear from the comment and the registration calls follow a predictable pattern. One minor issue is the presence of a leftover commented alternative line for name initialization, which slightly distracts but does not harm overall comprehension.","tokens":844,"name":"5.jsnp"}
{"score":"95","reasoning":"Code is very clear and easy to follow. The constructor is small, has a precise javadoc and delegates responsibility to well named helper methods. Indentation and naming conventions follow Java standards. There is no complex logic in this snippet, so comprehension is immediate.","tokens":651,"name":"19.jsnp"}
{"score":"90","reasoning":"Concise Java listener method with clear conditions and descriptive names. Indentation and structure are good, logic is easy to follow. Minor noise from commented out code but it does not hinder understanding. Overall very readable and straightforward.","tokens":856,"name":"11.jsnp"}
{"score":"88","reasoning":"Readable JUnit test with clear purpose and descriptive identifiers. Formatting is consistent and code flow is linear. However, heavy repetition of reader.getAnnotation calls makes lines long and slightly noisy; extracting local variables or helper methods could improve scanning. Overall still easy to understand.","tokens":1494,"name":"135.jsnp"}
{"score":"82","reasoning":"Good indentation and clear structure, with meaningful method and variable names. Trace logging improves understanding of the control flow and timing. However, the large block of commented out code and the unused runs counter reduce clarity and may confuse the intent. Overall still easy to follow but not perfectly clean.","tokens":1030,"name":"172.jsnp"}
{"score":"90","reasoning":"Clear structure and naming, with consistent indentation and concise body using helper methods. Test method name is long but descriptive of the scenario. Comment is understandable. It lacks explicit assertions in this snippet, relying on helper methods, which makes the test intent slightly less obvious when read alone. Overall it is easy to follow and readable.","tokens":901,"name":"187.jsnp"}
{"score":"92","reasoning":"Readable JUnit test with clear method and variable names, consistent indentation, and straightforward assertions. Queries are simple and intent is obvious. Minor redundancy and long lines but nothing harms comprehension. Overall very easy to follow.","tokens":1169,"name":"88.jsnp"}
{"score":"88","reasoning":"The code is clear and easy to follow. Method and variable names are descriptive, and comments explain the intent. Indentation and control flow are straightforward. Readability could be slightly improved by reducing line wrapping, avoiding unnecessary casts, and using an enhanced for loop instead of index based iteration.","tokens":938,"name":"51.jsnp"}
{"score":"90","reasoning":"Code is clear and idiomatic, with descriptive method and variable names and well separated logical steps. Comments label revisions and help orientation. Formatting and spacing are consistent. There is some boilerplate duplication around transaction handling and long fully qualified class name strings, but overall comprehension remains very easy.","tokens":964,"name":"189.jsnp"}
{"score":"90","reasoning":"Clear JUnit test, consistent naming, straightforward assertion sequence and formatting. Lacks brief comments and some grouping of related checks, and many magic constant values slightly reduce immediate understanding, but overall very readable.","tokens":1475,"name":"177.jsnp"}
{"score":"78","reasoning":"Method is short and uses clear, descriptive helper names, making overall intent understandable. However, embedding multiple null entries as implicit separators harms readability and maintainability, since their meaning is not self evident. A more explicit structure or comments for grouping would improve clarity.","tokens":556,"name":"156.jsnp"}
{"score":"84","reasoning":"Code is concise and uses descriptive method and variable names, making control flow easy to follow. Readability is slightly reduced by multiple explicit casts and framework specific types with no inline documentation, which may slow understanding for readers unfamiliar with the domain.","tokens":786,"name":"148.jsnp"}
{"score":"88","reasoning":"Clear JUnit style test with descriptive names and logical assertion order, making the intent understandable. Use of collections and iterators is straightforward. Readability is slightly reduced by long chained method calls, repeated expressions, and dense assertions that could be refactored into helper methods or intermediate variables for better clarity.","tokens":1169,"name":"180.jsnp"}
{"score":"94","reasoning":"Clear JavaDoc, descriptive method and variable names, consistent formatting, and straightforward control flow. The purpose of positive and negative accumulators is easy to infer, and the range computation is direct. Minor improvements could include clarifying the base parameter usage in the documentation, but overall readability is high and comprehension is easy.","tokens":953,"name":"41.jsnp"}
{"score":"85","reasoning":"Clear unit test structure with descriptive method name and straightforward assertion The fluent call chain is readable though slightly long and deeply nested Fully qualified class name is verbose but explicit Overall the logic is easy to follow and formatting is consistent","tokens":694,"name":"199.jsnp"}
{"score":"82","reasoning":"Code is well structured with clear naming and consistent indentation. Use of anonymous inner classes is standard for tests but adds verbosity. Lack of generics and repeated casts reduce readability slightly. Assertions are straightforward and the overall intent of the test is easy to understand.","tokens":1098,"name":"97.jsnp"}
{"score":"88","reasoning":"Clear Java constructor with descriptive method and class names, logical grouping with separators and actions, and consistent indentation. Minor downsides include the short variable name a and slightly dense formatting in the nested JScrollPane and UMLMutableLinkedList construction, but overall the code is easy to follow and understand.","tokens":806,"name":"158.jsnp"}
{"score":"78","reasoning":"Code is short and structurally clear, with a simple loop and obvious control flow. However, generated-style names like _loop119 and _tokenSet_6 and the lack of comments or intent-revealing naming reduce readability and make purpose harder to infer outside its parser context.","tokens":630,"name":"115.jsnp"}
{"score":"78","reasoning":"Clear structure with early returns, consistent indentation, and descriptive helper calls. The main drawback is the confusing boolean semantics in combination with the method name, negations, and the SelfDirtinessTracker branch, which makes it harder to reason about true and false outcomes. Overall readable but could be clearer with improved naming and reduced negation.","tokens":907,"name":"111.jsnp"}
{"score":"78","reasoning":"Clear method and variable names and a simple loop make the code mostly readable. However, the long parameter list with repeated getter calls reduces clarity and maintainability. Extracting local variables or a helper object for the grouped arguments would make the code easier to understand.","tokens":605,"name":"105.jsnp"}
{"score":"78","reasoning":"Code has clear structure, consistent indentation, and descriptive names, making control flow mostly easy to follow. Readability is reduced by a very long combined dialect condition and many dense inline HQL query strings. Splitting the condition and extracting queries into helper methods would make the test easier to scan, understand, and maintain.","tokens":1556,"name":"68.jsnp"}
{"score":"91","reasoning":"Readable Java method with clear purpose explained in the comment, consistent indentation, and descriptive helper method names. Control flow is simple and linear. However, the method chains many operations in one long block, which makes it slightly harder to scan; extracting logical sections into smaller methods would help.","tokens":1438,"name":"149.jsnp"}
{"score":"93","reasoning":"Readable unit test with clear method and variable names. Structure is simple and intent is obvious. Uses standard assertions and helper methods that convey purpose. Minor drawback is reliance on external helper methods and domain specific classes, but overall the code is easy to understand and maintain.","tokens":913,"name":"159.jsnp"}
{"score":"94","reasoning":"Clear unit test with descriptive method and variable names, simple control flow, and consistent formatting. SQL strings are long but still understandable. Overall very readable and easy to follow.","tokens":707,"name":"24.jsnp"}
{"score":"88","reasoning":"Code is clearly structured with meaningful names and consistent formatting. The test flow of setup query assertion and cleanup is easy to follow. Use of raw types and suppression of unchecked warnings slightly reduces clarity but overall the method remains concise and readable.","tokens":1158,"name":"82.jsnp"}
{"score":"90","reasoning":"Clear JUnit test with descriptive names, logical structure, and consistent formatting, making the intent easy to follow. Use of Hibernate specific APIs adds slight domain overhead, but the control flow and assertions remain straightforward and readable overall.","tokens":810,"name":"178.jsnp"}
{"score":"85","reasoning":"Clear JUnit test with descriptive method name and straightforward control flow. Consistent indentation and naming aid comprehension. Minor drawbacks are the empty catch block without explanation and reliance on an external TIMEOUT constant not shown in the snippet. Overall it is very readable.","tokens":672,"name":"160.jsnp"}
{"score":"80","reasoning":"Good Javadoc and inline comments, clear parameter names and intent. Concurrency rationale is partially documented. However, the compare and set loops are written as terse for statements with trailing semicolons, which reduces readability and may confuse readers. Using clearer while loops with bodies would improve comprehension.","tokens":1074,"name":"62.jsnp"}
{"score":"85","reasoning":"Readable JUnit Hibernate test with clear structure and comments, logical flow of three sessions and straightforward assertions. SQL and entity names are explicit. Minor issues include very short variable name s, some duplication in session handling and a long SQL string inline. Overall it is easy to follow.","tokens":1429,"name":"72.jsnp"}
{"score":"92","reasoning":"Simple, well-documented method with clear control flow and descriptive boolean flags. Indentation and formatting are consistent and logic is easy to follow. Minor improvement could be adding brief field documentation for hasLf and hasCr, but overall readability is high.","tokens":680,"name":"6.jsnp"}
{"score":"93","reasoning":"Code is clear and easy to read. Method name and constant names convey intent, and the use of a Set plus unmodifiableSet expresses semantics well. Indentation is consistent. It could be slightly more concise using the diamond operator or a static import and possibly a factory like Set.of, but overall readability is high.","tokens":636,"name":"16.jsnp"}
{"score":"82","reasoning":"Code is short and well structured with clear naming and consistent indentation. Control flow is simple and comments clarify intent. Use of raw Stack type and casting slightly reduces clarity, and missing type info for mInterface and ffCodePiece limits immediate understanding.","tokens":1217,"name":"116.jsnp"}
{"score":"93","reasoning":"Code is very readable with clear JavaDoc, straightforward control flow, and descriptive names. Try catch structure is easy to follow and exception handling intent is clear. Minor verbosity with else after return and nested exception logic, but nothing that harms comprehension. Overall, it is simple, well structured, and easy to understand.","tokens":605,"name":"164.jsnp"}
{"score":"88","reasoning":"Code is clear and concise, with meaningful names and helpful comments. Logic is straightforward and follows a standard listener notification pattern. Slightly odd indentation and reliance on Object arrays demand some prior knowledge of the listener list structure, but overall readability and comprehension remain high.","tokens":879,"name":"9.jsnp"}
{"score":"75","reasoning":"Readable overall with clear control flow and consistent formatting. However uses vague variable names and duplicated facade calls and type checks that reduce clarity. Logic is straightforward but could be refactored for better abstraction and maintainability.","tokens":1174,"name":"119.jsnp"}
{"score":"88","reasoning":"Clear Javadoc and method name, straightforward structure and consistent formatting. The explicit per-byte assignments make the intent understandable, though they are repetitive and could be replaced by a simple loop to improve maintainability. Bit-level logic is correct but slightly verbose, reducing readability a bit compared to a more idiomatic implementation.","tokens":778,"name":"113.jsnp"}
{"score":"92","reasoning":"Code is concise and follows common Java hashCode style. Naming is clear, indentation readable, and logic easy to follow. Could be slightly improved by using a more conventional single expression pattern and handling of nulls via ternary, but overall comprehension is straightforward.","tokens":778,"name":"141.jsnp"}
{"score":"88","reasoning":"Well structured test code with clear naming, consistent indentation and limited complexity. Anonymous inner class and nested try blocks add some depth but remain understandable. Overall flow is easy to follow and control paths are explicit, with good use of conditionals and finally block, so readability is high.","tokens":794,"name":"173.jsnp"}
{"score":"82","reasoning":"Readable Java code with clear method and class names, consistent formatting and straightforward logic. Nested anonymous classes and inline overrides slightly obscure control flow, and the if else statement without braces reduces clarity and future maintainability.","tokens":825,"name":"132.jsnp"}
{"score":"94","reasoning":"Code is concise, well structured, and uses clear, descriptive names. Generic typing and JAXB usage are standard and predictable. Logical flow is easy to follow from schema loading to unmarshalling and wrapping in JaxbRoot. Minor improvement could be more explicit variable naming for in or stream, but overall readability is high.","tokens":606,"name":"194.jsnp"}
{"score":"86","reasoning":"Code is mostly readable with meaningful names and straightforward control flow. StringBuilder use is clear and join handling is logical. Readability is slightly hurt by long conditions on single lines, nested ternary logic, and use of raw List without generics.","tokens":1203,"name":"34.jsnp"}
{"score":"90","reasoning":"Code is well formatted with clear structure and descriptive names for method and variables. Test flow is linear and easy to follow, with assertions reflecting intent. Multiple annotations add some noise but are still readable. Overall logic is straightforward despite omitted domain class details.","tokens":1387,"name":"138.jsnp"}
{"score":"96","reasoning":"Very readable Java constructor configuring column types with descriptive method name and consistent formatting; no complex logic or nesting; clear mapping from SQL types to database types; minimal comments needed; easy to understand even without context","tokens":994,"name":"25.jsnp"}
{"score":"88","reasoning":"Clear method structure, descriptive calls and conditions, consistent indentation. Boolean expression for flush is slightly complex and flags like isDriver and isInitiator lack context, but overall logic is easy to follow.","tokens":995,"name":"184.jsnp"}
{"score":"82","reasoning":"Clear naming and control flow; event type ranges and listener type checks are explicit. However, nested if blocks and repeated casts and getEventType calls add verbosity and minor duplication. Refactoring into helper methods or a more centralized dispatch mechanism could further improve readability.","tokens":1033,"name":"43.jsnp"}
{"score":"84","reasoning":"Control flow is simple and indentation consistent. Variable and method names are mostly meaningful, though generic Object type and short names sel and d reduce clarity. Duplicate row selection logic could be refactored. Overall easily readable with small improvements possible.","tokens":968,"name":"10.jsnp"}
{"score":"88","reasoning":"Code is well structured and linear, using descriptive names and standard JUnit assertions. Indentation and spacing aid comprehension, and the intent of the test can be inferred without much effort. Lack of comments or higher level description is the main minor drawback, along with some very long type names.","tokens":1222,"name":"142.jsnp"}
{"score":"90","reasoning":"Code is well formatted and easy to follow, with clear method and variable names and straightforward control flow. Loops are simple, and the intent of validating parameter indices is obvious. Minor readability issues are long inline error strings and repeated size calls; extracting constants or helper methods could further clarify. Overall highly readable.","tokens":1604,"name":"14.jsnp"}
{"score":"90","reasoning":"Code is well structured and idiomatic Java, with clear naming, straightforward control flow, and focused responsibility. Exception handling is explicit and messages are informative. Use of reflection inherently adds some complexity and the final cast is unchecked, but overall the method remains easy to read and understand.","tokens":765,"name":"2.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear naming, simple control flow and focused test intent. Use of increment variable and explanatory comments makes the purpose obvious. Minor downsides are repeated casting to Long and slightly verbose assertions, but overall comprehension remains very easy.","tokens":1047,"name":"56.jsnp"}
{"score":"86","reasoning":"Code is clear and easy to follow, with descriptive names and straightforward control flow. Proper use of try finally ensures resource cleanup. Indentation and formatting are mostly consistent. Minor issues include somewhat long lines and a single line if without braces, but overall readability is good.","tokens":716,"name":"49.jsnp"}
{"score":"90","reasoning":"Clean Java Swing constructor with clear naming, consistent indentation and straightforward layout logic. Responsibilities are cohesive, no deep nesting, and method calls are self explanatory. Slight redundancy setting auto resize twice and minimal inline documentation, but overall very easy to read and understand.","tokens":748,"name":"118.jsnp"}
{"score":"68","reasoning":"Readable overall with a descriptive method name and consistent call pattern. However it is heavily repetitive with long lines and many hard coded boolean arrays, which makes it harder to quickly see the intent and coverage. Refactoring into loops or helper methods and documenting the combinations would improve clarity and maintainability.","tokens":859,"name":"59.jsnp"}
{"score":"90","reasoning":"Readable Java test with clear intent and descriptive names. Inner Verifier class and breadth first traversal are easy to follow. While loops and conditions are straightforward. Minor verbosity and use of Stack instead of modern Deque, but overall very understandable.","tokens":1341,"name":"87.jsnp"}
{"score":"92","reasoning":"Readable Java method with clear control flow and descriptive names. Indentation and structure are consistent and the exception handling logic is straightforward. Minor style issues like field naming prefix and inconsistent spacing around constructors, but they barely affect comprehension.","tokens":1632,"name":"125.jsnp"}
{"score":"88","reasoning":"Clear Java test method with descriptive variable and method names, straightforward control flow, and limited nesting. Hibernate session usage is linear and easy to follow. Comments explain a known limitation. Slight loss of clarity from framework specific details and absence of assertions, but overall very readable.","tokens":984,"name":"80.jsnp"}
{"score":"93","reasoning":"Clear test structure with descriptive method name, meaningful variable names and logical progression. Comments help explain purpose of each step. Query string is readable and filters are applied consistently. Minor issues are use of raw List and reliance on magic strings, but they do not hurt comprehension much.","tokens":1564,"name":"91.jsnp"}
{"score":"90","reasoning":"Code is well formatted and concise, with clear method and variable names, consistent indentation and straightforward control flow. Exception handling is explicit and the method is short and focused. Some domain specific chaining calls and the autodiscovertypes flag slightly reduce immediate readability but overall clarity remains high.","tokens":1382,"name":"33.jsnp"}
{"score":"90","reasoning":"Clear Javadoc and descriptive names make the logic easy to follow. Control flow is linear and indentation and spacing are good. Two nearly identical loops introduce some duplication but do not significantly harm comprehension. Use of raw Vector and explicit casts is somewhat dated, yet still easy to understand. Overall the method is highly readable.","tokens":1067,"name":"121.jsnp"}
{"score":"92","reasoning":"Clean and idiomatic equals implementation in Java. Uses early returns and an instanceof style check, variables are clearly named and casting is straightforward. Comment explains purpose and parameters. Very easy to read and understand. Could be slightly improved by considering floating point comparison nuances but overall readability is high.","tokens":1015,"name":"114.jsnp"}
{"score":"88","reasoning":"Clear intent and simple control flow with descriptive names. The long chained call with explicit cast slightly hurts readability, and the empty catch block that silently ignores exceptions can confuse maintainers. Overall still easy to follow with only minor style and formatting issues.","tokens":884,"name":"95.jsnp"}
{"score":"84","reasoning":"Clear naming and structure, with helpful comments referencing the JPA specification. Control flow is straightforward and guard clauses improve readability. Some duplication between the two loops and slightly confusing use of the field and property maps and log messages make it a bit harder to follow, but overall it remains easy to understand.","tokens":1415,"name":"27.jsnp"}
{"score":"90","reasoning":"Clear unit test structure, meaningful method and variable names, and proper transaction handling make the code easy to follow. The anonymous inner class and long chained calls slightly reduce readability, but overall the intent and flow remain straightforward.","tokens":884,"name":"94.jsnp"}
{"score":"88","reasoning":"Code is well structured and easy to follow, with descriptive names and clear null checks. Indentation and formatting are consistent, and branching is simple. Minor issues are the very long decorative comment, dependence on external metadata context, and the magic index zero in the sqlTypes array.","tokens":1079,"name":"147.jsnp"}
{"score":"95","reasoning":"Code is concise and follows the standard Java equals pattern with identity, superclass, class, and field checks. Readability is high and logic is straightforward. Naming is descriptive, though the class name is quite long. Unusual spacing around parentheses is slightly non idiomatic but does not significantly affect comprehension.","tokens":773,"name":"169.jsnp"}
{"score":"90","reasoning":"Clear formatting and naming, documentation comments, and simple loop based logic make the method easy to understand. Generic type with multiple bounds and nested try and finally blocks introduce some complexity but do not hinder comprehension much overall","tokens":1525,"name":"110.jsnp"}
{"score":"72","reasoning":"Readable indentation and clear field comparisons, but the long chained boolean expression is hard to scan, inconsistent use of array comparison approaches, commented out portions in the middle of the return, and many redundant parentheses reduce clarity and maintainability","tokens":1790,"name":"74.jsnp"}
{"score":"92","reasoning":"Code is concise, consistently formatted and uses descriptive class and method names, making control flow and intent easy to understand. Repeated calls follow the same clear pattern, aiding readability. Minor improvement could be made by reducing repetition via a helper method or data structure, but overall comprehension is straightforward.","tokens":670,"name":"171.jsnp"}
{"score":"90","reasoning":"Readable unit test with clear intent and well named entities. Comments explain purpose and edge cases. Consistent formatting and logical flow make it easy to follow. Minor issues are length of comments and need for Hibernate domain knowledge, but overall comprehension is straightforward.","tokens":1416,"name":"78.jsnp"}
{"score":"92","reasoning":"Code is concise and idiomatic JUnit. Method name explains purpose, listener logic is clear, and variable names are descriptive. Anonymous inner class is small and easy to follow. Only missing context is what fMax represents, but that does not harm readability much in this snippet.","tokens":728,"name":"124.jsnp"}
{"score":"92","reasoning":"Short and clear unit test with descriptive method and helper names. Indentation and structure make the assertion easy to follow despite nested calls. Domain specific class name is long but still understandable. Overall highly readable with minimal cognitive load.","tokens":701,"name":"165.jsnp"}
{"score":"90","reasoning":"Clear test method name and comments explain purpose, consistent formatting, straightforward SyntaxChecker usage and readable HQL strings, minimal nesting. Slight repetition and lack of explicit assertions or message text reduce clarity slightly, but overall the snippet is easy to follow.","tokens":1495,"name":"79.jsnp"}
{"score":"88","reasoning":"Clear Java method with consistent indentation and meaningful names. Control flow is simple and use of helper methods improves comprehension. Minor complexity due to domain specific terminology like queryableCollection and aliases, but overall easy to read.","tokens":798,"name":"182.jsnp"}
{"score":"72","reasoning":"Reasonable indentation and naming, but deep nested conditionals make the control flow hard to follow. Mixing domain logic with layer manipulation in a single method reduces cohesion. Comments interrupt the flow and are verbose. Some conditions are duplicated and the logic is coupled to external helpers, which slows comprehension.","tokens":986,"name":"155.jsnp"}
{"score":"90","reasoning":"Readable JUnit test with clear intent. Descriptive class and variable names, straightforward try catch structure, and explicit assertions make the flow easy to follow. Loop logic is simple and focused on one concern. Slight verbosity in boolean flags but it actually improves clarity. Overall, easy to understand and maintain.","tokens":1087,"name":"161.jsnp"}
{"score":"88","reasoning":"Clear method and parameter names, straightforward conditional logic, and consistent formatting. Early returns and enum comparisons help understanding. The compound if condition with multiple cases and inline comments is a bit dense, but overall the code is still easy to read and comprehend.","tokens":1036,"name":"29.jsnp"}
{"score":"90","reasoning":"Clear and consistent structure with descriptive class and variable names makes the code easy to follow. The sequence of operations is logical and indentation is good. However, there are no comments, no explicit intention revealing name for the method beyond context, and use of raw string literals without constants slightly reduces overall clarity.","tokens":1060,"name":"76.jsnp"}
{"score":"88","reasoning":"Clear equals implementation with standard identity and type checks and explicit null handling for fields. Readability is high though the ternary style null comparisons in if statements are slightly dense and the variable name cidDetailID could better match the field naming. Indentation and flow are straightforward.","tokens":914,"name":"70.jsnp"}
{"score":"92","reasoning":"Code is well structured and easy to follow with clear method and variable names, consistent indentation, and meaningful assert messages. Use of try catch finally and logging aids comprehension. Minor issues are raw Iterator type and slightly verbose exception handling.","tokens":1110,"name":"137.jsnp"}
{"score":"95","reasoning":"Very readable Java constructor delegating to another with default values. Javadoc and argument names are clear, inline comments explain booleans, and formatting is consistent. The only minor downside is the relatively long parameter list, but overall comprehension remains straightforward.","tokens":886,"name":"4.jsnp"}
{"score":"93","reasoning":"Code is concise and well structured with clear method and class naming and a focused test purpose. Javadoc explains intent and use of addFirstListener. Anonymous inner class override is simple and easy to follow. Minor missing context but overall highly readable.","tokens":1095,"name":"53.jsnp"}
{"score":"89","reasoning":"Readable Java method with clear purpose and structure. Informative comments outline the steps. Variable and method names are descriptive and the control flow is straightforward. Some domain specific Hibernate classes and methods may slow understanding for newcomers, but overall the code remains easy to follow.","tokens":843,"name":"66.jsnp"}
{"score":"88","reasoning":"Code is readable with clear intent, meaningful names, and straightforward control flow. Annotations and dialect handling are easy to follow. SQL strings are a bit dense and could be broken up for clarity, and the use of raw List without generics slightly harms readability. Overall structure and transaction handling are clear and consistent.","tokens":1056,"name":"71.jsnp"}
{"score":"94","reasoning":"Code is well formatted with consistent indentation and clear structure. Variable and class names are meaningful and domain specific. Comments explain the intent and relevant specification context. Control flow is linear and simple. Only minor issue is the short variable name s, but overall readability and comprehension are high.","tokens":1258,"name":"134.jsnp"}
{"score":"90","reasoning":"Code is concise and well structured, with clear method and variable names. Nested loops and helper methods make the control flow easy to follow, and the comment explains the sorting rationale. Long generic type declarations slightly reduce readability but overall comprehension remains high.","tokens":1236,"name":"52.jsnp"}
{"score":"92","reasoning":"Descriptive test name and helpful comments give clear intent. Structure is linear and easy to follow, with well named variables and explicit setup and teardown. Use of try catch and assertions is clear. Requires some Hibernate domain knowledge, but overall readability and comprehension are high.","tokens":1113,"name":"75.jsnp"}
{"score":"85","reasoning":"Code is clear and consistent, with explicit null checks and standard use of collections, making behavior easy to infer. However, long ternary expressions and repeated generic initializations hurt readability slightly and might be improved by extracting helper methods or breaking statements across lines with clearer naming.","tokens":849,"name":"196.jsnp"}
{"score":"82","reasoning":"Readable JUnit test with clear setup and teardown. Human readable variable names and straightforward sequence of HQL queries make intent understandable. However, long inline query strings, repeated reassignment to a raw List without generics, and no spacing or comments make quick scanning and maintenance harder.","tokens":1287,"name":"83.jsnp"}
{"score":"88","reasoning":"Readable Java constructor with clear, consistent listener naming and straightforward initialization. The event registration calls are logically grouped and easy to follow. Slightly reduced score due to an implicit cast and lack of brief contextual comments.","tokens":717,"name":"139.jsnp"}
{"score":"82","reasoning":"Readable Java method with clear intent, collecting various related elements into a set. Simple control flow and meaningful names aid comprehension. Readability could be improved by using generics, avoiding repeated Model.getFacade calls, and returning an empty set instead of null when parent is not a class.","tokens":680,"name":"123.jsnp"}
{"score":"90","reasoning":"The code is short and clearly structured. Method and variable names are descriptive, and the test intent is easy to infer from the assertions and transaction lifecycle. Indentation and spacing are consistent. A minor drawback is the lack of an explicit final assertion about flush mode behavior, which slightly obscures the test purpose, but readability remains high.","tokens":557,"name":"128.jsnp"}
{"score":"92","reasoning":"Code is concise and well structured, with clear method and helper names, good indentation, and comments that explain each case. Control flow is straightforward and easy to follow. The main drawback is the use of magic numeric SQL state values instead of named constants, but overall readability and comprehension remain high.","tokens":899,"name":"22.jsnp"}
{"score":"90","reasoning":"Clear structure, good naming and indentation, simple control flow and try finally for cleanup. Anonymous Thread class is slightly verbose compared to using a Runnable or lambda, and the inlining comment could distract a bit, but overall it is easy to read and understand.","tokens":759,"name":"1.jsnp"}
{"score":"87","reasoning":"Clear structure and consistent indentation, expressive method and class usage, and straightforward control flow make it easy to follow. Minor drawbacks are single letter variables like s and st, long annotation comment, and the lowercase l in -3l which can be confusing. Overall highly readable.","tokens":1313,"name":"69.jsnp"}
{"score":"85","reasoning":"Clean Java code with clear branching and descriptive method calls. Indentation and spacing are consistent, and conditions are straightforward. Some nested if blocks and duplicated normalization logic slightly reduce clarity, but overall the flow is still easy to follow and maintain.","tokens":860,"name":"30.jsnp"}
{"score":"82","reasoning":"Code is fairly readable with clear method intent, simple control flow and descriptive variable names. Use of inSection flag and repeated getSectId calls is understandable but could be refactored for clarity. String concatenation in loop and while condition pattern make logic slightly harder to follow but still easy overall.","tokens":875,"name":"48.jsnp"}
{"score":"86","reasoning":"Clear purpose with javadoc, simple control flow and good use of caching. Indentation and structure are clean. However, use of raw types, vague variable names like cls, intfs, clazz and chlist, and lack of generics or stronger typing reduce clarity slightly. Overall still easy to follow for a Java developer.","tokens":1221,"name":"44.jsnp"}
{"score":"90","reasoning":"Readable JUnit test with clear intent and consistent formatting. Variable names and assertion structure make the cache behavior easy to follow. However, the long sequence of nearly identical blocks and the explicit cast to Hibernate specific classes reduce ideal clarity slightly.","tokens":1249,"name":"162.jsnp"}
{"score":"92","reasoning":"Clear JavaDoc, descriptive method and parameter names, straightforward control flow, consistent formatting and use of helper methods make the code easy to read. Limited branching and explicit exception improve comprehension. Minor TODO note and lack of more specific exception detail slightly reduce perfection.","tokens":839,"name":"32.jsnp"}
{"score":"90","reasoning":"Clear unit test with good structure and naming. Session lifecycle and assertions are easy to follow. Use of a raw List instead of generics and repeated openSession and transaction blocks slightly reduce clarity, but overall the code is straightforward and readable.","tokens":869,"name":"77.jsnp"}
{"score":"90","reasoning":"Code is well structured and easy to follow, with a descriptive test name, clear separation between entity and collection checks, and straightforward assertions. Indentation and naming are consistent. Readability could improve by reducing magic numbers and very long property key literals.","tokens":1624,"name":"130.jsnp"}
{"score":"88","reasoning":"Readable JUnit test with clear assertions, descriptive method and variable names, and consistent formatting. The transactional state progression is straightforward to follow. Slightly verbose and tightly coupled to framework-specific helpers and side effects like using getFlushMode to trigger behavior, which requires some prior framework knowledge.","tokens":857,"name":"127.jsnp"}
{"score":"90","reasoning":"Clear small unit test, descriptive method name and comments explain intent. Consistent indentation and repeated parse calls keep structure simple. The series of queries is easy to scan. One commented parse line slightly adds noise but overall readability and comprehension are high.","tokens":1465,"name":"86.jsnp"}
{"score":"68","reasoning":"Code is structurally simple and short with clear control flow. Indentation is consistent and the method purpose is fairly evident. However, use of raw types, vague variable names like res and cr, and the obsolete Vector class reduce clarity. Lack of generics and documentation also harms overall readability and ease of comprehension.","tokens":814,"name":"120.jsnp"}
{"score":"80","reasoning":"The method is straightforward and structured, with clear switch cases and matchRange calls, making the intent of matching hexadecimal digits obvious. Indentation and grouping of character ranges aid readability. However, autogenerated-style names like _ttype and _token and lack of comments reduce clarity slightly.","tokens":1028,"name":"117.jsnp"}
{"score":"93","reasoning":"Clean concise method with descriptive names and clear intent. Uses a strategy object and builder in a straightforward way. Indentation and formatting are consistent and there is no complex logic, making the code easy to read and maintain.","tokens":1127,"name":"143.jsnp"}
{"score":"93","reasoning":"Clear and idiomatic Java equals implementation with good structure and Javadoc. Variable names are meaningful, null handling is explicit, and control flow is straightforward. Nesting is minimal and logic is easy to follow. Only minor improvement could be slight refactoring or comments for intent, but overall readability and comprehension are very high.","tokens":752,"name":"40.jsnp"}
{"score":"93","reasoning":"Java method is clear and concise. Javadoc explains purpose and parameters. Method body uses consistent naming and delegation to helper methods, one concern per line. No complex logic, easy to follow. Overall very readable serialization code.","tokens":1007,"name":"38.jsnp"}
{"score":"90","reasoning":"Code is short and straightforward, with clear output structure and simple concatenations. Readability is high due to meaningful method and variable usage and consistent formatting. Minor improvements could include using a logging framework and extracting repeated separator strings, but overall it is easy to understand.","tokens":778,"name":"144.jsnp"}
{"score":"87","reasoning":"Clear naming and structure with helpful Javadoc and logging. Control flow is simple with early returns. Use of generics and downcasting adds some complexity but is still readable. Domain specific types may slow understanding for newcomers, yet overall the method remains concise and easy to follow.","tokens":1246,"name":"84.jsnp"}
{"score":"89","reasoning":"Code is short and straightforward with clear purpose and consistent naming. Lazy initialization of the static collection is easy to follow, and each added element is explicit and readable. Readability is slightly reduced by lack of generics and use of legacy Vector instead of modern collections, but overall comprehension remains high.","tokens":876,"name":"45.jsnp"}
{"score":"65","reasoning":"Structure and indentation are clear and the cleanup sequence is logically grouped, making the control flow easy to follow. However, the use of single-letter class and variable names greatly reduces semantic clarity, and the repeated association removals and deletes could be refactored into helper methods to improve readability and maintainability.","tokens":1075,"name":"200.jsnp"}
{"score":"82","reasoning":"Code is mostly readable with clear method and variable names and a logical structure for parsing options. The use of early returns for remaining arguments is easy to follow. Readability is reduced by nested conditionals, a try block covering the whole loop body, and manual index manipulation inside the loop, which make reasoning about control flow slightly harder.","tokens":1030,"name":"15.jsnp"}
{"score":"94","reasoning":"Clean, well structured test using criteria api. Indentation and spacing are consistent, names are descriptive, and control flow is straightforward, making the intent easy to follow. A brief comment clarifies the correlated subquery. Overall high readability with minimal cognitive load and no confusing constructs.","tokens":1320,"name":"163.jsnp"}
{"score":"82","reasoning":"Readable JUnit test with clear intent and comments. Method name and annotations explain purpose and the flow is linear. The variable name it is vague and hardcoded values and a minor typo in the assertion message reduce clarity slightly. Overall, behavior remains easy to understand.","tokens":823,"name":"179.jsnp"}
{"score":"90","reasoning":"JUnit test is concise and well structured. Repeated assertion pattern makes intent easy to follow, and descriptive method and entity names aid understanding despite being verbose. Excessive line breaks and long class identifiers slightly reduce readability, but the logic remains straightforward and clear overall.","tokens":859,"name":"185.jsnp"}
{"score":"90","reasoning":"The method is clear and consistent, using a StringBuilder with chained appends and a well defined structure for the output. Indentation and naming are good and each field is explicitly labeled, which aids comprehension. It is slightly verbose and could be simplified with a more compact formatting approach, but overall readability is high.","tokens":610,"name":"63.jsnp"}
{"score":"82","reasoning":"Code is readable with clear method and variable names and consistent indentation. Control flow is straightforward although nested conditionals for tooltip handling add some complexity. Commented out lines slightly distract but overall logic is easy to follow and side effects are localized.","tokens":1081,"name":"122.jsnp"}
{"score":"86","reasoning":"Clear control flow and descriptive names make the method easy to follow. The handling of model elements and expressions is consistent and straightforward. Readability could improve by using generics, enhanced for loops, clearer null or empty handling helpers, and avoiding shared mutable buffers and raw collection types.","tokens":868,"name":"8.jsnp"}
{"score":"90","reasoning":"Code is clean and well structured, with clear type based branches, descriptive variable names and consistent indentation. Control flow is straightforward and each case is easy to follow. Minor improvements could be extracting nested logic or adding brief documentation, but overall readability and comprehension are high.","tokens":821,"name":"54.jsnp"}
{"score":"78","reasoning":"Clear structure and naming with proper indentation and logical flow. Conditions are understandable and side effects are explicit. However, use of a raw List without generics, tight coupling to specific framework classes and somewhat dense nested logic reduce readability for less experienced readers, though it remains reasonably clear for seasoned Java developers.","tokens":1168,"name":"109.jsnp"}
{"score":"88","reasoning":"Clear unit test structure, descriptive method name and sequential asserts make the logic easy to follow. Indentation and spacing are good. However, repetitive blocks could be refactored into a loop, comments are somewhat noisy, and unnecessary casts slightly reduce clarity.","tokens":1147,"name":"17.jsnp"}
{"score":"88","reasoning":"Clear and consistent Java style, descriptive method and variable names, straightforward control flow and small method size make it easy to understand. Minor verbosity with explicit boolean flags and repeated checks, but it actually aids readability. Overall the code is highly readable and maintainable.","tokens":1123,"name":"195.jsnp"}
{"score":"86","reasoning":"Code is concise and uses clear names for methods and variables, structured try finally blocks, and explicit expectations for exception handling. Indentation is consistent and logic is easy to follow. Slightly reduced readability due to nested try catch and minimal documentation of test intent.","tokens":1061,"name":"129.jsnp"}
{"score":"82","reasoning":"Code is mostly readable with clear intent and decent naming, though use of raw Object and Collection types, duplicate logic in both branches, and the questionable string equality checks reduce clarity and make reasoning about behavior slightly harder. Overall structure and indentation still keep it fairly easy to follow.","tokens":1452,"name":"154.jsnp"}
{"score":"76","reasoning":"Readable Java method with clear structure and descriptive names. Try catch and error messages aid understanding. However, the repeated call to getSqlTypeCode inside the same method is confusing and may suggest unintended recursion or tight coupling to external state, which reduces clarity. Overall logic remains straightforward for experienced readers.","tokens":1057,"name":"37.jsnp"}
{"score":"88","reasoning":"Code is clean and consistently indented, method and variable names are descriptive, and control flow is straightforward with two clear loops. Use of domain specific types and nested method calls adds some cognitive load, but overall structure remains readable and maintainable.","tokens":1503,"name":"197.jsnp"}
{"score":"88","reasoning":"Clear if else structure with descriptive constant names and concise exception messages. Repeated patterns and a long conditional chain slightly hurt readability, and minor spacing issues exist, but overall the logic is simple and easy to understand.","tokens":1500,"name":"108.jsnp"}
