{"score":"88","reasoning":"Clear Java code with meaningful method names, consistent formatting, and straightforward control flow. Null and state checks are explicit and exceptions are appropriate. Field names with leading underscores are still descriptive. Lack of comments and reliance on external utility methods for behavior slightly reduce immediate comprehensibility.","tokens":963,"name":"131.jsnp"}
{"score":"88","reasoning":"Code is concise and clearly structured with meaningful class and method names and standard imports. Indentation is consistent and actions are self explanatory. The use of a descriptive test method name aids understanding. The snippet is truncated, which slightly limits full comprehension of flow, but overall readability remains high","tokens":705,"name":"191.jsnp"}
{"score":"82","reasoning":"Code is fairly readable with meaningful method and variable names, consistent formatting and comments explaining purpose. Use of raw collections, casts and reused parameter_group list slightly hurts clarity. Control flow in the listener is simple and easy to follow, so overall it is easy to understand for Java developers.","tokens":1315,"name":"106.jsnp"}
{"score":"97","reasoning":"Code is extremely readable with clear and consistent getter and setter methods, well named parameters, and complete JavaDoc comments describing purpose and usage. Indentation and formatting are standard, making comprehension immediate even without broader context. Overall, the snippet adheres closely to common Java style conventions.","tokens":713,"name":"136.jsnp"}
{"score":"90","reasoning":"Readable Java utility methods with consistent null and state checks, clear naming and straightforward control flow. Logging aids understanding. Some repetition of initialization checks could be refactored into a helper to improve clarity and reduce duplication, but overall comprehension is easy.","tokens":964,"name":"116.jsnp"}
{"score":"88","reasoning":"Code is short and clear, with descriptive names and straightforward logic. Indentation and formatting are good. The commented assignment in the constructor slightly reduces clarity because the parameter is unused, but overall readability and comprehension remain high.","tokens":623,"name":"181.jsnp"}
{"score":"80","reasoning":"Readable Java snippet with clear intent using constants and a utility method. Indentation is consistent, though nested calls and verbose line wrapping make it slightly harder to follow. Naming is adequate and types are explicit.","tokens":909,"name":"133.jsnp"}
{"score":"88","reasoning":"Overall readability is high with descriptive class and method names and clear Selenium actions. Indentation and structure follow common Java testing patterns, making the flow easy to follow. However, the manual timeout loop with an empty catch block could be refactored into a helper or use built-in wait utilities to improve clarity and intent.","tokens":768,"name":"212.jsnp"}
{"score":"78","reasoning":"Readable polling logic with clear intent and straightforward control flow. Variable naming and structure are understandable. However, there is some duplication, use of magic numbers for timeouts, and empty catch blocks that reduce clarity and maintainability. Overall it remains fairly easy to comprehend.","tokens":723,"name":"146.jsnp"}
{"score":"85","reasoning":"Readable Java Swing snippet with clear method names and straightforward control flow. Use of null checks, revalidate, and repaint is easy to follow. Minor issues include an apparent truncated assignment at the start, one misaligned line, and no comments or class context, which slightly reduce overall clarity.","tokens":814,"name":"170.jsnp"}
{"score":"80","reasoning":"Structure and naming are mostly clear, with consistent formatting and straightforward logic that support readability. Use of constants like UPDATE_DIR and ACTIONS helps comprehension. However comments are sparse, some names such as class_mon are slightly cryptic, and the partial snippet prevents seeing full method flow, which slightly reduces overall clarity.","tokens":1007,"name":"151.jsnp"}
{"score":"88","reasoning":"Clear Java code with meaningful variable names and structured logging. Database and upgrade logic are separated into readable blocks. Proper use of utility methods and early return improves comprehension. Minor verbosity in string concatenation, but this does not significantly hinder readability.","tokens":1044,"name":"103.jsnp"}
{"score":"93","reasoning":"Code is very readable, with clear method names and standard override implementations of equals and hashCode. Formatting and naming are consistent, and logic is straightforward. Minor indentation inconsistency does not significantly affect comprehension.","tokens":918,"name":"150.jsnp"}
{"score":"82","reasoning":"Code is well structured with clear indentation and descriptive variable names. Control flow is straightforward and consistent with typical Java web patterns. Some context is missing due to snippet cut, but overall readability and comprehension are good.","tokens":873,"name":"186.jsnp"}
{"score":"60","reasoning":"Code intent is somewhat clear due to descriptive names, but the snippet is incomplete with a stray closing brace, uses a raw xpath string, and has an empty catch of generic Exception, all of which reduce readability and make behavior harder to understand","tokens":857,"name":"192.jsnp"}
{"score":"68","reasoning":"Variable names and overall structure are understandable and indentation is consistent. However, heavy use of long XPaths as string literals, repeated blocks, and missing surrounding context with label and case logic reduce readability and make intent less obvious.","tokens":1204,"name":"152.jsnp"}
{"score":"88","reasoning":"Code is well structured with clear class and field names, consistent indentation, and appropriate use of constants for internationalized strings. The i18n interface pattern is slightly unusual but still understandable. Overall the snippet is concise and easy to follow, supporting good readability and low cognitive load for maintainers.","tokens":932,"name":"172.jsnp"}
{"score":"88","reasoning":"Readable Java code with clear try catch structure and consistent error handling. Method names are descriptive and indentation is correct, making control flow easy to follow. The main drawback is repeated boilerplate across methods, which reduces conciseness but not understanding.","tokens":868,"name":"140.jsnp"}
{"score":"92","reasoning":"Clear Java service methods with descriptive names and consistent indentation. For each loop and direct calls to the persistence layer make the logic easy to understand. No complex control flow or nesting, and method responsibilities are obvious. Lack of comments is acceptable here because the intent is straightforward and the code remains easy to read.","tokens":868,"name":"153.jsnp"}
{"score":"90","reasoning":"Code is very readable with clear naming, simple constructors and accessor methods, and consistent formatting. Fully qualified type names add some verbosity but not confusion. Overall structure is easy to follow and there is no complex logic, so comprehension is straightforward.","tokens":884,"name":"188.jsnp"}
{"score":"92","reasoning":"Clear Java style with descriptive names, consistent indentation and helpful Javadoc. Constructor parameters map directly to fields, logic is straightforward, and accessors are simple. Minor omissions in documentation for some parameters and slight redundancy in comments, but overall very easy to understand.","tokens":1096,"name":"221.jsnp"}
{"score":"92","reasoning":"The code is highly readable with clear variable and method names, straightforward control flow, and consistent formatting. The try catch around getGroup and the layout set selection logic are easy to follow. Exception handling is simple, returning a default, which is conceptually clear. Overall, minimal nesting and standard accessor patterns make comprehension easy despite missing surrounding class context.","tokens":981,"name":"101.jsnp"}
{"score":"85","reasoning":"Code has clear control flow and indentation with meaningful variable names and simple conditions. Use of the domain macro BETTER_THAN is understandable. Overall logic is easy to trace though comments and slightly more descriptive names could improve readability further.","tokens":1047,"name":"112.jsnp"}
{"score":"78","reasoning":"Linear Selenium test flow is easy to follow, with clear sequencing, consistent indentation and descriptive method names that make the intent understandable. However, readability suffers from long hard coded xpath expressions and file paths, repeated waits with magic constants, lack of comments, and no reuse via helper methods or constants, which hinders maintainability.","tokens":1376,"name":"198.jsnp"}
{"score":"88","reasoning":"Code is clear and readable with descriptive method names and straightforward control flow. The wait loop is explicit, though a helper method could improve reuse. Exception handling is minimal but understandable. Overall structure is easy to follow despite the snippet being incomplete.","tokens":1059,"name":"209.jsnp"}
{"score":"88","reasoning":"Code is concise and easy to follow, with clear method and variable names and straightforward control flow. Caching logic is simple and well structured. Readability is slightly reduced by use of a raw Map type without generics, a broad Exception catch, and some commented out legacy code, but overall comprehension remains high.","tokens":1216,"name":"166.jsnp"}
{"score":"78","reasoning":"The code is mostly readable with clear indentation and descriptive method names. Use of selenium and wait loop is easy to follow. However, the switch with a label based while loop is unusual and harms clarity, especially without comments describing the control flow intent. The snippet is incomplete, which also impacts overall comprehension and context.","tokens":680,"name":"102.jsnp"}
{"score":"88","reasoning":"Readable comment header with clear plugin description and standard structure. Imports are straightforward and there is no logic to follow, so comprehension is easy. However, the long legal block adds verbosity and offers little guidance about actual behavior, slightly reducing overall clarity.","tokens":1023,"name":"190.jsnp"}
{"score":"94","reasoning":"Clear sequential setter usage and simple compareTo implementation. Names are descriptive and style is consistent, making intent obvious. No complex branching and the flow is straightforward. Minor redundancy in compareTo using an extra variable instead of returning directly, but this hardly affects readability.","tokens":917,"name":"183.jsnp"}
{"score":"88","reasoning":"Code is short and clear, with descriptive class and method names, standard JUnit style, and consistent indentation. Responsibilities are obvious and logic is simple. However the snippet is incomplete and lacks closing braces and more detailed comments, which slightly reduces overall readability.","tokens":950,"name":"207.jsnp"}
{"score":"88","reasoning":"The code is short and clear, with descriptive method and parameter names and standard Java style, making it easy to understand. The Javadoc for getServiceName is helpful, though the snippet appears truncated with a stray closing comment and lacks documentation for setGadgetKey, which slightly reduces overall readability.","tokens":1078,"name":"168.jsnp"}
{"score":"78","reasoning":"Straightforward Java persistence logic with clear method calls and reasonable naming. Control flow in try catch finally is standard and easy to follow. Lack of comments and context around variables slightly reduces clarity, but overall the code is readable and consistent","tokens":784,"name":"202.jsnp"}
{"score":"90","reasoning":"Clear variable names and formatting make the snippet easy to read. Using a helper to build fieldsMap aids comprehension. The main drawback is the long updateFileEntry parameter list, which makes it harder to see what each argument represents. Overall the code is concise, consistent with Java style, and quickly understandable.","tokens":996,"name":"135.jsnp"}
{"score":"86","reasoning":"Readable test code with clear method names and intent. Framework utilities are used in a straightforward way and variable names are descriptive. Some statements are long and compressed which slightly reduces scanability, but control flow and expectations remain easy to understand overall.","tokens":1272,"name":"204.jsnp"}
{"score":"78","reasoning":"Readable Selenium Java test code with clear action sequence and understandable variable names. Indentation is acceptable and conditions are simple. Use of magic strings and cryptic element identifiers plus label based control flow lower clarity. Absence of comments and helper methods slightly hurts overall comprehension","tokens":1247,"name":"193.jsnp"}
{"score":"72","reasoning":"Code is mostly straightforward with clear method calls and a descriptive boolean name. However, it relies on hard coded string selectors and magic timeout values, and uses a label with continue which reduces clarity. The manual wait loop is somewhat verbose. Overall understandable but the control flow and constants could be cleaner.","tokens":988,"name":"157.jsnp"}
{"score":"95","reasoning":"Very readable concise Java code with descriptive names clear intent and simple logic using a standard command pattern Only two short methods easy to follow and consistent formatting No unnecessary complexity Minor improvement could include comments or documentation for additional context","tokens":726,"name":"104.jsnp"}
{"score":"92","reasoning":"Clear naming, straightforward control flow, and consistent formatting make the code easy to understand. Permission checks follow a simple, repeated pattern, aiding comprehension. Overall complexity is low. Some additional documentation about business rules and potential edge cases could further improve clarity, but readability is already high.","tokens":1056,"name":"175.jsnp"}
{"score":"86","reasoning":"The code is well indented and uses clear try catch blocks and straightforward conditional checks. Naming of variables and methods is descriptive, aiding comprehension. Exception handling paths are explicit and use consistent patterns. Domain specific classes may require context, but overall readability and structure are good and easy to follow.","tokens":724,"name":"111.jsnp"}
{"score":"82","reasoning":"Clear Java snippet with consistent indentation and naming. Logic is straightforward and synchronized usage is obvious. However the code is partial, lacks comments and missing braces in the excerpt, and uses leading underscore style that may reduce clarity for some readers.","tokens":686,"name":"156.jsnp"}
{"score":"82","reasoning":"Clear Java test code with consistent formatting and descriptive method names. Control flow is straightforward, and Selenium actions are easy to follow. Readability is reduced by duplicated wait loops, magic numbers for timeouts, and reliance on Thread.sleep, but overall comprehension remains good.","tokens":1109,"name":"145.jsnp"}
{"score":"82","reasoning":"Code is linear and uses descriptive selenium calls, so the flow is easy to follow. Repeated waits and JavaScript loader calls are explicit but could be abstracted. The polling loop with a magic timeout and empty catch reduces clarity. Overall reasonably readable, though somewhat verbose and repetitive.","tokens":1026,"name":"167.jsnp"}
{"score":"40","reasoning":"Indentation is inconsistent, empty catch block hides errors, magic sleep call and complex locator reduce clarity despite short code.","tokens":1068,"name":"174.jsnp"}
{"score":"85","reasoning":"Method names are descriptive and the Javadoc clearly explains getBadNATCount, making the intent easy to understand. The snippet is short and straightforward. Minor style issues, such as the odd line break between int and getBadNATCount and the absence of a comment for getLeecherCount, slightly reduce overall readability.","tokens":912,"name":"126.jsnp"}
{"score":"82","reasoning":"Readable Java snippet with clear names and straightforward control flow. Indentation and braces are consistent. Some redundancy in the conditional setting of loadProcedures and repeated constant comparisons adds minor noise. Overall easy to follow, though it could be simplified and slightly refactored to improve clarity further.","tokens":1018,"name":"187.jsnp"}
{"score":"90","reasoning":"Clean Java test suite code with descriptive class and method names and good indentation. The intent of assembling a test suite from LoginTests and TagsTestPlan is immediately clear. Minor issue is that the snippet is incomplete and missing closing braces and context, which slightly reduces overall clarity.","tokens":1005,"name":"176.jsnp"}
{"score":"90","reasoning":"Clear naming, small focused test suite method, consistent formatting, but missing closing braces in the snippet and lacks comments or documentation about test purpose, still very easy to follow.","tokens":807,"name":"199.jsnp"}
{"score":"86","reasoning":"Method signatures are well structured and consistently formatted, with clear parameter names and Javadoc for each variant. Alignment with tabs aids scanning, and comments hint at valid encoding types and constraints. Slight issues are the duplicated method name with overloads and somewhat generic names like resource_name and encoding_type.","tokens":1114,"name":"201.jsnp"}
{"score":"78","reasoning":"Clear indentation and naming but the label and case based control flow reduce clarity Empty catch block and manual timeout loop without explanation also hurt readability but the overall intent remains understandable","tokens":841,"name":"217.jsnp"}
{"score":"78","reasoning":"Readable Selenium Java test with consistent indentation and clear method calls. However uses magic numbers for timeouts and page loads, an empty catch block, and a manual polling loop instead of higher level waits. Long chained calls and labels reduce readability. Overall understandable but not very polished.","tokens":1090,"name":"107.jsnp"}
{"score":"80","reasoning":"Overall readability is good, with descriptive test names, clear loops, and straightforward assertions. Exception handling intent is understandable, though relying on comments in empty catch blocks is not ideal. Indentation is somewhat inconsistent and the snippet starts and ends mid method, which slightly hurts immediate comprehension.","tokens":718,"name":"178.jsnp"}
{"score":"90","reasoning":"Very readable snippet with clear naming and formatting. Constants are self descriptive and the structure is simple. Missing closing braces and broader context of how the keys are used makes overall understanding slightly less complete but still easy to follow","tokens":999,"name":"189.jsnp"}
{"score":"96","reasoning":"Code is very readable and straightforward. Method names clearly express intent, parameters are well chosen, and delegation to the underlying service is obvious. Formatting and indentation are standard and consistent. The only minor drawbacks are the verbose fully qualified class names and the underscore in the field name, but they do not significantly impact comprehension.","tokens":530,"name":"214.jsnp"}
{"score":"92","reasoning":"Method names are clear and self explanatory, using consistent Java naming conventions and appropriate return types. The absence of parameters keeps the signatures simple and easy to understand. Minor formatting issues with line breaks slightly impact readability, and there is no documentation or context, but overall the snippet is very easy to comprehend.","tokens":536,"name":"158.jsnp"}
{"score":"82","reasoning":"Code is concise and uses meaningful names, selenium actions are clear and structure is standard. Use of label variable suggests goto style control flow and slightly reduces clarity. Missing surrounding context and comments limit full understanding, but within this snippet readability and intent are generally easy to follow.","tokens":814,"name":"149.jsnp"}
{"score":"78","reasoning":"Simple control flow and clear intent make the code fairly easy to follow. Indentation and brace usage are mostly consistent. However, variable names like temp and changed are vague, comments are poorly formatted, and string concatenation in a loop is not ideal. Overall readability is acceptable but could be improved with better naming and structure.","tokens":817,"name":"115.jsnp"}
{"score":"86","reasoning":"Java test code is well formatted with clear naming, consistent indentation and straightforward control flow. Use of selenium.open and the timeout loop is easy to follow. However, the infinite for loop with manual sleep and an empty catch block is slightly less expressive and could be refactored for clarity, so readability is very good but not perfect.","tokens":939,"name":"203.jsnp"}
{"score":"90","reasoning":"Code is clean, well formatted, and uses a meaningful interface name with clear documentation, making it easy to read and understand structurally. However, the snippet is incomplete and the interface has no methods, so comprehension of its intended behavior is limited, slightly reducing overall clarity.","tokens":841,"name":"160.jsnp"}
{"score":"62","reasoning":"Indentation and structure make the try block and conditional break easy to follow, and method names are reasonably descriptive. However, the empty catch block hides potential errors, and the missing surrounding loop or method context makes the purpose of the break and sleep less clear, reducing overall readability and comprehension.","tokens":748,"name":"105.jsnp"}
{"score":"95","reasoning":"Snippet contains only standard Java import statements with clear package names and consistent formatting. No complex logic is present, so readability and comprehension are very high, though context is limited because it is only a fragment.","tokens":877,"name":"208.jsnp"}
{"score":"78","reasoning":"The code is generally readable: it uses descriptive class and method names, clear selenium actions, and a recognizable wait loop pattern with a timeout and fail call. However, indentation is partially visible only, comments are missing, and the snippet ends abruptly, reducing overall clarity and context for the reader.","tokens":454,"name":"114.jsnp"}
{"score":"82","reasoning":"The snippet is easy to understand: Java style, clear method name and parameter, and a concise Javadoc describing purpose and argument. However, the formatting is awkward, with the method signature split across multiple lines in an unusual way, and the snippet is incomplete contextually, which slightly hurts readability and flow.","tokens":533,"name":"118.jsnp"}
{"score":"75","reasoning":"Clear method responsibilities and helpful javadoc comment aid understanding. Naming is meaningful and logic is straightforward. Readability is reduced by unconventional line breaks, dense regular expressions, and commented debug statements left in place.","tokens":1508,"name":"177.jsnp"}
{"score":"82","reasoning":"Code is mostly readable with clear indentation and descriptive names, and the control flow around preview generation and cleanup is easy to follow. However, empty catch blocks hide potential errors and require readers to infer missing behavior. Reliance on framework specific utilities without comments slightly reduces immediate comprehensibility.","tokens":1278,"name":"180.jsnp"}
{"score":"90","reasoning":"Simple Java method declarations with clear naming and a familiar getter and setter pattern. The structure is concise and easy to follow. A small drawback is the oddly spaced term class p k in the comments, which slightly reduces clarity, but overall the snippet remains highly readable and understandable.","tokens":715,"name":"141.jsnp"}
{"score":"88","reasoning":"Clear Java interface with descriptive Javadoc and consistent formatting. Method names and parameters are self explanatory. Minor issues are small typos in comments and slight mismatch between cipher and MAC terminology, but overall readability and comprehension are high.","tokens":1154,"name":"184.jsnp"}
{"score":"76","reasoning":"Code is mostly clear, with consistent indentation and understandable control flow and Selenium calls. The wait loop pattern is recognizable. Readability suffers from magic numbers for timeout and sleep, duplicated locator strings, and an empty catch block, which hinder clarity, error handling, and maintainability.","tokens":945,"name":"113.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear method names, generic typing, and consistent formatting. Variable names and control flow are straightforward, with minimal nesting and obvious intent. JavaDoc and type bounds support comprehension. Slight deduction because the snippet is incomplete and business rules are not explicitly documented.","tokens":945,"name":"119.jsnp"}
{"score":"78","reasoning":"Straightforward Java methods with clear intent and simple control flow, making the snippet easy to follow. Names are mostly understandable, but leading underscores for members reduce clarity. The snippet appears structurally incomplete, with missing closing braces and context, which slightly harms readability and overall comprehension.","tokens":623,"name":"132.jsnp"}
{"score":"98","reasoning":"Very clear and readable Java setter method with descriptive name and proper Javadoc comment. The parameter name matches the field, and indentation and formatting follow common conventions. There is no complex logic, making it easy to understand at a glance.","tokens":605,"name":"161.jsnp"}
{"score":"92","reasoning":"Clear, concise JUnit style test. Method and variable names describe intent well, control flow is linear, and spacing and formatting are consistent. External helper methods are not shown but their purpose is obvious from naming, so comprehension remains easy.","tokens":1513,"name":"159.jsnp"}
{"score":"80","reasoning":"Clear structure and indentation with straightforward selenium flows and waits. However, duplicated polling loops, magic numbers for timeouts, empty catch blocks, and unwrapped locator strings reduce readability and maintainability. Extracting wait logic and constants would improve comprehension.","tokens":887,"name":"110.jsnp"}
{"score":"72","reasoning":"Sequential flow and assertions are straightforward and indentation is consistent, so the intent of sending a message is understandable. However readability suffers from duplicated wait loops, magic timeout constants, empty exception handlers, and opaque locator strings instead of named helpers or constants.","tokens":1089,"name":"194.jsnp"}
{"score":"88","reasoning":"Clear, simple Java code with descriptive names and straightforward control flow. Consistent formatting and minimal logic make it easy to follow. Minor drawbacks include underscore-prefixed fields and the snippet ending before showing the full class and remaining methods, but these do not significantly reduce readability.","tokens":887,"name":"147.jsnp"}
{"score":"90","reasoning":"Code is very readable with clear variable names, consistent formatting, and straightforward control flow. Validation logic is easy to follow and error keys are descriptive. Minor issues are duplicated structure between added and updated methods and the use of else if, which prevents checking the body when the subject prefix is null.","tokens":642,"name":"206.jsnp"}
{"score":"70","reasoning":"Method and parameter names are descriptive and consistent, so intent is clear and structure is simple. Readability is reduced by unusual line breaks between return type and method name, excessive vertical spacing, and empty method bodies without documentation explaining why they are empty or unsupported.","tokens":1059,"name":"138.jsnp"}
{"score":"80","reasoning":"Code is readable with clear Java structure, consistent indentation, and descriptive method names. Exception handling is explicit and patterned, making control flow easy to follow. Use of fully qualified class names and boilerplate Liferay proxy code adds verbosity but does not significantly hinder comprehension.","tokens":907,"name":"165.jsnp"}
{"score":"98","reasoning":"Very clear and minimal Java exception class. Naming is descriptive, structure is standard, and indentation and style follow common conventions. The snippet is small, making it extremely easy to understand. Only minor drawback is limited context and functionality, but readability itself is excellent.","tokens":601,"name":"182.jsnp"}
{"score":"82","reasoning":"Short Java snippet with clear intent and straightforward logic. Method names and structure are understandable and encoding behavior is obvious. However, there is little context, no comments, and the abstract method line break style and dangling brace slightly hurt readability. Overall still easy to follow for someone familiar with Java.","tokens":567,"name":"169.jsnp"}
{"score":"92","reasoning":"Very readable sequential property assignments with consistent indentation and naming. Uses clear source and target objects, minimal logic, and a simple conditional block, so intent is easy to understand. Lack of comments is acceptable because field names are descriptive. Could be slightly improved by grouping related fields or using a builder, but overall clarity is high.","tokens":1329,"name":"148.jsnp"}
{"score":"90","reasoning":"Code is clean and consistent, with clear variable names and straightforward null handling using simple if else blocks. The structure is easy to follow and logic is obvious for both dates and string normalization. Minor verbosity due to duplicated patterns and the extra local variable for name, but this does not significantly hurt readability or comprehension.","tokens":838,"name":"142.jsnp"}
{"score":"92","reasoning":"Code is concise and well structured. Method and constructor names are clear and descriptive, indentation is consistent and logic is straightforward. The only minor issue is an apparent stray comment terminator at the beginning, but this does not significantly hurt readability.","tokens":666,"name":"213.jsnp"}
{"score":"92","reasoning":"Code is concise and well structured with a clear interface purpose and descriptive method names. Consistent naming of source and destination sessions and selected database objects aids comprehension. The license header is standard and unobtrusive. Additional method level documentation could slightly improve clarity, but overall readability is very high.","tokens":1170,"name":"200.jsnp"}
{"score":"93","reasoning":"Code is highly readable, with clear method names and detailed JavaDoc explaining purpose and parameters. Consistent style and simple signatures make comprehension easy. Minor drawback is the missing JavaDoc for setCompanyId, but overall clarity is excellent.","tokens":755,"name":"130.jsnp"}
{"score":"75","reasoning":"Clear step by step selenium test flow and consistent indentation make it fairly easy to follow. However readability suffers from duplicated polling loops, magic numbers for timeouts, long exact locators and paths, and empty exception handlers. Lack of comments and descriptive helper methods also reduces overall clarity.","tokens":1418,"name":"173.jsnp"}
{"score":"70","reasoning":"Code is properly indented and uses consistent naming, making control flow mostly clear. However, heavy use of fully qualified class names, reflection via MethodKey and MethodHandler, and nested try catch blocks reduce readability and make understanding intent slower for readers unfamiliar with the framework.","tokens":1078,"name":"162.jsnp"}
{"score":"90","reasoning":"Code is short and easy to follow. Class and variable names are descriptive, formatting and structure are clear, and logic is straightforward. Uses standard Swing patterns. Minor issues include the missing closing brace in the snippet and lack of comments, but these do not significantly reduce overall readability.","tokens":680,"name":"123.jsnp"}
{"score":"78","reasoning":"Code is mostly readable with clear control flow and consistent indentation. Polling loops are understandable but duplicated, use hard coded time values and swallow exceptions, which obscure intent. Many string literals and XPath expressions inline hurt clarity; helper methods and constants would improve comprehension.","tokens":1031,"name":"210.jsnp"}
{"score":"92","reasoning":"Code is concise and well structured with clear naming and simple getters and setters. Logic is easy to follow and the error state is obvious. The hasError method could be more compact and the snippet appears to omit the final closing brace, but overall readability and comprehension are very high.","tokens":890,"name":"163.jsnp"}
{"score":"93","reasoning":"Clear Java foreach over models with descriptive names and simple transformation to SOAP models, using a standard toArray pattern and an explicit empty constructor. Indentation and structure are straightforward and idiomatic. Lack of broader context and comments slightly reduces overall ease of comprehension.","tokens":850,"name":"171.jsnp"}
{"score":"92","reasoning":"Clear wrapper class delegating to an underlying auth token with straightforward methods and consistent naming, making it easy to understand. Logic is simple and well structured, though the snippet seems to miss the final class brace and has minor style concerns, keeping it from a perfect score","tokens":819,"name":"139.jsnp"}
{"score":"94","reasoning":"The code is concise and easy to follow, using clear component names like pnlName, lblName, and txtName. Layout usage with BorderLayout is straightforward and consistent. The i18n comment clarifies the label text source. Indentation is mostly clean, and there is no complex logic, making the snippet very readable and quickly understandable.","tokens":687,"name":"196.jsnp"}
{"score":"95","reasoning":"Straightforward sequence of test registrations with consistent naming and formatting makes the code highly readable and easy to follow; minor improvement could come from grouping related tests or adding brief context about each group.","tokens":765,"name":"155.jsnp"}
{"score":"95","reasoning":"Code is concise, well structured and uses clear names. Methods are short and focused, logic is straightforward and follows standard Java conventions. Generics are used correctly and control flow is easy to follow. Only minor drawback is the magic string parameter name, but overall readability is very high.","tokens":1244,"name":"125.jsnp"}
{"score":"88","reasoning":"Simple Java snippet with clear class and field names and standard formatting making it easy to read though it is incomplete and lacks access modifiers and documentation which slightly reduces clarity","tokens":584,"name":"128.jsnp"}
{"score":"72","reasoning":"Code is fairly readable with consistent indentation and largely clear variable names. However, the main conditional expression is dense and would benefit from additional parentheses, use of a space character as a state flag is not very explicit, and tight nesting plus missing broader context reduce ease of comprehension.","tokens":1104,"name":"164.jsnp"}
{"score":"82","reasoning":"The snippet is readable with consistent formatting and clear method and variable names. Repeated calls to updatePortletPermissions follow a uniform pattern that is easy to follow. However, it relies on magic string IDs and permission names without documentation or explanation, which reduces clarity for readers unfamiliar with the specific Liferay domain and context.","tokens":930,"name":"127.jsnp"}
{"score":"75","reasoning":"The snippet intent is clear, using a visibility check to break a loop. Readable indentation and simple control flow help comprehension. However, the empty catch block hides potential errors, the hard coded XPath string is unexplained, and there is no comment on why Thread.sleep is used, which reduces overall clarity.","tokens":1207,"name":"124.jsnp"}
{"score":"74","reasoning":"Code is generally readable with clear indentation and flow. Selenium actions and variable names are understandable. Readability is hurt by the long polling loop, silent exception handling, and magic numbers for timeouts and locators. Overall it is easy to follow but not polished.","tokens":1326,"name":"220.jsnp"}
{"score":"82","reasoning":"Code is clear and well structured, with meaningful method and variable names, consistent indentation, and straightforward logic. Minor issues are the typo in _proccessAttributes, use of Collections.EMPTY_LIST without generics, and missing generics in some map declarations, but these do not significantly hinder readability.","tokens":969,"name":"211.jsnp"}
{"score":"93","reasoning":"Clear and concise Java snippet using an enum style comparison and a straightforward getter. Control flow is simple, naming is readable, and the exception message is informative, making the intent easy to understand. Slight lack of surrounding context prevents a perfect score, but readability of this fragment alone is very high.","tokens":544,"name":"109.jsnp"}
{"score":"62","reasoning":"Indentation and structure are acceptable and variable names are clear, making control flow mostly easy to follow. Readability suffers from long opaque XPath expressions, magic numeric timeouts, an empty catch block, and use of labels with continue, which obscure intent and complicate understanding.","tokens":1357,"name":"121.jsnp"}
{"score":"75","reasoning":"Logic is straightforward and naming is clear, so comprehension is easy. Readability is reduced by odd line breaks, an empty catch block that hides errors, and lack of comments or context about the looping structure.","tokens":1013,"name":"143.jsnp"}
{"score":"90","reasoning":"Code is clean and easy to follow, with descriptive test method names and straightforward arrange act assert structure. Indentation and spacing are consistent, and use of helper methods keeps tests compact. Readability could be slightly improved with brief comments or more explicit naming for helper methods like nextLong and randomString.","tokens":921,"name":"120.jsnp"}
{"score":"88","reasoning":"Readable Java test code with clear structure, descriptive class and method names, and consistent indentation. The waiting loop logic is straightforward. Minor issues like an empty catch block and a magic timeout constant slightly reduce clarity but overall it is easy to understand.","tokens":897,"name":"219.jsnp"}
{"score":"94","reasoning":"Clean and minimal Java code with clear method names and Javadoc, consistent formatting and straightforward logic. Very easy to follow, but lacks generics on the Enumeration return type and has no input validation or error logging, which slightly reduces overall clarity and modern readability.","tokens":845,"name":"122.jsnp"}
{"score":"82","reasoning":"Simple and readable interface declaration with clear naming and organized imports. Annotations are concise and self descriptive. However, the snippet is incomplete and lacks method signatures or documentation of purpose, reducing overall clarity and usefulness.","tokens":688,"name":"179.jsnp"}
{"score":"86","reasoning":"Code is clearly formatted with meaningful class and method names, and the control flow is easy to follow. Use of logging and string manager is standard and aids understanding. The only minor issue is the logger and string manager referencing DeleteAliasAction.class, which can briefly confuse the reader but not much.","tokens":1085,"name":"137.jsnp"}
{"score":"80","reasoning":"Code is short and intent is clear, indentation is consistent and the logic of checking for a link and then breaking or sleeping is easy to follow. Readability suffers from an empty generic exception handler and missing loop context.","tokens":907,"name":"218.jsnp"}
{"score":"78","reasoning":"Clear Java method signatures with consistent naming and transactional annotations. The intent of each method is easy to infer. Readability is reduced by very long fully qualified type names and repeated exception declarations, which add noise. Using imports and possibly grouping or documenting overloads would make the interface easier to scan and understand.","tokens":1182,"name":"144.jsnp"}
{"score":"90","reasoning":"Code is well formatted and easy to follow, with clear variable names and straightforward control flow. Logging aids comprehension. Use of UnsupportedOperationException for unimplemented methods is explicit but leaves behavior undefined for keySet and isEmpty, slightly reducing overall clarity.","tokens":923,"name":"154.jsnp"}
{"score":"94","reasoning":"Very readable and easy to understand interface. Clear naming, concise methods, and helpful Javadoc comments. Limited complexity makes intent obvious. Only downside is the use of a raw Map without type parameters, which slightly reduces type clarity.","tokens":875,"name":"216.jsnp"}
{"score":"78","reasoning":"Code is mostly clear Selenium test logic with explicit wait loop and meaningful asserts. Indentation and long XPath reduce readability. Magic numbers for timeouts and empty catch block hurt clarity slightly, but overall flow is easy to follow.","tokens":2094,"name":"215.jsnp"}
{"score":"72","reasoning":"Code uses consistent indentation and descriptive names and the logic flow is generally clear. However the label driven while and switch structure and lack of explicit break before the next case reduce readability. Magic numbers and an empty catch block also hurt clarity.","tokens":1764,"name":"205.jsnp"}
{"score":"88","reasoning":"Code is concise and easy to follow with clear control flow. Indentation and spacing are consistent, and naming is acceptable. Minor issues include unconventional spacing around parentheses, lack of method context, and absence of comments or explanation for string Tunnel and null parameters.","tokens":774,"name":"185.jsnp"}
{"score":"90","reasoning":"Code is very readable with clear naming and straightforward StringBundler usage. Indentation and structure are consistent, and null handling is explicit. Slight verbosity in repetitive append calls and null checks prevents a perfect score, but overall comprehension is easy and maintenance should be simple.","tokens":1098,"name":"197.jsnp"}
{"score":"90","reasoning":"Code is well formatted and uses clear Java conventions, with organized imports and standard license header. Naming is descriptive and package structure is evident, making the snippet easy to read, though no actual logic is shown to assess deeper clarity.","tokens":1200,"name":"134.jsnp"}
{"score":"40","reasoning":"Variable names are reasonably clear, but the snippet starts with several closing braces that lack context, making structure hard to follow. The method signature is split across multiple lines in an unusual way, which reduces readability. There are no comments or visible logic to infer intent, so overall comprehension from this snippet alone is limited.","tokens":890,"name":"117.jsnp"}
{"score":"82","reasoning":"Getters and simple methods are clear and well named, indentation is consistent, and concatenation in toString and toShortString is understandable. Readability is slightly reduced by the magic number 32767, the lSequenceNo prefix, and minor naming issues like PlaformMessage and the cn literal, but overall the snippet is easy to follow.","tokens":1072,"name":"108.jsnp"}
{"score":"60","reasoning":"The snippet is short and the control flow is simple, making it moderately understandable. However, readability suffers from an opaque element identifier, use of label as a magic number, and the apparent truncation at the start of the code. Indentation and structure are otherwise acceptable.","tokens":909,"name":"129.jsnp"}
{"score":"88","reasoning":"Code is short and clear, method names are descriptive, parameters and types are explicit and consistently named, indentation is good. It lacks surrounding interface or class declaration and any documentation, but overall readability and ease of comprehension are high.","tokens":1016,"name":"195.jsnp"}
