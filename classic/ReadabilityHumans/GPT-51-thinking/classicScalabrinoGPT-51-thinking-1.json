{"score":"93","reasoning":"The code is short, idiomatic, and uses clear naming consistent with JUnit and Hibernate patterns. The test intent is understandable from the method name, and the sequence of operations is straightforward. Minor improvements could include an assertion to clarify expected behavior, but readability and comprehension are high overall.","tokens":509,"name":"133.jsnp"}
{"score":"94","reasoning":"The code is concise and self-explanatory, with clear naming and helpful documentation. It uses straightforward construction logic and consistent formatting, making it easy to read and understand. The absence of complex control flow or side effects keeps cognitive load low.","tokens":582,"name":"67.jsnp"}
{"score":"94","reasoning":"The constructor is concise and clear, with consistent formatting and descriptive function names. The sequence of registerFunction calls is straightforward and uniform, making behavior easy to follow. Minor improvement could be adding brief comments about each function purpose, but overall readability and comprehension are high.","tokens":722,"name":"21.jsnp"}
{"score":"88","reasoning":"Readable method with clear naming and structure; responsibilities are focused and comments clarify purpose. Some domain specific types and chained calls require knowledge of the surrounding framework, so comprehension is not completely straightforward but still fairly easy.","tokens":882,"name":"170.jsnp"}
{"score":"78","reasoning":"Code is mostly readable with clear structure and meaningful variable names. However, the long repetitive print statements, magic numbers, and dense bit manipulation without comments reduce clarity. Extracting helper methods and adding brief documentation would significantly improve ease of comprehension.","tokens":1039,"name":"58.jsnp"}
{"score":"83","reasoning":"Clear structure and naming, straightforward control flow, and consistent null handling make the code easy to follow. However there is duplicated address clearing logic in multiple branches, the empty else block for empty input may confuse readers, and the magic string NULL could be replaced by a constant or enum for clarity.","tokens":772,"name":"61.jsnp"}
{"score":"92","reasoning":"Code is well structured and consistently indented, with clear method and class responsibilities. Use of a private integrate helper removes duplication and improves clarity. Names are descriptive and the flow of integration logic is straightforward. The only minor issue is a long chained call that could be wrapped for better line readability, but overall comprehension is easy.","tokens":758,"name":"174.jsnp"}
{"score":"85","reasoning":"Clear JUnit test method with consistent indentation and descriptive though lengthy type names. Logic flows linearly and assertions are straightforward. Use of numbered rev variables is understandable but a loop or helper could reduce repetition. Overall easy to read with minor verbosity issues.","tokens":982,"name":"186.jsnp"}
{"score":"78","reasoning":"Clear structure and intent with a descriptive test name and consistent use of assertNoLoss. However, very long SQL strings on single lines make the code harder to scan and maintain. Lack of formatting or extraction of the SQL into named constants reduces readability, though overall it remains understandable for experienced developers.","tokens":1146,"name":"101.jsnp"}
{"score":"90","reasoning":"Clear structure and naming, well formatted, simple branching for composite vs non composite keys, helpful comments and limited nesting. Slightly dense string concatenation and helper calls may slow understanding but overall it is very readable.","tokens":910,"name":"112.jsnp"}
{"score":"90","reasoning":"Code is well formatted with clear indentation and naming. The test method name and variable identifiers are descriptive, and the sequence of actions and assertions is easy to follow. The configuration block is dense and property keys are long, but they follow a consistent pattern. Overall, the structure and clarity make the snippet easy to read and understand.","tokens":1061,"name":"131.jsnp"}
{"score":"92","reasoning":"Code is short, cohesive and easy to follow. Method and property names are descriptive, and configuration calls are consistently structured. Using cfg as parameter name slightly reduces clarity, and there are no comments explaining context, but overall readability and comprehension are high.","tokens":805,"name":"191.jsnp"}
{"score":"86","reasoning":"Readable Java test with clear intent, good naming and structured assertions. Anonymous inner classes and repeated casts add some verbosity and noise, but logic remains straightforward. Overall easy to follow despite minor clutter from nested calls and long identifiers.","tokens":1033,"name":"98.jsnp"}
{"score":"94","reasoning":"Clear and concise unit test with descriptive method name and comments, consistent formatting and logically grouped assertions. Domain specific types may require framework knowledge but do not hurt structure. Overall high readability and straightforward control flow.","tokens":935,"name":"57.jsnp"}
{"score":"88","reasoning":"Readable JUnit style test. Clear setup, actions, and assertions. Consistent indentation and naming of variables and methods. Hibernate session and transaction usage is straightforward. Minor issues like small text typos and some repetition, but overall the control flow and intent are easy to understand.","tokens":1168,"name":"192.jsnp"}
{"score":"90","reasoning":"Well structured unit test with clear method and variable names and logical flow. Comment explains non deterministic order handling. Use of iterators and multiple assertions is easy to follow though slightly verbose. Overall very readable and understandable code.","tokens":1314,"name":"181.jsnp"}
{"score":"95","reasoning":"Very short and clear method releasing a resource. Proper null check and try catch block. Naming is clear and indentation is consistent. Only minor concern is the empty catch which may hide errors, but it is commonly used for close operations. Overall easy to understand.","tokens":610,"name":"150.jsnp"}
{"score":"86","reasoning":"Code is concise and well structured, with a clear test name and straightforward try catch pattern. The HQL query expresses intent but is dense and packed into a single long string, which slightly reduces readability. Overall logic is easy to follow and resource handling is explicit with session open and close.","tokens":735,"name":"81.jsnp"}
{"score":"94","reasoning":"Code is concise, well structured, and uses clear method and variable names. Comments explain intent and flow. Method chaining is readable but slightly long, which can hinder quick scanning. Overall, logic is straightforward and easy to follow for someone familiar with the domain, indicating high readability and maintainability.","tokens":706,"name":"103.jsnp"}
{"score":"88","reasoning":"Clear naming and consistent formatting, method purpose easy to infer. Straightforward property assignments and type descriptor setup aid comprehension. Readability slightly reduced by duplicated persister configuration block and domain specific framework methods, but overall still very easy to follow.","tokens":1273,"name":"146.jsnp"}
{"score":"92","reasoning":"Clear structure, meaningful names, consistent indentation and helpful comments make the code easy to follow. Control flow is straightforward and conditions are simple. Minor issue, comments are slightly verbose and there is small repetition, but overall readability is excellent.","tokens":858,"name":"151.jsnp"}
{"score":"88","reasoning":"Code is concise and well formatted with meaningful names and straightforward logic. Use of arrays for candidate points is understandable but the hardcoded 5 and lack of comments or named constants slightly reduce clarity. Overall it remains easy to read and maintain","tokens":760,"name":"153.jsnp"}
{"score":"90","reasoning":"The test code is concise, well formatted, and uses descriptive method and variable names. The sequence of entity retrievals and revision checks is straightforward and consistent. Assertions are clear and repetitive in a predictable pattern. Although there are no comments, the intent of the test is evident, resulting in high readability and ease of comprehension.","tokens":940,"name":"166.jsnp"}
{"score":"88","reasoning":"Clear naming and linear control flow, limited nesting, and a focused responsibility make the method easy to follow. Comment documents a design limitation. Minor readability issues from raw Iterator and map lacking generics and a slightly verbose boolean expression, but overall the code remains straightforward.","tokens":1357,"name":"31.jsnp"}
{"score":"95","reasoning":"The code is very clear and concise, using a standard equals pattern, good JavaDoc, and simple control flow. Readability is high and intent is obvious. It is slightly redundant because it only delegates to super.equals after type checking and then explicitly returns true, instead of directly returning super.equals(obj). Overall it is highly readable and easy to comprehend.","tokens":539,"name":"39.jsnp"}
{"score":"92","reasoning":"Clear Java constructor with consistent formatting and descriptive method and type names. Column type and function registrations are logically grouped and easy to follow. Very low complexity and no nested logic aid understanding. Minor domain specific knowledge is needed to fully grasp purpose, but overall the snippet is highly readable and straightforward.","tokens":937,"name":"20.jsnp"}
{"score":"88","reasoning":"Code is well structured with clear indentation and meaningful names. Inline comment explains purpose of failing insert. Use of anonymous class and repeated session casting adds slight noise but flow remains easy to follow. Error handling and transaction management are clear, improving readability overall.","tokens":1141,"name":"93.jsnp"}
{"score":"74","reasoning":"Readable test with clear structure and a somewhat descriptive name, but clarity suffers from heavy use of explicit casts, raw Collection types, and an index variable used across multiple checks. Lack of comments and generics makes the relationships between parent, children, and listeners harder to follow, though the overall flow remains maintainable.","tokens":1267,"name":"140.jsnp"}
{"score":"84","reasoning":"Code is mostly readable with clear variable names and straightforward control flow. Indentation and structure are good, and logic is easy to follow. Use of boolean flags and nested loops adds some complexity, and factoring out the inner row search into a helper could improve clarity. Commented out code slightly distracts.","tokens":937,"name":"50.jsnp"}
{"score":"40","reasoning":"Early null and identity checks are clear, but the main return expression is a long nested conditional combining multiple checks, which is hard to parse and reason about. The heavy use of inline logic instead of intermediate variables reduces readability and maintainability. Overall, understanding the method requires careful step by step mental evaluation.","tokens":961,"name":"36.jsnp"}
{"score":"92","reasoning":"Clear and standard equals implementation with straightforward control flow and meaningful names. Null checks are explicit and consistent. Lack of braces on one line if statements and somewhat verbose ternary style null comparisons slightly reduce readability, but overall the method is easy to follow and maintain.","tokens":685,"name":"60.jsnp"}
{"score":"82","reasoning":"Code is generally clear with descriptive test name and straightforward assertTranslation calls. Use of dialect specific conditionals is logical but the long chained instanceof checks with negations reduce readability. Comments help context yet the method mixes many concerns, hindering quick comprehension.","tokens":1796,"name":"89.jsnp"}
{"score":"82","reasoning":"Clear Java style, meaningful method and variable names and helpful inline comments make the flow mostly easy to follow. However, the logic around implied optimistic locking, dynamic versus static delete statements, and indirect state lookup is somewhat dense and domain specific, so it requires careful reading despite being well structured.","tokens":1710,"name":"106.jsnp"}
{"score":"90","reasoning":"Code is concise and well formatted. Clear method and variable names and consistent indentation improve readability. Domain specific conditions and use of instanceof are straightforward. Comments help describe intent. Minor improvements could be extraction of repeated strings and flattening nested if statements for even better clarity.","tokens":835,"name":"47.jsnp"}
{"score":"88","reasoning":"Clear structure and intent, good naming and indentation. Conditional branches are straightforward and the method is short, aiding comprehension. Minor issues include the odd method name parserPrimaryKeyJoinColumn which suggests parse, and the magic string value, which slightly reduce clarity. Overall the code is very readable and easy to follow.","tokens":685,"name":"193.jsnp"}
{"score":"87","reasoning":"Code is clear and consistent, with descriptive names and straightforward control flow. Assertions are well structured and indentation is good. Minor issues include several magic numbers, limited comments, and a slightly opaque condition on the MBean name, but overall readability and comprehension are high.","tokens":1349,"name":"90.jsnp"}
{"score":"90","reasoning":"Readability is high thanks to clear structure and limited logic in the thread run method. Try finally block and descriptive method names aid understanding. Slight deduction for short thread variable name and reliance on an anonymous inner class but overall the code is straightforward.","tokens":1225,"name":"73.jsnp"}
{"score":"92","reasoning":"Clear and compact JUnit test, consistent indentation and naming, simple control flow, and straightforward assertions make it easy to understand. Minor issues are magic string literals and duplicate property keys, but they do not significantly harm readability.","tokens":892,"name":"35.jsnp"}
{"score":"80","reasoning":"Readable method with clear purpose and descriptive identifiers. Control flow is simple and loops are straightforward. However it uses raw Vector and Enumeration without generics and an Object array path without explanation, which slightly hurts clarity. Indentation is a bit inconsistent but overall understanding is easy.","tokens":1045,"name":"46.jsnp"}
{"score":"88","reasoning":"Well structured JUnit test with clear method name and comments. Logic flows in a straightforward way, queries are readable, and assertions are easy to follow. Variable names are descriptive. Minor issues include inconsistent indentation, manual index based asserts, and lack of try with resources, but they do not significantly harm readability.","tokens":1009,"name":"136.jsnp"}
{"score":"78","reasoning":"Code is mostly readable, with clear control flow, consistent indentation and descriptive logging. Use of try finally with barriers is easy to follow. Readability is reduced by the large commented out section, unused variables like runs in the current form, and some leftover benchmarking scaffolding that adds noise.","tokens":955,"name":"172.jsnp"}
{"score":"83","reasoning":"Code is fairly readable with clear session lifecycle, setup, and cleanup. Indentation and naming are consistent, and test intent is mostly inferable. However, the long compound dialect condition and dense HQL query strings hinder quick understanding. More structure, helper methods, or brief documentation would improve overall clarity.","tokens":1427,"name":"68.jsnp"}
{"score":"92","reasoning":"Clear Java test method with meaningful name, standard JPA usage, consistent indentation and spacing, and simple control flow. The comment and variable names aid understanding, and the small scope with no nested logic keeps it easy to read. Overall, the code has very good readability and is easy to comprehend.","tokens":730,"name":"168.jsnp"}
{"score":"88","reasoning":"Code is clear and well structured, with descriptive names and consistent formatting. Control flow is straightforward and use of ternary operators remains readable. Some verbosity from fully qualified annotation names, but overall logic is easy to follow. Readability is high for experienced Java developers.","tokens":1455,"name":"28.jsnp"}
{"score":"92","reasoning":"Very readable Java constructor with a clear single purpose registering SQL functions. Consistent formatting, descriptive function names, and simple repetitive structure make it easy to scan and understand. Minor improvement could be grouping related functions or adding a brief comment describing the overall registration strategy.","tokens":947,"name":"18.jsnp"}
{"score":"88","reasoning":"Readable JUnit test with clear purpose and meaningful names. SQL and expected output kept together aids understanding but the very long concatenated string in assertEquals reduces scanability and is prone to subtle formatting errors. Extracting SQL constants or helper methods would further improve clarity.","tokens":984,"name":"23.jsnp"}
{"score":"96","reasoning":"Clear and conventional Java equals implementation with descriptive comments and straightforward control flow. Each comparison is explicit and well ordered, making the logic easy to follow. Naming and formatting are consistent. Slight verbosity from multiple individual checks, but it actually improves readability for most readers.","tokens":694,"name":"42.jsnp"}
{"score":"86","reasoning":"Readable unit test with clear indentation and descriptive naming. Anonymous inner classes are short and focused, making the flow easy to follow. Long query string on one line and repeated casts with raw List and Map types slightly reduce clarity, but overall structure remains straightforward to understand.","tokens":1693,"name":"99.jsnp"}
{"score":"92","reasoning":"Clear and concise toString implementation. Uses StringBuilder with readable chained appends and descriptive field names. Conditional block for region improves safety. Indentation and structure are consistent. Slightly long chain but still easy to follow.","tokens":822,"name":"64.jsnp"}
{"score":"90","reasoning":"Well structured Java method with clear Javadoc, descriptive identifiers, and straightforward control flow. Logging message is explicit and variable naming reflects intent. Use of multiple chained iterator calls adds minor cognitive load but overall readability and comprehension remain high.","tokens":1109,"name":"102.jsnp"}
{"score":"92","reasoning":"Good readability with descriptive names and consistent formatting. Control flow is straightforward and helped by an inline comment. The main drawback is the long compound conditional, which could be extracted into a helper for clarity. Overall, the method is easy to understand for experienced Java developers.","tokens":967,"name":"198.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear control flow, meaningful exception messages, and consistent indentation. Use of switch on event types and explicit handling of cases makes behavior easy to follow. Limited comments but logic remains straightforward for experienced readers.","tokens":1058,"name":"152.jsnp"}
{"score":"88","reasoning":"Test method is concise with clear naming and logical flow. Comments explain context and intent, though one is verbose. Indentation is consistent and the control structure is simple, making the code easy to follow and maintain.","tokens":970,"name":"175.jsnp"}
{"score":"86","reasoning":"Short method with clear purpose and descriptive names, straightforward control flow and helpful logging. Readability is high. Minor drawbacks are outdated raw Iterator without generics, inconsistent indentation and weak exception variable naming; still easy to understand overall.","tokens":1198,"name":"7.jsnp"}
{"score":"82","reasoning":"Code is generally clear, method and variable names are descriptive, and the test intent is easy to infer. However, the HQL query and chained calls are on a single long line, hurting readability, and there is a leftover commented print plus a typo in the assertion message. Splitting the query and calls would improve clarity.","tokens":847,"name":"92.jsnp"}
{"score":"86","reasoning":"Code is well formatted, uses descriptive names and has a straightforward linear flow, so the intent of the test is easy to follow. Use of raw List and Object array slightly hurts readability, and magic revision numbers 15, 16, 17 lack context, but overall comprehension remains high.","tokens":1071,"name":"167.jsnp"}
{"score":"82","reasoning":"Code is mostly clear with good indentation and descriptive names. Use of raw Stack and absence of generics reduce type safety. Commented out cast and vague method names like ffCodePiece slightly hurt readability. Overall flow and branching are easy to follow.","tokens":816,"name":"116.jsnp"}
{"score":"74","reasoning":"Well structured test with meaningful method and variable names. Anonymous inner classes for executors and checker are understandable, but nested braces and extensive casting on a raw List reduce clarity. Noisy spacing around casts and repeated expressions in assertions hurt readability, though overall comprehension remains reasonable.","tokens":1262,"name":"96.jsnp"}
{"score":"90","reasoning":"Code is concise and readable with clear test structure and meaningful names. Anonymous inner classes are used idiomatically and control flow is straightforward. The only minor issue is the long inline string array for expected output, which could be split for better readability.","tokens":1154,"name":"12.jsnp"}
{"score":"88","reasoning":"Clear naming and structure, simple control flow and consistent indentation. Method purpose is obvious and parameters are readable. Minor issues are the raw Map type and vague parameter name map, plus an unresolved TODO comment reducing completeness.","tokens":810,"name":"55.jsnp"}
{"score":"86","reasoning":"Code is well-indented with a clear if-else chain and meaningful names. Comments explain the intent and precedence of conditions, aiding comprehension. Some conditions are long and repeated calls slightly clutter the logic, and a few comment typos exist, but overall the control flow and purpose remain easy to understand.","tokens":1001,"name":"107.jsnp"}
{"score":"88","reasoning":"Simple and short Java method, clear naming and indentation, concise conditional and comment explaining behavior. Minor style issue with missing space around the inequality operator and missing explicit access modifier, but overall it is very easy to read and understand.","tokens":855,"name":"65.jsnp"}
{"score":"70","reasoning":"Readability is moderate; control flow is clear and the method is short, but long chained calls and repeated casting of session reduce clarity. Lack of meaningful handling in the catch block and missing resource management constructs like try with resources also hurt maintainability.","tokens":1076,"name":"100.jsnp"}
{"score":"84","reasoning":"Clear unit test with descriptive name and straightforward assertions Repeated annotation checks are verbose but still easy to follow Formatting and naming are consistent Could be improved by grouping similar asserts but overall readability is high","tokens":1008,"name":"176.jsnp"}
{"score":"88","reasoning":"Clear structure and naming, with logging that aids understanding. Conditions and exceptions are explicit and informative. Nested if else blocks are simple and consistent. Domain specific types may require framework knowledge, but the control flow is straightforward, providing high readability and ease of comprehension.","tokens":996,"name":"183.jsnp"}
{"score":"86","reasoning":"Code is well structured, consistently indented, and uses clear stepwise comments for each revision, making the flow easy to follow. The JPA and transaction usage is standard and recognizable. Readability is slightly reduced by non-descriptive variable names like ele1, c3_1, and c3_2 and some repetition in the find and transaction blocks.","tokens":1120,"name":"188.jsnp"}
{"score":"87","reasoning":"Clear Java method with descriptive names and straightforward logic. Formatting is consistent and the comment explains the snapshot handling. Readability is slightly reduced by the vague index parameter j and the dependence on parallel arrays, which makes the code less self explanatory without broader context.","tokens":892,"name":"104.jsnp"}
{"score":"88","reasoning":"Code is well indented with clear test name and assertion message. Control flow try catch finally is straightforward and variable names are meaningful. Deeply chained coordinator calls and the boolean flag pattern for exception handling make it slightly less clean but overall readability and comprehension are high.","tokens":920,"name":"145.jsnp"}
{"score":"82","reasoning":"Clear Java listener code with descriptive names, simple control flow, and reasonable formatting. Minimal nesting and domain specific calls are easy to follow. Some commented out lines add minor noise and missing braces for inner if blocks could further improve clarity, but overall comprehension is straightforward.","tokens":677,"name":"11.jsnp"}
{"score":"92","reasoning":"Code is clear and well structured, with descriptive method and variable names. Assertions are logically grouped by context and target field, making intent easy to follow. Some repetition of reader getAnnotation calls and relatively long lines slightly reduce readability but overall it is very easy to understand.","tokens":2073,"name":"135.jsnp"}
{"score":"85","reasoning":"Simple, well indented JUnit test with clearly separated steps and descriptive helper method names. However the test name is very long and uses multiple concepts making it harder to scan quickly, and the internal comment is abbreviated, which slightly reduces immediate clarity.","tokens":679,"name":"187.jsnp"}
{"score":"88","reasoning":"Very readable Java method with clear naming, consistent structure and simple control flow. Uses descriptive variable names and log message. Minor issue is method name resetRegionUsageState not fully aligned with its behavior of registering access and modification events, and use of getSaw prefix may confuse side effects. Overall easy to understand.","tokens":696,"name":"190.jsnp"}
{"score":"82","reasoning":"The code is generally easy to follow, with clear intent and understandable variable names. Readability is reduced by unnecessary deep nesting of if else blocks and repeated long method calls instead of using else if and local variables. Formatting is acceptable but could be more consistent to further improve scanning.","tokens":986,"name":"157.jsnp"}
{"score":"93","reasoning":"Very readable Java code with clear Javadoc, descriptive method and variable names, and straightforward control flow. Consistent formatting and limited complexity. Minor drawback is a long return statement that could be split for clarity.","tokens":851,"name":"126.jsnp"}
{"score":"95","reasoning":"Method is short, clearly structured and supported by precise Javadoc. Field names are descriptive and follow a consistent pattern, making the sequence of paint deserialization calls easy to follow. No branching or complex logic improves readability, though the repetitive assignments could be slightly condensed.","tokens":1261,"name":"3.jsnp"}
{"score":"78","reasoning":"Simple test method that sequentially calls parse with various query strings. Code structure is straightforward and easy to follow, and indentation is acceptable. However, the test name is not very descriptive and there are no assertions, making intent less clear. Dense inline queries slightly reduce readability but overall comprehension remains good.","tokens":1046,"name":"85.jsnp"}
{"score":"98","reasoning":"Very readable Java constructor with clear purpose and well named methods. Consistent indentation and concise structure aid comprehension. Lacks inline detail but code intent is obvious so overall readability is excellent.","tokens":594,"name":"19.jsnp"}
{"score":"90","reasoning":"Clear naming and repetitive structure make the test easy to follow. Consistent formatting and straightforward assertions aid comprehension. Some duplication could be reduced with a helper method or parameterized test to improve maintainability, but overall readability remains high.","tokens":1537,"name":"26.jsnp"}
{"score":"90","reasoning":"Code is concise and well structured. Clear naming and consistent formatting. Static init method purpose is documented. Repeated registration code is straightforward and easy to follow. Minor issue is the presence of commented legacy code and some long lines, but overall readability remains high.","tokens":969,"name":"5.jsnp"}
{"score":"87","reasoning":"Code is generally clear and well structured. Method and variable names are descriptive and comments explain each branch. Loop and condition logic are straightforward. However, long chained calls and line breaks slightly hinder readability, and the cast from shortcutHash hints at non-generic collections which can reduce clarity.","tokens":834,"name":"51.jsnp"}
{"score":"88","reasoning":"Code is clear and well structured, with descriptive method and variable names, simple control flow and precise error messages. Reflection adds some inherent complexity, but the parameter checking, instance creation and field assignment logic remain easy to follow. Exception construction is slightly verbose but does not harm readability significantly.","tokens":992,"name":"13.jsnp"}
{"score":"92","reasoning":"Clear, linear test flow with meaningful domain names and consistent formatting. Transactions and sessions are easy to follow and the intention of the assertion is obvious. Use of raw collections and lack of generics slightly reduce clarity, but overall the snippet is straightforward and highly readable.","tokens":992,"name":"82.jsnp"}
{"score":"84","reasoning":"Code is concise and method names are descriptive, making the purpose of each array element clear. The use of an Object array with several null entries slightly reduces readability, as the intent of the null separators is implicit rather than documented. Overall structure is simple and easy to follow, but could be improved with stronger typing or clearer grouping.","tokens":587,"name":"156.jsnp"}
{"score":"90","reasoning":"Code is well structured and easy to follow, with clear variable names and straightforward loops. The validation logic is coherent and error messages are explicit and descriptive. Minor drawbacks are long concatenated strings that slightly reduce readability and validation logic that could be split into smaller helper methods for even clearer structure.","tokens":909,"name":"14.jsnp"}
{"score":"82","reasoning":"The test is concise and the intent is understandable, with a straightforward assertion on a column name. However, readability is reduced by the long chained calls, nested getClassMapping, explicit cast, and fully qualified class name inside the assertion. Introducing intermediate variables would make the code clearer and easier to follow.","tokens":718,"name":"199.jsnp"}
{"score":"86","reasoning":"Well structured JUnit test with consistent indentation and descriptive method and variable names. Assertions follow a logical order and use clear API calls. However, the method is long and repetitive with several similar iterator checks, which slightly reduces overall readability and maintainability.","tokens":1186,"name":"180.jsnp"}
{"score":"93","reasoning":"Clear and descriptive test method with meaningful names and straightforward structure, uses standard testing patterns, assertions are easy to read, almost self explanatory, comments are not needed for understanding","tokens":828,"name":"159.jsnp"}
{"score":"86","reasoning":"Readable Java test code with clear naming and logical structure. Hibernate usage and session lifecycle are straightforward. Mixed indentation and the long SQL string on one line slightly reduce clarity, but overall comprehension is easy.","tokens":1129,"name":"72.jsnp"}
{"score":"88","reasoning":"Clear method and variable names, concise logic, and consistent formatting make the code easy to follow. The control flow is straightforward and the purpose is mostly evident from naming. Domain specific types and multiple casts add some cognitive load, but overall the snippet remains highly readable and understandable.","tokens":740,"name":"148.jsnp"}
{"score":"92","reasoning":"Code is very readable, with clear transaction blocks per revision and descriptive class and variable names. Indentation and structure are consistent. Minor issues include long lines for constructor arguments and long class name strings, which slightly reduce scanability but do not hinder comprehension.","tokens":1119,"name":"189.jsnp"}
{"score":"90","reasoning":"Highly readable unit test with descriptive method and assert messages, consistent naming and formatting. Logic flows in small clear steps and repeated patterns aid comprehension. Minor issue is line length and some duplication, but overall clarity is strong.","tokens":1221,"name":"88.jsnp"}
{"score":"88","reasoning":"Readable JUnit test with clear method and variable names, consistent formatting, and descriptive assertion messages. While it uses Hibernate specific types that require some domain knowledge, the overall flow is straightforward and the intent of the test is easy to understand.","tokens":816,"name":"178.jsnp"}
{"score":"88","reasoning":"Readable Java with clear naming, consistent formatting and an informative comment. Control flow is straightforward and side effects are expressed via well named helper methods. However, the method is somewhat long, chains many operations in one block and depends heavily on external context, which slightly reduces immediate comprehensibility.","tokens":1313,"name":"149.jsnp"}
{"score":"86","reasoning":"Method is concise, has clear JavaDoc and inline comments, and uses descriptive names, so comprehension is generally good. The compact CAS for loops with empty bodies and trailing semicolons are harder to read and demand concurrency knowledge, which slightly reduces readability, but the overall intent remains understandable to an experienced reader.","tokens":783,"name":"62.jsnp"}
{"score":"90","reasoning":"Clear unit test with descriptive name and straightforward assertions. Consistent indentation and grouping make flow easy to follow. Despite many repeated calls, structure remains simple and linear, with no complex control logic. Minor verbosity is the only drawback, but overall readability and comprehension are high.","tokens":1518,"name":"177.jsnp"}
{"score":"86","reasoning":"Overall very readable test with clear structure and naming. Anonymous inner classes are straightforward and indentation is consistent. Heavy casting to Student and use of a raw List reduce type safety and clarity slightly. The commented out assertion adds a bit of noise, but overall the logic and intent remain easy to follow for someone familiar with Hibernate.","tokens":1039,"name":"97.jsnp"}
{"score":"92","reasoning":"Code is highly readable with clear Javadoc explaining purpose and parameters, descriptive variable names, straightforward nested loops, and consistent formatting. Logic for positive and negative stacking is easy to follow. Only minor improvement would be extracting the inner accumulation loop for even clearer structure.","tokens":1077,"name":"41.jsnp"}
{"score":"88","reasoning":"Readable JUnit test with clear naming and straightforward flow. Annotations are verbose but structured. Minimal logic, consistent formatting, and meaningful assertions aid comprehension. Minor drawbacks are magic IDs, direct field access, and console output in the test, but they do not significantly hinder understanding.","tokens":947,"name":"138.jsnp"}
{"score":"72","reasoning":"Code is short and control structure is straightforward. Indentation is acceptable, but names like caseSList, _loop119 and _tokenSet_6 are obscure and likely generated, which hurts readability. Lack of comments and descriptive identifiers makes intent less obvious, though overall flow is still easy to infer.","tokens":732,"name":"115.jsnp"}
{"score":"82","reasoning":"Clear structure and purpose, consistent use of helper methods and localization. Readable ordering of fields and actions. Minor issues: inconsistent indentation, use of short variable names like a, lack of type parameters for collections, and no comments describing the more complex UI list models. Overall still easy to follow.","tokens":915,"name":"158.jsnp"}
{"score":"97","reasoning":"Simple and concise conditional logic with clear intent and descriptive flag names. Control flow is straightforward with no nesting, making it easy to follow. Readability is very high, though the roles of hasLf and hasCr are not explicitly documented within this snippet.","tokens":661,"name":"6.jsnp"}
{"score":"82","reasoning":"Code is structurally clear, with a simple for loop and a single method call, and naming indicates purpose well. However, repeated long getter calls with array indexing reduce readability and conciseness. Extracting values into local variables would improve comprehension. Overall it is reasonably easy to understand.","tokens":951,"name":"105.jsnp"}
{"score":"92","reasoning":"Clear JavaDoc and descriptive names make intent obvious. Control flow is straightforward with simple null checks and explicit error handling. Indentation and structure are consistent. Slight verbosity with else after returns and explicit casting in the exception handler, but these do not significantly reduce readability. Overall, the code is easy to follow.","tokens":657,"name":"164.jsnp"}
{"score":"82","reasoning":"Code is reasonably readable with clear method and class names, consistent indentation, and straightforward control flow. Anonymous inner classes are used appropriately but add some nesting complexity. Limited comments or documentation slightly reduce ease of comprehension, though intent of transaction manager and cache manager overrides is still clear.","tokens":625,"name":"132.jsnp"}
{"score":"92","reasoning":"Code is concise and easy to follow with meaningful method and variable names and clear control flow. Exception construction and stack trace handling are straightforward. Minor style issues like inconsistent spacing and reliance on external fields slightly reduce clarity but overall readability is high.","tokens":847,"name":"125.jsnp"}
{"score":"82","reasoning":"Well formatted and documented method, clear intent and consistent style. Variable names are descriptive and logic is straightforward, though the repeated shift operations are slightly verbose and require some mental effort to verify correctness. A small loop or library utility could improve clarity and reduce repetition.","tokens":839,"name":"113.jsnp"}
{"score":"92","reasoning":"Clear method purpose with Javadoc and descriptive names; loop logic is straightforward; event creation is lazy but well explained in comments. Indentation is slightly inconsistent and use of raw Object arrays reduces type clarity, but overall the code is easy to follow and well structured.","tokens":771,"name":"9.jsnp"}
{"score":"88","reasoning":"The test method is concise and readable, with descriptive names and a clear Arrange Act Assert flow. The use of thrown.expectMessage and TIMEOUT + 50 makes the intent explicit. The empty catch block slightly hurts readability because it silently ignores the exception without explaining why, but overall comprehension remains easy.","tokens":833,"name":"160.jsnp"}
{"score":"78","reasoning":"Clear control flow and meaningful method name help readability. Use of early returns and spacing is mostly consistent. However, inconsistent brace style, repeated getPersister calls, and a confusing first branch due to negation and tracker naming reduce ease of understanding somewhat.","tokens":1320,"name":"111.jsnp"}
{"score":"94","reasoning":"Clear and concise JUnit test. Method name is descriptive, variables are well named and final, and the SQL strings are readable despite their length. The structure is straightforward and the assertion is easy to understand. Minor readability issue from long SQL literals, but overall very understandable.","tokens":1023,"name":"24.jsnp"}
{"score":"92","reasoning":"Code is well formatted, uses descriptive names and clear control flow. The try catch structure and early return make execution easy to follow. Long chained calls and framework specific types add slight cognitive load, but overall readability and intent are very good.","tokens":878,"name":"33.jsnp"}
{"score":"80","reasoning":"Code is structurally simple and easy to trace with clear logging and straightforward conditions though there is duplicated logic and repetitive facade calls variable names like eo and me are not very descriptive and lack of generics and comments slightly reduces readability overall still quite understandable","tokens":1338,"name":"119.jsnp"}
{"score":"88","reasoning":"Clear Java hashCode implementation with consistent formatting, meaningful variable names and simple control flow. Null checks are explicit and logic is easy to follow. Slightly non-idiomatic ordering of multiplication and addition and missing use of a more standard helper like Objects.hash reduce clarity a bit.","tokens":615,"name":"141.jsnp"}
{"score":"94","reasoning":"Clear method name and intent, consistent naming and straightforward set construction. Use of specific Set and HashSet types aids understanding. Minor verbosity such as explicit package qualification and absence of the diamond operator, but these do not significantly affect readability.","tokens":758,"name":"16.jsnp"}
{"score":"88","reasoning":"Code is clean and readable with descriptive method and variable names, consistent indentation and straightforward assertions. Domain specific classes reduce immediate comprehension for newcomers, but control flow is linear and clear. Overall it is easy to understand as a focused unit test.","tokens":816,"name":"142.jsnp"}
{"score":"86","reasoning":"The test is concise and logically ordered, with clear transaction flow and meaningful domain class and variable names. Queries are straightforward and responsibilities within the method are obvious. Minor drawbacks are the single letter session variable and reliance on suppression annotation, but overall the code is readable and easy to understand.","tokens":916,"name":"80.jsnp"}
{"score":"94","reasoning":"Code is well formatted with clear indentation and naming, and the inner Verifier class is small and focused. Comments describe intent, and the traversal logic is straightforward and easy to follow. Minor drawbacks are the somewhat dense condition within the loop and use of Stack instead of a clearer queue type.","tokens":1245,"name":"87.jsnp"}
{"score":"78","reasoning":"Readable and concise with consistent indentation and clear control flow, variable names are acceptable though somewhat generic, duplicated logic for table handling could be refactored and null checks for the selected object are only implicit, overall the method is easy to understand but not exemplary","tokens":979,"name":"10.jsnp"}
{"score":"90","reasoning":"Clear method and variable names, linear control flow, and standard JAXB usage make the code easy to read. Generics are used appropriately and formatting is consistent. Absence of comments and not using try with resources slightly reduce clarity and modern style, but overall comprehension remains high.","tokens":807,"name":"194.jsnp"}
{"score":"86","reasoning":"Readable Java method with clear names and straightforward control flow. Event type checks and instanceof usage are easy to follow. Some duplication of conditions and repeated event.getEventType calls slightly hurt clarity. Range based event type checks require domain knowledge but overall comprehension remains high.","tokens":1378,"name":"43.jsnp"}
{"score":"88","reasoning":"Well structured JUnit test with clear variable names and logical flow. Indentation and spacing are consistent. Comments explain intent, though there are minor typos and slightly verbose wording. Overall the code is highly readable and easy to follow, with a straightforward control flow and clear assertions demonstrating expected behavior.","tokens":952,"name":"56.jsnp"}
{"score":"92","reasoning":"Clear JUnit test with descriptive name, consistent indentation and spacing. Query string and filters are readable, with logical flow from control to filtered queries. Comments help understanding. Minor downsides are the long method name, use of a raw List, and positional parameters, but overall comprehension is easy.","tokens":1007,"name":"91.jsnp"}
{"score":"88","reasoning":"Clear method and variable names, consistent formatting, and straightforward control flow make the test easy to follow. Boolean flags slightly reduce readability and the nested anonymous class with try blocks adds some visual noise, but overall comprehension remains high.","tokens":1112,"name":"173.jsnp"}
{"score":"88","reasoning":"Readable Java method with clear naming, consistent indentation and straightforward control flow. The flush flag expression is somewhat dense but uses descriptive method names, so the intent remains clear. Overall structure is concise and responsibilities are well separated, making comprehension easy.","tokens":1354,"name":"184.jsnp"}
{"score":"95","reasoning":"The code is highly readable, with clear Javadoc, straightforward control flow, and consistent formatting. Early returns make the logic easy to follow, and the type check plus cast are standard and understandable. Variable names are concise and descriptive. Overall, the method intent and behavior are immediately clear to the reader.","tokens":835,"name":"114.jsnp"}
{"score":"90","reasoning":"Code is well-structured, with clear naming, proper exception handling, and straightforward control flow. Reflection use is idiomatic and branching is easy to follow. The introductory comment is nontechnical but unobtrusive. Minor verbosity and casting complexity, but overall readability and comprehension are high.","tokens":811,"name":"2.jsnp"}
{"score":"92","reasoning":"Clear, concise Java Swing constructor with meaningful names and consistent formatting. Table configuration steps are logically grouped, making the flow easy to follow. Minimal comments are acceptable because the code is largely self explanatory. Small redundancy in calling setAutoResizeMode twice slightly detracts, but overall readability is high.","tokens":813,"name":"118.jsnp"}
{"score":"93","reasoning":"Clear and idiomatic Java equals implementation with good structure and meaningful variable names null checks and class checks are easy to follow minimal nesting and consistent formatting make it very readable and understandable","tokens":642,"name":"169.jsnp"}
{"score":"88","reasoning":"Well formatted JUnit test with clear purpose and structure, descriptive method name, and proper try catch finally usage. The intent of forcing a SQL grammar error is evident. Readability is slightly reduced by the long chained method calls, explicit casting, and anonymous inner class, but overall it remains easy to understand.","tokens":768,"name":"94.jsnp"}
{"score":"68","reasoning":"Clear structure and indentation, but long chained conditions reduce readability. Repetition for primitive and wrapper comparisons could be simplified with helper methods or utilities. Commented out blocks and inconsistent equals usage add noise and potential confusion, though the intent remains understandable.","tokens":1579,"name":"74.jsnp"}
{"score":"88","reasoning":"Readable Java method with clear purpose and straightforward control flow. The overwrite confirmation and early return logic are easy to understand. Try finally usage for stream closing is standard. Slightly reduced clarity due to the non descriptive variable name fo and somewhat dense dialog construction, but overall the code is still easy to follow.","tokens":903,"name":"49.jsnp"}
{"score":"88","reasoning":"Clear method structure, consistent indentation and spacing, descriptive names for parameters and local variables, and straightforward control flow. Limited nesting and early return improve readability. Minor issues are the lengthy method name, reliance on external metadata context, and slightly noisy comment lines, but overall comprehension is high.","tokens":783,"name":"147.jsnp"}
{"score":"90","reasoning":"Code is short and well structured, with clear method and parameter names and consistent indentation. Logic with null check and try catch is straightforward. The long chained call is slightly dense, and catching Throwable is debatable, but overall readability and comprehension remain high.","tokens":783,"name":"95.jsnp"}
{"score":"92","reasoning":"Code is concise and readable, with clear method and variable names. The nested loops are straightforward and the comment explains field ordering well. Use of helper methods for sorting and adding improves clarity. Generics and long parameter list add minor complexity but overall structure remains easy to understand.","tokens":639,"name":"52.jsnp"}
{"score":"93","reasoning":"The code is concise, well formatted, and uses clear naming. The Javadoc accurately describes the test intent, making the purpose easy to understand. Anonymous inner class usage is straightforward, with a single overridden method that clearly adds the listener. Slight indirection through the abstract base test adds minor complexity but overall readability remains high.","tokens":547,"name":"53.jsnp"}
{"score":"90","reasoning":"Clear method purpose with Javadoc and descriptive names. Control flow in the loop and transaction handling is straightforward. Comments document the double iteration concern. Generic bounds and nested try and finally blocks introduce some complexity but are still readable. Overall it is well structured and understandable.","tokens":1383,"name":"110.jsnp"}
{"score":"95","reasoning":"The code is highly readable and concise, with a simple constructor and clear registration of type mappings. Naming and indentation are consistent and there is no complex logic, making comprehension straightforward. A minor improvement would be adding a brief class level description for broader context.","tokens":1440,"name":"25.jsnp"}
{"score":"90","reasoning":"Clear Java test with descriptive names and helpful comments. Control flow is straightforward and session lifecycle is explicit. Minor style issues like mixed indentation and long comments slightly reduce readability but overall it is easy to understand.","tokens":1162,"name":"78.jsnp"}
{"score":"82","reasoning":"Code has clear names and comment, logic mostly linear and easy to follow. StringBuilder use is straightforward. Readability is hurt by lack of typed List, a dense selectFragment call with inline conditionals, and domain specific concepts that require prior knowledge.","tokens":1517,"name":"34.jsnp"}
{"score":"88","reasoning":"Clear structure with two separated loops, meaningful variable names and helpful comments. Consistent indentation and straightforward conditions. Minor redundancy and small confusion potential in the second loop logic but overall easy to read and understand.","tokens":1222,"name":"27.jsnp"}
{"score":"90","reasoning":"Clear test purpose, descriptive method name and targeted queries. Consistent structure and simple control flow make it easy to follow. Inline remarks, though informal, help explain intent. Slight confusion arises from heavy reuse of keywords as identifiers, but still readable.","tokens":917,"name":"86.jsnp"}
{"score":"93","reasoning":"Clear JUnit test with straightforward control flow and descriptive names. The try catch structure and assertions are easy to follow, and indentation is consistent. Boolean variable names are somewhat verbose but still improve clarity. Overall, the code is very readable and easy to understand.","tokens":963,"name":"161.jsnp"}
{"score":"93","reasoning":"Very readable Java constructor delegating to another with well named constants and inline comments clarifying boolean parameters. Indentation and formatting are clean. Only minor issue is the many positional arguments, which might be harder to modify or extend later, but for default configuration it remains easy to understand.","tokens":662,"name":"4.jsnp"}
{"score":"92","reasoning":"Code is very readable thanks to clear naming, simple control flow, and consistent formatting. Object creation and persistence steps are ordered logically, with no nested logic to obscure intent. Minor readability issues include use of hardcoded string values and absence of brief comments about the test scenario, but overall comprehension is easy.","tokens":915,"name":"76.jsnp"}
{"score":"60","reasoning":"Indentation and structure are clear, and the cleanup flow and transaction lifecycle are straightforward. However, the heavy use of single-letter variable and class names significantly reduces readability and makes the associations between objects hard to understand. No comments or logical grouping further limits ease of comprehension despite otherwise simple control flow.","tokens":806,"name":"200.jsnp"}
{"score":"92","reasoning":"Clear Java method registering transaction factories, descriptive class and method names, consistent formatting and simple control flow. Slight repetition but still easy to follow and maintain. Lack of comments is acceptable since intent is obvious.","tokens":823,"name":"171.jsnp"}
{"score":"88","reasoning":"Code is concise and logically structured with standard equals pattern and early returns. Naming is mostly clear though cidDetailID is slightly confusing. Ternary based null checks are correct but a bit dense and could be more readable using Objects.equals. Overall it is easy to follow for experienced Java developers.","tokens":685,"name":"70.jsnp"}
{"score":"86","reasoning":"Readable JUnit test with clear trycatchfinally structure and meaningful logging. Variable names and assertions express intent well. Formatting and indentation are consistent. Use of raw Iterator without generics and a very long assertion message slightly reduce clarity, but overall comprehension remains high.","tokens":1017,"name":"137.jsnp"}
{"score":"88","reasoning":"Clear method with good comments and naming simple loops duplicated code block could be extracted and use of raw Vector and casts is outdated but readability remains high overall","tokens":1196,"name":"121.jsnp"}
{"score":"88","reasoning":"Code is well structured and formatted with clear method and variable names. Test flow from setup to assertions and cleanup is straightforward. Use of an anonymous inner class for JDBC work adds minor noise but remains understandable. Inline SQL string is simple. Overall the code is easy to read and comprehend.","tokens":1090,"name":"69.jsnp"}
{"score":"90","reasoning":"Clear and concise unit test with a descriptive name and simple assertion, consistent indentation and spacing, no complex logic or control structures, only minor nesting from method calls, so readability and comprehension are high.","tokens":861,"name":"165.jsnp"}
{"score":"70","reasoning":"Code logic is understandable and uses meaningful method names, but readability suffers from deep nested conditionals, reuse of nod and comp temp variables, commented out code and mixed responsibilities in one method. Lack of generics and modern constructs also hurts clarity. Overall moderately readable but not clean.","tokens":1206,"name":"155.jsnp"}
{"score":"90","reasoning":"Clear Java method with good naming, consistent indentation, and straightforward control flow. Chained method calls are a bit dense but still understandable. No misleading constructs, comments not needed. Overall easy to follow for someone familiar with ORM style code.","tokens":949,"name":"182.jsnp"}
{"score":"72","reasoning":"Consistent formatting and a descriptive method name make the intent mostly clear. However, nested calls with inline boolean arrays and long lines hurt readability, and heavy repetition suggests it could be refactored into a loop or helper, improving clarity and reducing duplication.","tokens":1322,"name":"59.jsnp"}
{"score":"80","reasoning":"Readable Java test method with consistent naming and clear flow. Hibernate queries are straightforward but packed into long strings, making them harder to scan. Reuse of a raw List results variable without generics slightly reduces clarity. The lack of comments or assertions limits understanding of the precise test intent beyond exercising various expressions.","tokens":1331,"name":"83.jsnp"}
{"score":"93","reasoning":"Naming is clear and expressive, structure is simple, and indentation is consistent. Anonymous listener is concise and its purpose is obvious. Limited control flow and small scope make the code easy to follow.","tokens":1595,"name":"124.jsnp"}
{"score":"93","reasoning":"Clear Java test with meaningful names consistent indentation and logical steps using criteria API Comment helps context Generics may look slightly verbose but flow remains easy to follow Overall highly readable","tokens":912,"name":"163.jsnp"}
{"score":"84","reasoning":"Clear constructor with consistent null checks and descriptive method names. Use of ternary operators and long generic type expressions slightly hurts readability, and the repeated pattern could be refactored, but overall the logic is straightforward and easy to follow.","tokens":785,"name":"196.jsnp"}
{"score":"90","reasoning":"Readable Java snippet using an anonymous Thread class with clear structure and minimal nesting; intent to run a test asynchronously is easy to infer; comments are concise; naming is adequate though adding a more descriptive thread name or extracting logic to a named class could slightly improve clarity","tokens":619,"name":"1.jsnp"}
{"score":"88","reasoning":"Code is well structured with clear method purpose, meaningful names and helpful comments. Loop logic is straightforward and side effects are explicit. Domain specific types add some complexity but overall flow remains easy to follow and maintain.","tokens":1084,"name":"66.jsnp"}
{"score":"90","reasoning":"Code is concise with clear method and variable names and consistent formatting. The purpose of the method and the constructed strategy is easy to infer. Long class names slightly reduce quick readability, but overall structure and flow remain straightforward and highly comprehensible.","tokens":540,"name":"143.jsnp"}
{"score":"90","reasoning":"Clear test structure, meaningful method name, and focused comments aid comprehension. HQL query strings are repetitive but consistently formatted. Indentation and spacing are good, though the long method name and dense sequence of similar SyntaxChecker calls slightly reduce scanability. Overall, the snippet is easy to read and understand.","tokens":1163,"name":"79.jsnp"}
{"score":"82","reasoning":"Readability is high with clear structure, meaningful names, and consistent indentation. Control flow is straightforward and comments explain dialect specific logic. However, long inline SQL strings and lack of generic types for List reduce clarity slightly, as does mixing concerns of setup, execution, and assertions in one method.","tokens":1124,"name":"71.jsnp"}
{"score":"90","reasoning":"Code is well formatted and easy to follow. Variable and class names are descriptive, indentation is consistent, and the pattern of listener registration is clear. However, there is some repetitive boilerplate that could be refactored or commented to further improve readability and maintainability.","tokens":903,"name":"139.jsnp"}
{"score":"88","reasoning":"Code is concise and easy to follow, with a clear method name and straightforward logic collecting dependencies from the facade. Control flow is simple with an early return pattern. Readability is slightly reduced by the use of raw Set and HashSet without generics and minor indentation inconsistencies, but overall it is quite clear.","tokens":841,"name":"123.jsnp"}
{"score":"90","reasoning":"Readable test method with clear property setup and assertions. Consistent naming and straightforward control flow, though long property keys and dense chained calls reduce clarity slightly. Overall still easy to understand at a glance.","tokens":1267,"name":"130.jsnp"}
{"score":"90","reasoning":"Readable and concise code, clear method name and purpose, switch statement is straightforward and comments explain each SQL state. Use of magic numeric codes hurts self documentation somewhat but comments mitigate this. Error handling is simple and consistent. Overall easy to follow with minor room for improvement by extracting constants.","tokens":918,"name":"22.jsnp"}
{"score":"82","reasoning":"Clear intent and logic, supported by a good doc comment. Control flow is straightforward and variable names are descriptive, making the method easy to follow. Readability is reduced slightly by the use of raw Class and Enumeration types, absence of generics, and old style collection API, plus minor indentation inconsistency. Overall still quite understandable.","tokens":881,"name":"44.jsnp"}
{"score":"93","reasoning":"Clear unit test with descriptive method and variable names, logical grouping of assertions, consistent formatting, and straightforward cache mode checks. Slight reduction for explicit casting and somewhat verbose constant usage, but overall very easy to follow and maintain.","tokens":1217,"name":"162.jsnp"}
{"score":"92","reasoning":"Clear JavaDoc, descriptive method and parameter names, and simple branching based on entity mode make this code highly readable. Consistent formatting and explicit exception handling help comprehension. Minor issues include combining null and POJO checks in one condition and a vague TODO note, but they do not significantly impact clarity.","tokens":784,"name":"32.jsnp"}
{"score":"92","reasoning":"Clear unit test with descriptive name and helpful inline comments. Logical flow is linear and easy to follow. Variable names are mostly meaningful, with only sr slightly cryptic. Overall structure and spacing aid comprehension; exception handling is explicit. Minor issue: domain knowledge needed to grasp subtle behavior.","tokens":1383,"name":"75.jsnp"}
{"score":"90","reasoning":"Code is short and well structured, with clear method and variable names, consistent indentation and useful error message. Condition branches are understandable but the chained equality checks make the main if slightly dense. Overall the intent is clear and it is easy to maintain.","tokens":1141,"name":"29.jsnp"}
{"score":"85","reasoning":"Code is short, idiomatic and focused. Method and helper names clearly convey intent. Assertions show pre and post conditions of starting a transaction. Chaining for session creation is long but still understandable. Minor readability issue from repeated transaction manager access without a local variable.","tokens":968,"name":"128.jsnp"}
{"score":"82","reasoning":"Readable Java method with clear structure, good indentation and simple control flow. Variable names are mostly understandable but could be more descriptive than f, fr and mAry. Using StringBuilder and try with resources would improve clarity. Lack of high level comment about file format slightly reduces ease of comprehension.","tokens":859,"name":"48.jsnp"}
{"score":"88","reasoning":"Clear structure with meaningful method and variable names and consistent formatting. The test intent is obvious and the Hibernate session lifecycle is straightforward to follow. Use of raw List instead of generics slightly reduces type clarity, but overall the snippet remains easy to read and understand as a focused test case.","tokens":830,"name":"77.jsnp"}
{"score":"85","reasoning":"Code is readable and logically structured, with clear control flow and consistent formatting. Hex digit handling via switch and matchRange is easy to follow. However, legacy ANTLR style, extra boilerplate around token creation, and minimal comments slightly reduce overall ease of comprehension.","tokens":956,"name":"117.jsnp"}
{"score":"94","reasoning":"Very readable equals implementation using standard pattern. Clear structure, helpful Javadoc, descriptive names and straightforward null handling. Loops are simple and logic is easy to follow. Lacks minor comments on performance implications but overall it is highly understandable.","tokens":826,"name":"40.jsnp"}
{"score":"94","reasoning":"Clear and concise Java serialization method with good naming and Javadoc. Consistent formatting and straightforward sequence of operations make it easy to read and maintain. Slight dependency on external SerialUtilities methods, but overall logic is immediately understandable and well structured.","tokens":835,"name":"38.jsnp"}
{"score":"82","reasoning":"Clear naming and consistent style make the logic fairly easy to follow. Indentation is good and responsibilities are obvious. However, nested conditionals increase cognitive load, and normalization logic is duplicated, which slightly reduces readability and could be improved by extracting helper methods.","tokens":922,"name":"30.jsnp"}
{"score":"87","reasoning":"Readable Java test method with clear naming and straightforward control flow. Nested try catch finally is a bit dense but still understandable. Consistent indentation and simple logic make comprehension easy. Minor improvement possible by reducing nesting or extracting helper methods.","tokens":743,"name":"129.jsnp"}
{"score":"90","reasoning":"Clean and consistent formatting, descriptive names and clear setup of entities and relationships make the test easy to follow. Comment block explains intent well. Only minor issue is the long, chained expression inside assertEquals, which slightly hurts readability but remains understandable.","tokens":1844,"name":"134.jsnp"}
{"score":"90","reasoning":"The test is short, well-indented, and uses descriptive names for methods and variables, making the control flow clear. Assertions are logically grouped to show state changes over time. Some repetition and Hibernate or JTA specific details may slow initial understanding, but overall readability and intent are strong.","tokens":945,"name":"127.jsnp"}
{"score":"90","reasoning":"Simple and readable Java method with clear intent and straightforward control flow. Naming is descriptive and the use of constants aids comprehension. The only minor drawbacks are the repetitive Vector initialization and the absence of generics, which make the style look outdated but do not significantly reduce clarity.","tokens":752,"name":"45.jsnp"}
{"score":"80","reasoning":"Short method with clear control flow and meaningful names, but uses raw types without generics, overly generic Object parameters, and legacy Vector and Collection APIs. Lack of type safety and documentation slightly reduces readability, yet logic is still easy to follow overall.","tokens":853,"name":"120.jsnp"}
{"score":"88","reasoning":"Clear structure, descriptive names and helpful comments make the method easy to follow. Control flow is straightforward with early returns and limited nesting. Generics add some complexity but are standard and consistent. Domain specific types may slow newcomers, yet overall readability and intent remain high.","tokens":1257,"name":"84.jsnp"}
{"score":"92","reasoning":"The method is straightforward and idiomatic for Java toString implementations, using a chained StringBuilder and clear field names. Indentation and structure are consistent, making it easy to follow. Readability could be slightly improved with spaces after commas or by using a more structured formatter, but overall it is very clear and maintainable.","tokens":595,"name":"63.jsnp"}
{"score":"78","reasoning":"Code is mostly readable with consistent formatting and clear structure. The comment explains intent and the logic is straightforward. However, duplicated blocks for incoming and outgoing, use of raw Collection and Object types, and the use of \u003d\u003d for string comparison slightly reduce clarity and ease of understanding.","tokens":910,"name":"154.jsnp"}
{"score":"82","reasoning":"Code is generally readable with clear control flow and option handling logic. Names are descriptive and indentation is consistent. Nested conditionals and manual index manipulation inside the loop make it slightly harder to follow, but overall the behavior remains understandable for a typical reader.","tokens":1186,"name":"15.jsnp"}
{"score":"84","reasoning":"Code is generally clear with descriptive method and variable names, straightforward control flow, and proper null checks. Indentation is mostly consistent. Readability is slightly reduced by repeated getJComponent calls and commented out legacy code that adds minor visual noise.","tokens":842,"name":"122.jsnp"}
{"score":"90","reasoning":"Method is short and clearly focused on printing comparison data. Uses informative labels, straightforward concatenation and a helper to join suffixes. Banner style separators make the output easy to scan. Minor issue is reliance on direct console printing, but this does not reduce comprehension.","tokens":920,"name":"144.jsnp"}
{"score":"78","reasoning":"Code is mostly readable with clear structure and consistent indentation. Domain specific names help, but lack of comments and some dense logic hurt quick understanding. Long method, magic string integer, inline if, and short variable names like ib and value reduce clarity, yet overall flow is still followable for experienced Java readers.","tokens":1170,"name":"109.jsnp"}
{"score":"88","reasoning":"Clear JUnit test structure, consistent indentation, and straightforward assertions make the snippet easy to read. Long entity class names reduce readability slightly but are still descriptive. Some duplication could be refactored yet does not hurt comprehension much.","tokens":819,"name":"185.jsnp"}
{"score":"88","reasoning":"Clear JUnit style test with a descriptive method name and well structured steps. Hibernate session operations and transaction boundaries are easy to follow, and comments clarify the natural id cache behavior. Minor drawbacks are the non descriptive variable name it and a typo in the assertion message, but overall readability and comprehension are high.","tokens":1084,"name":"179.jsnp"}
{"score":"88","reasoning":"Code is concise and well structured, with descriptive method and variable names and straightforward control flow. Use of boolean flags makes intent clear, though slightly verbose and could be simplified. Dependency on helper methods is understandable from context. Overall, the logic is easy to follow and maintain.","tokens":951,"name":"195.jsnp"}
{"score":"85","reasoning":"Clear unit test structure with descriptive names and consistent assertion pattern, making the sequence of generated values easy to follow. Comments provide good context, though one seems outdated relative to the asserted value, and session casting is a bit noisy, slightly reducing overall clarity.","tokens":1106,"name":"17.jsnp"}
{"score":"90","reasoning":"Clear structure using type checks, meaningful names, and straightforward control flow. Readable handling of different Test implementations and recursive suite description building. Comment clarifies fallback case. Slight verbosity due to repeated instanceof and casts, but overall the code is easy to understand and maintain.","tokens":947,"name":"54.jsnp"}
{"score":"78","reasoning":"Code is concise and mostly clear. Naming is reasonable and control flow is straightforward. Exception messages are descriptive, though a bit verbose. The use of getSqlTypeCode inside a similarly named method may cause confusion, and catching generic Exception slightly hurts readability.","tokens":1004,"name":"37.jsnp"}
{"score":"86","reasoning":"Readable Java with clear conditions and consistent formatting. Use of well named constants aids understanding and error messages clarify failure cases. However, the long else if chain and repeated index and element handling reduce elegance and make future extension less straightforward.","tokens":1293,"name":"108.jsnp"}
{"score":"86","reasoning":"Readable and well structured: clear parameter names, consistent indentation and simple control flow. Use of temporary variable v and model facade calls is straightforward. Lack of generics and type information for List and Iterator slightly hurts clarity but overall comprehension is easy.","tokens":1587,"name":"8.jsnp"}
{"score":"84","reasoning":"Code is well indented, with descriptive names and clear separation of loops. Logic is straightforward, though use of EntityFetch and CompositeFetch checks via class methods slightly hurts clarity. Overall flow is easy to follow with limited nesting and consistent style, so readability is relatively high.","tokens":1171,"name":"197.jsnp"}
