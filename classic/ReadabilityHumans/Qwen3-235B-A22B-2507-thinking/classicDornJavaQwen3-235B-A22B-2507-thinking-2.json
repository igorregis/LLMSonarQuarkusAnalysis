{"score":"85","reasoning":"The code demonstrates good readability with clear class and method names indicating test purpose Proper indentation and descriptive method calls like selenium.open enhance comprehension However the snippet is incomplete missing closing braces which reduces structural clarity and could confuse readers unfamiliar with the framework context The use of standard testing patterns aids understanding but incomplete syntax slightly impacts overall ease of comprehension","tokens":647,"name":"191.jsnp"}
{"score":"55","reasoning":"The code has logical structure but suffers from poor readability due to undefined macros like BETTER_THAN which obscure comparison logic Magic numbers 0 2f and 0 4f lack context Variable names like dif are ambiguous and reduce clarity Consistent indentation helps but absence of comments and unclear intent hinder comprehension significantly for maintainability and understanding","tokens":1077,"name":"112.jsnp"}
{"score":"92","reasoning":"The code is well-structured with comprehensive Javadoc explaining each parameter and method purpose. Clear naming conventions except for non-standard \u0027a\u0027 prefixes in parameters like aColumnName which slightly reduces readability. Logical flow from constructors to setters getters. Minimal complexity with straightforward assignments. Missing Javadoc for no-arg constructor is minor issue. Excellent documentation compensates for minor naming quirks making it highly comprehensible","tokens":1360,"name":"221.jsnp"}
{"score":"25","reasoning":"The code snippet exhibits poor readability due to an empty catch block which hides exceptions without logging or handling making debugging difficult Thread sleep with magic number 1000 lacks context or comment explaining its purpose The XPath selector is brittle and unclear without documentation The abrupt closing braces at start confuse code structure Overall the snippet lacks comments meaningful variable names and error handling clarity severely hindering comprehension","tokens":1121,"name":"174.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear test structure with descriptive method names and explicit timeout handling. However the empty catch block and non-standard for loop reduce readability. The selenium-based waiting pattern is common in test automation but modern practices would prefer WebDriverWait for better clarity. The purpose remains understandable despite minor readability issues in exception handling and loop structure","tokens":1264,"name":"212.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear getter methods and standard Java practices. Field names use underscores which is slightly outdated but still comprehensible. Overridden hashCode and equals methods follow correct patterns with proper documentation. Minor deduction for underscored private fields and indirect comparison via getSimpleName in equals method but overall structure is clean and easy to understand","tokens":1580,"name":"150.jsnp"}
{"score":"92","reasoning":"The code demonstrates strong readability with clear variable names like tablesSQL and descriptive method calls such as StringUtilread The logical flow for database updates and upgrade checks is well-structured using meaningful conditionals String concatenation for logging is straightforward though slightly verbose due to line breaks The abrupt ending is inherent to the snippet format not a code flaw Overall excellent comprehension with minor room for string handling refinement","tokens":1714,"name":"103.jsnp"}
{"score":"88","reasoning":"The code demonstrates strong readability with clear structure and meaningful naming. Proper use of interfaces for i18n strings enhances maintainability. Comments effectively explain internationalization setup. Minor deductions for verbose imports and unconventional inner interface usage which slightly increases cognitive load. Overall well-organized with logical flow and standard Java conventions followed","tokens":834,"name":"172.jsnp"}
{"score":"70","reasoning":"Code exhibits high duplication with identical try-catch blocks across methods reducing readability. Each method follows clear structure but repeated error handling logic creates unnecessary noise. Consistent naming aids comprehension yet boilerplate code lowers maintainability and clarity. Logging call format may confuse but overall flow is straightforward. Score reflects balance between simplicity and redundancy","tokens":1263,"name":"140.jsnp"}
{"score":"92","reasoning":"The code exhibits strong structure with logical flow in getColor method using cache check compute and store pattern. Meaningful variable names like colorMap and sID enhance clarity. However raw Map type without generics and catching generic Exception reduce modern readability slightly. Commented log statement is minor distraction but common practice. Overall well organized for experienced Java developers","tokens":1950,"name":"166.jsnp"}
{"score":"55","reasoning":"The code snippet shows Selenium test steps but lacks context for control flow. The use of continue without visible loop and abrupt case 2 label confuse readers. Hardcoded strings and locators reduce clarity. Repetitive waitForPageToLoad and loadRequiredJavaScriptModules are acceptable but could be refactored. The incomplete structure and unclear jump logic lower readability significantly despite straightforward test actions","tokens":1272,"name":"193.jsnp"}
{"score":"90","reasoning":"The code demonstrates clear structure with concise methods and logical flow Each method handles specific responsibilities with appropriate null checks and exception handling Variable names like _events and _portletRequestImpl while using non standard leading underscores are consistent and contextually meaningful The absence of comments is compensated by self explanatory method names and straightforward logic Incomplete try block in snippet does not significantly hinder comprehension as core patterns remain evident","tokens":1966,"name":"131.jsnp"}
{"score":"92","reasoning":"Code exhibits strong readability with clear method names and consistent structure. Repetitive null checks are straightforward and easy to follow. Logging usage is appropriate and warnings are descriptive. Minimal repetition does not significantly hinder comprehension. Incomplete methods at snippet boundaries are minor issues. Overall logical flow is intuitive for Java developers","tokens":1519,"name":"116.jsnp"}
{"score":"92","reasoning":"The code exhibits strong readability with clear structure consistent indentation and meaningful naming conventions. Helpful comments explain critical constraints like the UPDATE_DIR warning. The logic in checkForFailedInstalls is straightforward using standard Java I/O patterns. Minor deduction for the unused files variable declaration in the visible snippet causing slight confusion and the abrupt truncation mid-method which interrupts flow. Overall comprehension remains high due to excellent organization and self-documenting elements","tokens":2474,"name":"151.jsnp"}
{"score":"100","reasoning":"The code exhibits exceptional readability with consistent JavaBean naming conventions clear Javadoc comments for each method and straightforward getter setter logic No complex structures or ambiguous naming exist The uniform pattern across all methods enhances comprehension significantly while proper indentation and descriptive parameter names ensure immediate understanding of each components purpose The thorough documentation aligns with standard Java practices making it ideal for maintenance and onboarding","tokens":1312,"name":"136.jsnp"}
{"score":"90","reasoning":"The code snippet demonstrates clear Java Swing practices with well-structured methods. paintComponent correctly sets size and delegates to super. remove and addImpl properly manage component listeners and layout updates. Consistent indentation and standard Swing method names enhance readability. Minor deductions for the incomplete constructor fragment at start and lack of context for _app assignment which isn\u0027t used in shown methods. No comments but operations follow expected Swing patterns making comprehension straightforward for experienced developers","tokens":2360,"name":"170.jsnp"}
{"score":"60","reasoning":"The code uses an unnecessary switch inside a while loop with a static label value making the structure confusing and redundant. The timeout logic with a for loop is standard but obscured by poor control flow design. Lack of comments explaining the test teardown purpose reduces clarity. Proper indentation helps readability but the overall pattern suggests auto-generated code with low maintainability. Variable names like label do not convey intent and the infinite loop pattern is hard to follow for comprehension","tokens":1267,"name":"102.jsnp"}
{"score":"95","reasoning":"The code snippet consists of well-organized imports with clear naming conventions following Java standards Liferay-specific packages are logically grouped before standard Java libraries Class names like LogFactoryUtil and SortedProperties effectively communicate their purpose indicating good readability and ease of understanding for developers familiar with the ecosystem Minimal complexity in this boilerplate section contributes to high comprehension","tokens":2352,"name":"208.jsnp"}
{"score":"90","reasoning":"The code exhibits strong readability with clear variable and method names such as logoId group and isStagingGroup which convey intent effectively Logical flow is straightforward with minimal nesting and consistent structure The try-catch blocks and conditional checks are easy to follow though the absence of comments and use of generic Exception handling slightly reduce immediate clarity for new readers Overall the organization and naming conventions support comprehension without unnecessary complexity","tokens":2564,"name":"101.jsnp"}
{"score":"55","reasoning":"The code snippet lacks context making control flow ambiguous. The empty catch block is a significant anti-pattern that hides errors and reduces debuggability. The fail statement appears disconnected from the try block which contains a break suggesting a loop not visible. These factors severely hinder comprehension.","tokens":2488,"name":"192.jsnp"}
{"score":"72","reasoning":"The code is procedural and clear in its Selenium test steps but suffers from magic numbers like 30000 and 90 without explanation. Repetitive waitForPageToLoad and loadRequiredJavaScriptModules calls could be abstracted. Variable names are acceptable but not highly descriptive. The incomplete structure missing closing braces in the snippet slightly reduces readability. Overall moderately readable for Selenium tests but could be improved with constants and helper methods","tokens":1182,"name":"157.jsnp"}
{"score":"62","reasoning":"The code is a linear Selenium test with repetitive patterns click wait load that could be abstracted. Long file path string is hard to read. Manual wait loop is verbose and error-prone instead of using explicit waits. Lack of comments. RuntimeVariables.replace aids data parameterization but without context. Understandable for Selenium experts but poor structure reduces maintainability and clarity","tokens":1812,"name":"198.jsnp"}
{"score":"90","reasoning":"The code snippet exhibits strong readability with clear method names like testDynamicQueryByProjectionMissing and testResetOriginalValues that immediately convey test purpose. Variables are meaningfully named dynamicQuery result existingRatingsEntryModelImpl. Logical flow follows standard test structure setup execution assertion. Helper method addRatingsEntry reduces duplication and uses descriptive random data generators. Framework-specific utilities like DynamicQueryFactoryUtil are consistently applied with self-explanatory method names property in. Minor deduction for the initial assertEquals fragment lacking context but overall comprehension remains high due to consistent patterns and focused test cases","tokens":1553,"name":"204.jsnp"}
{"score":"88","reasoning":"The code demonstrates clear structure with well-named methods and variables following consistent patterns. Each method performs a single responsibility with explicit permission checks before operations. Meaningful parameter names like className classPK and primary enhance understanding. However Liferay-specific framework dependencies may hinder readability for developers unfamiliar with the ecosystem. The absence of inline comments explaining non-obvious framework interactions slightly reduces accessibility despite generally clean implementation","tokens":998,"name":"175.jsnp"}
{"score":"65","reasoning":"The code uses clear constants but has deeply nested method calls and split conditional logic which complicate understanding. Type casting and lack of intermediate variables reduce readability. Initial line seems misplaced causing minor confusion","tokens":2859,"name":"133.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear linear structure and consistent naming conventions Each setter call follows a predictable pattern making it easy to comprehend The compareTo method is straightforward with logical flow although slightly redundant by initializing value before assignment The resetOriginalValues call is framework-specific but well-named Overall the code is well-organized with minimal complexity and no nested logic ensuring ease of understanding for developers familiar with Java conventions","tokens":945,"name":"183.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear method and variable names such as SetServerManagerContextPathCommand and execute. The constructor and execute method are concise showing logical flow. Meaningful parameter names like serverManagerContextPath enhance understanding. The execute method properly captures old value before update indicating thoughtful design. Minimal complexity and adherence to Java conventions make it easy to comprehend. Lacks minor comments explaining purpose of old value storage but overall structure is self-explanatory","tokens":689,"name":"104.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure and meaningful variable names like ruleGroupId and ruleGroup enhancing readability. Consistent indentation and logical flow in parameter handling and attribute setting improve comprehension. However the initial incomplete line WebKeys.MOBILE_DEVICE_RULES_RULE_EDITOR_JSP editorJSP without context slightly disrupts understanding. Framework-specific utilities like BeanParamUtil are well-named but assume domain knowledge. Lack of comments for complex framework interactions slightly reduces accessibility for new developers","tokens":3116,"name":"186.jsnp"}
{"score":"65","reasoning":"The code is procedural and linear which aids basic understanding but suffers from multiple readability issues Magic numbers like 30000 and 90 lack context making timeouts unclear Non-descriptive variables such as selen01 and generated IDs like _125_keywords reduce clarity The empty catch block hides potential errors and the loop structure for element visibility check is not intuitive Missing comments fail to explain the test flow or purpose of repeated loadRequiredJavaScriptModules calls","tokens":1293,"name":"167.jsnp"}
{"score":"85","reasoning":"The code is mostly clear with meaningful names but contains a commented out assignment in the constructor which reduces readability by introducing confusion about its purpose The getIcon method is straightforward and well structured however the unused commented code is a minor distraction that slightly impacts comprehension","tokens":3117,"name":"181.jsnp"}
{"score":"65","reasoning":"Code has inconsistent indentation and uses non-descriptive variable names like lp dm am Raw ArrayList types reduce clarity Comments are sparse especially for the listener logic Parameter grouping is confusing as the same list is extended after group creation Logical flow is hard to follow due to interleaved operations Despite clear method name the overall readability is poor","tokens":3710,"name":"106.jsnp"}
{"score":"68","reasoning":"The code snippet shows Selenium test steps which are generally clear but lacks context. The abrupt start with case labels without the enclosing switch statement makes flow comprehension difficult. The waiting loop uses an empty catch which is poor practice. Variable names are good but the use of labels and continue for control flow is confusing. Overall moderate readability due to incomplete structure and non-idiomatic control flow.","tokens":1539,"name":"107.jsnp"}
{"score":"75","reasoning":"The code snippet includes a well-documented getServiceName method with a minor typo o auth instead of OAuth and an appropriate AutoEscape annotation. However setGadgetKey lacks any documentation in the provided snippet reducing clarity. Method names are clear but missing javadoc for one method impacts overall readability especially in an interface context where documentation is critical for understanding contract expectations resulting in a moderate score","tokens":2620,"name":"168.jsnp"}
{"score":"75","reasoning":"The code uses verbose fully qualified class names like com.sap.engine.services.dc.wsgate.ArchiveFile which significantly reduces readability. Method overloading for setArchiveFiles creates confusion between setting the entire array versus a single element. Standard Java bean structure with getters setters and Javadoc comments provides some clarity but excessive verbosity and potential naming ambiguity lower comprehension ease for new readers","tokens":1787,"name":"188.jsnp"}
{"score":"45","reasoning":"The code snippet exhibits poor readability due to unstructured control flow with labels and continues repetitive selenium commands without abstraction and magic strings Variable names are somewhat descriptive but arbitrary numbers 2 3 lack context The abrupt fragment start and end hinder comprehension Lack of comments and complex regex further reduce clarity However selenium method calls are standard for test automation providing minimal structure Overall the code is difficult to follow and maintain","tokens":2895,"name":"152.jsnp"}
{"score":"92","reasoning":"The code demonstrates strong readability with clear variable names like schemaLoadInfo and descriptive constants. Logical flow is linear and easy to follow with consistent indentation. Conditionals for table view and procedure handling are straightforward. Minor deductions for the redundant else block setting loadProcedures to false explicitly and the abrupt continue statement without loop context which slightly disrupts initial comprehension","tokens":1561,"name":"187.jsnp"}
{"score":"90","reasoning":"The code is well-structured with clear class and method names indicating its purpose as a test suite aggregator. Variable names are descriptive and the logic is straightforward adding two test suites. The class name is lengthy but contextually appropriate for version-specific testing. Minor deduction for lack of comments explaining the specific test inclusions despite conventional naming","tokens":1982,"name":"176.jsnp"}
{"score":"90","reasoning":"The code snippet demonstrates high readability with clear class and method names such as ViewSitePublicPageDropDownTests and suite. Logical structure using TestSuite with descriptive test class additions like AddSitesTest and TearDownSitesTest enhances comprehension. Consistent indentation and standard JUnit patterns aid understanding. Minor deduction for slightly verbose naming and absence of closing braces in the snippet which is expected in partial code but slightly impacts completeness","tokens":859,"name":"199.jsnp"}
{"score":"85","reasoning":"The code demonstrates good structure with clear variable names like beforeRecurrence and duringRecurrence1 making test scenarios understandable The test flow logically checks before during and after recurrence periods However magic numbers 3 and 1 in getRecurrence lack explanatory constants reducing immediate clarity Some context dependencies like dtStart and FRIDAY constants from superclass may require external knowledge but overall organization and method naming support comprehension within a testing framework context","tokens":1289,"name":"159.jsnp"}
{"score":"70","reasoning":"The code has clear class and method names indicating its purpose but suffers from significant readability issues. The empty catch block hides exceptions without logging making debugging difficult. The loop structure using Thread sleep for element visibility is outdated and less readable than modern explicit waits. While the sequential flow is logical the timeout mechanism feels crude and the lack of comments explaining the wait strategy reduces comprehension. These flaws hinder maintainability despite functional clarity","tokens":1794,"name":"209.jsnp"}
{"score":"75","reasoning":"The code demonstrates logical flow and meaningful variable names but suffers from a lengthy parameter list in updateFileEntry which reduces readability despite line breaks Proper indentation helps but ambiguous variable name is instead of inputStream and unexplained null value hinder comprehension The structure is clear yet excessive parameters and minor naming issues lower overall readability","tokens":2628,"name":"135.jsnp"}
{"score":"40","reasoning":"The snippet contains an invalid top-level statement getLeecherCount outside any method body which breaks Java syntax and causes immediate confusion The Javadoc for getBadNATCount is clear with good explanation but the erroneous initial line severely disrupts structure and comprehension making the entire snippet appear broken and unprofessional despite the well-documented method declaration","tokens":1696,"name":"126.jsnp"}
{"score":"60","reasoning":"The code snippet contains extensive but verbose header comments with a critical error referencing Foobar instead of the actual project name causing confusion The presence of incorrect placeholder text significantly hampers comprehension despite clear import statements Standard license templates should be properly customized to maintain professionalism and clarity in academic contexts","tokens":1806,"name":"190.jsnp"}
{"score":"72","reasoning":"The code demonstrates clear test steps with descriptive method names but suffers from non idiomatic manual wait loops causing significant repetition and reduced readability The waiting pattern using infinite loops with Thread sleep is error prone and should leverage Selenium explicit waits instead Lack of helper methods for common operations increases duplication and maintenance burden The abrupt ending limits full assessment but existing structure shows logical flow despite suboptimal implementation choices affecting overall comprehension","tokens":2598,"name":"145.jsnp"}
{"score":"80","reasoning":"The code demonstrates clear intent for Selenium-based UI testing with logical polling loops for element visibility However it suffers from magic numbers lack of comments and empty exception handlers which ignore errors reducing clarity The pattern of retrying with Thread sleep is common in Selenium tests aiding comprehension for experienced developers but inconsistent timeout handling between loops slightly impacts readability","tokens":4613,"name":"146.jsnp"}
{"score":"85","reasoning":"The snippet features four well-structured methods with clear names and standard persistence operations enhancing readability However the initial method block lacks a complete signature starting only with throws clause causing confusion about method identity and parameters The clear loop body partially offsets this issue but the missing context reduces overall comprehension The remaining code demonstrates strong readability with self-explanatory logic","tokens":4609,"name":"153.jsnp"}
{"score":"95","reasoning":"The code snippet features clear class and constant names AdminActivityKeys ADD_KB_ARTICLE ADD_KB_COMMENT which immediately convey purpose. Public static final integers follow standard Java constant conventions. Minimal structure avoids clutter enhancing readability. However the absence of descriptive comments for constants and class reduces context slightly. Numeric values 1 and 5 lack explanation though names partially compensate. Overall highly comprehensible for experienced developers with minor room for documentation improvement","tokens":1576,"name":"189.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with meaningful variable names and standard try-catch-finally blocks enhancing readability The logic for query execution ordering and caching is straightforward However the abrupt snippet start with a closing brace and missing session closure in finally may cause minor confusion Long constant names are conventional but slightly cumbersome The absence of try-with-resources for session management is a modern practice gap but doesn\u0027t severely hinder comprehension","tokens":2254,"name":"202.jsnp"}
{"score":"75","reasoning":"The code has clear class and method names but uses a non-standard infinite loop with timeout check inside and an empty catch block which hides errors and reduces readability and maintainability The loop structure is unconventional and the empty catch is a bad practice making debugging difficult despite the straightforward selenium commands","tokens":1069,"name":"203.jsnp"}
{"score":"60","reasoning":"The code has moderate readability issues due to duplicated timeout loops and empty catch blocks that hide exceptions reducing debuggability Magic strings for element locators and lack of comments hinder clarity Thread sleep polling is outdated but structure is otherwise straightforward Selenium commands are readable but error handling practices lower comprehension score","tokens":1226,"name":"220.jsnp"}
{"score":"50","reasoning":"The code exhibits poor readability due to inconsistent indentation multiple nested blocks and empty catch handlers that obscure error handling logic Non standard leading underscores in method names violate Java conventions increasing cognitive load Lack of comments fails to clarify complex conditional flows and resource management decisions Temporary file handling logic is partially obscured by excessive nesting and abrupt early returns","tokens":1774,"name":"180.jsnp"}
{"score":"50","reasoning":"The code snippet exhibits poor readability due to missing Javadoc method descriptions and parameter explanations relying on inline comments instead of proper documentation. Inconsistent whitespace around parameters and ambiguous method names with suffixes like 2 hinder comprehension. While Javadoc tags exist their lack of descriptive content significantly reduces clarity for understanding API purpose and parameter roles which is critical for maintainability and academic research context","tokens":2612,"name":"201.jsnp"}
{"score":"65","reasoning":"The code has good structure with clear method names and logical separation but suffers from ambiguous regex pattern variable names especially the parameter named match in isValuePresent which is actually a presence check pattern not the replacement pattern Javadoc for setValue is helpful but other methods lack documentation Commented out debug statements add noise","tokens":2525,"name":"177.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method and variable names following Java conventions Consistent indentation and straightforward linear structure enhance comprehension Minimal control flow with a single simple conditional reduces complexity Repetitive setter calls are expected in such contexts and do not hinder understanding Slight deduction for inconsistent line splitting in some method calls which slightly affects visual flow but remains easily parseable","tokens":1668,"name":"148.jsnp"}
{"score":"65","reasoning":"The code exhibits inconsistent formatting with irregular indentation spacing and brace placement Some methods have parameters separated by tabs others by spaces leading to visual clutter Empty method bodies and notSupported calls lack explanatory comments reducing clarity Despite meaningful method names the inconsistent style choices significantly hinder readability and comprehension for maintainers","tokens":889,"name":"138.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method names getQuestionVotes and getQuestionVotesCount that directly convey their purpose Parameters like questionId start end are intuitive and follow common pagination conventions The implementation is straightforward delegation to a well-named service instance _pollsVoteLocalService Minimal logic reduces cognitive load Fully qualified exception names add slight verbosity but remain understandable within Liferay framework context No unnecessary complexity or obscure patterns are present","tokens":971,"name":"214.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method names and logical structure. Standard license header is present but does not obstruct comprehension. Method implementations are concise and focused each performing a single responsibility. The use of descriptive variable names like sharepointRequest and storage enhances understanding. Exception handling is appropriately declared though minimal. Minor deduction for missing constant definition of _METHOD_NAME in snippet but context makes purpose evident. Overall very clean and maintainable code","tokens":1309,"name":"125.jsnp"}
{"score":"90","reasoning":"The code snippet demonstrates clear method naming and structure with appropriate use of Javadoc. However the comment uses inconsistent spacing in class p k instead of classPK which slightly reduces readability. The term expando row may require domain knowledge but overall comprehension remains high due to straightforward method signatures and logical getter setter pattern","tokens":1054,"name":"141.jsnp"}
{"score":"65","reasoning":"The code uses a common Selenium wait pattern but has significant readability issues. Magic numbers 90 and 1000 should be named constants. Empty catch block swallows exceptions making debugging hard. Long XPath strings are repeated and not extracted. Incomplete second loop in snippet reduces clarity. Fail message is too generic. Despite clear loop structure for waiting the lack of best practices lowers comprehension for maintainers","tokens":1327,"name":"113.jsnp"}
{"score":"90","reasoning":"Code exhibits clear structure and meaningful naming conventions enhancing readability Exceptions handled with specific checks though multiple instanceof usage slightly reduces clarity Consistent indentation and logical flow aid comprehension Minor deduction for verbose exception type checks in catch blocks","tokens":2330,"name":"111.jsnp"}
{"score":"85","reasoning":"The code removes double quotes and trailing separators from a path string. Readability is reduced by inconsistent spacing around operators and variables e g String temp  and library_path  temp. The changed flag is set in two non adjacent operations which may confuse readers. Helpful comments exist but one is cut off and informal language stuff up is used. Logic is otherwise clear and straightforward","tokens":2045,"name":"115.jsnp"}
{"score":"90","reasoning":"The code features clear and descriptive method names which enhance understanding. However the non standard line breaks between return types and method names deviate from conventional Java formatting reducing readability slightly. Despite this the structure remains simple and easy to follow for experienced developers","tokens":2084,"name":"158.jsnp"}
{"score":"98","reasoning":"Well-structured Java interface with clear Javadoc comments explaining each method s purpose parameters and exceptions Method names are meaningful and follow conventions Minor typo in doFinal comment statge slightly reduces readability but overall highly comprehensible for its purpose","tokens":1531,"name":"184.jsnp"}
{"score":"55","reasoning":"The code has poor readability due to hard-coded lengthy XPath selectors making element identification unclear without context Duplicated wait loops with empty catch blocks and Thread sleep reduce maintainability and comprehension RuntimeVariables usage lacks explanation and absolute file paths are non-portable Variable names like second are ambiguous and modern explicit waits would improve clarity but are absent The structure is linear but lacks comments and abstraction for repeated patterns","tokens":1479,"name":"173.jsnp"}
{"score":"30","reasoning":"The code snippet contains a syntax error with an extra parenthesis in the first line making it invalid Java This severely hinders comprehension Additionally empty catch blocks swallow exceptions reducing debuggability Long XPath expressions are not abstracted and magic numbers like 90 and 1000 lack context The dangling case 3 label indicates incomplete structure Despite logical Selenium test flow the issues significantly impair readability","tokens":2831,"name":"215.jsnp"}
{"score":"40","reasoning":"Code snippet lacks context making control flow confusing. Use of numeric label 3 with continue and case 3 is unclear without surrounding switch and loop structure. Exception swallowing in try-catch reduces debuggability. Magic numbers 90 and 1000 for timeout should be constants. Hardcoded strings with unicode Â» are not self-explanatory. Selenium wait pattern is standard but overall comprehension requires significant effort due to disjointed state management","tokens":3551,"name":"217.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear variable names and straightforward logic Each block handles one field consistently using simple null checks and assignments The repetition for createDate and modifiedDate is minor and acceptable in this context The empty string check for name is well implemented without unnecessary complexity Overall the structure is linear and easy to follow making comprehension effortless","tokens":1176,"name":"142.jsnp"}
{"score":"100","reasoning":"The code is a straightforward Java setter method with clear naming conventions and proper Javadoc documentation It follows standard Java practices with no complex logic or ambiguous elements The parameter and field names are descriptive and consistent making it immediately understandable for developers familiar with Java The minimal structure and absence of unnecessary complexity ensure maximum readability and ease of comprehension","tokens":636,"name":"161.jsnp"}
{"score":"60","reasoning":"The code exhibits moderate readability with clear sequential flow typical of Selenium tests However it suffers from hard-coded XPath selectors which are lengthy and obscure magic strings for UI elements like socialofficefriendfn reduce clarity Empty catch blocks hide potential errors and RuntimeVariables usage lacks context making maintenance difficult Consistent indentation helps but absence of comments or meaningful variable names hampers comprehension for unfamiliar readers","tokens":1468,"name":"194.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with well-defined methods and consistent naming conventions. Comments effectively explain empty methods and interface implementations. However readability is slightly hindered by non-standard variable prefixes like _myscrolledPanel using hungarian notation and leading underscores which deviate from typical Java camelCase standards. Abbreviated names such as _prefs reduce immediate clarity despite overall logical flow and proper encapsulation","tokens":1167,"name":"147.jsnp"}
{"score":"25","reasoning":"The code snippet starts mid-logic with orphaned closing braces and a disconnected statement causing immediate confusion Lacks context for _instance and _connecting variables making their scope unclear Inconsistent indentation and unused parameters in update method reduce clarity Static send method using instance variable hints at singleton pattern but poor structure obscures intent Critical class definition and initialization logic are missing severely hindering comprehension","tokens":1812,"name":"132.jsnp"}
{"score":"65","reasoning":"The code has moderate readability but suffers from duplicated timeout loops and empty exception handling which obscure intent Magic numbers like 90 and 1000 lack context reducing clarity Inconsistent use of Thread sleep versus waitForPageToLoad creates confusion Variable names are acceptable but the absence of helper methods for repeated logic increases cognitive load The structure is linear but poor error handling and lack of comments hinder comprehension for maintenance","tokens":1182,"name":"210.jsnp"}
{"score":"70","reasoning":"The code snippet is mostly readable with good structure and conventional naming for test suites However it is syntactically incomplete missing closing braces for method and class which requires the reader to mentally complete it Lack of descriptive comments reduces clarity but experienced developers can easily comprehend the intent","tokens":4058,"name":"207.jsnp"}
{"score":"65","reasoning":"The code exhibits moderate readability with consistent formatting but suffers from repeated timeout loops and hardcoded values 90 and 1000 reducing clarity Magic numbers lack explanatory constants Empty exception handlers obscure error handling logic and duplicate wait patterns could be refactored into reusable methods Selenium commands are clear but overall structure feels unoptimized for maintainability and comprehension","tokens":1680,"name":"110.jsnp"}
{"score":"95","reasoning":"The code is highly readable with clear method names and straightforward logic The constructor is a standard copy implementation and getICMPHeaderByteLength correctly returns the fixed ICMP header size of 8 bytes which is a wellknown standard value in networking contexts Although the magic number 8 could be defined as a named constant for enhanced clarity its domain specificity makes it reasonably understandable without additional comments","tokens":1298,"name":"213.jsnp"}
{"score":"35","reasoning":"The code snippet has poor readability due to hard-coded XPath expressions magic numbers and an empty catch block which obscures error handling The use of a labeled continue statement is an anti-pattern in Java making control flow difficult to follow Lack of comments and context such as the surrounding switch case structure further reduces comprehension Although Selenium commands are sequentially clear the overall structure is convoluted and not self-documenting leading to significant challenges in understanding the test logic without additional context","tokens":1443,"name":"121.jsnp"}
{"score":"95","reasoning":"The code snippet demonstrates strong readability with clear variable names like objectNameCacheKey and consistent indentation The synchronized block structure is logical and the if-else flow is straightforward to follow Minor deductions for the abrupt ending without closing braces and the unexplained origin of defaultObjectName which slightly impacts immediate comprehension but remains highly understandable within context","tokens":3400,"name":"156.jsnp"}
{"score":"65","reasoning":"The code uses a timeout loop common in Selenium tests but has poor readability due to an empty for loop condition and silent exception swallowing which hides errors. Lack of comments explaining the 90-second timeout logic and cryptic XPath reduce comprehension. While structure is functional the empty catch block and unconventional loop style negatively impact maintainability and debugging clarity","tokens":1049,"name":"219.jsnp"}
{"score":"30","reasoning":"The snippet starts with an unmatched closing brace creating immediate confusion. The toString method references undefined variable string causing ambiguity. Although the encode method signature is clear the fragment lacks class context making it incomplete. The Hex.encode usage assumes external knowledge and the stray brace severely impacts readability. Code would not compile as presented due to syntax errors and missing declarations","tokens":1303,"name":"169.jsnp"}
{"score":"90","reasoning":"The code demonstrates clear structure with meaningful variable names like models and soapModels facilitating understanding The for-each loop is concise and standard Java practice The toSoapModel method name effectively conveys its purpose The toArray conversion follows common Java idioms though slightly verbose for beginners The empty constructor adds minimal complexity Overall the snippet is well-organized and self-explanatory without unnecessary complexity","tokens":1114,"name":"171.jsnp"}
{"score":"55","reasoning":"The code shows repetitive Liferay-specific patterns with duplicated exception handling logic. Magic numbers in method keys like _addBar_RollbackMethodKey17 lack explanation. Absence of comments makes purpose unclear without framework knowledge. Abrupt ending reduces completeness. Consistent structure partially offsets poor readability for unfamiliar readers","tokens":1568,"name":"165.jsnp"}
{"score":"90","reasoning":"The code exhibits high readability due to consistent repetitive structure and clear method naming Each line follows an identical pattern making it easy to understand the purpose of adding test suites The minor deduction stems from inconsistent test class naming conventions using both numbers and letters which could slightly hinder immediate comprehension without additional context","tokens":1033,"name":"155.jsnp"}
{"score":"40","reasoning":"The code snippet is incomplete and lacks the critical condition inside the loop that would break on success. Only the timeout check is visible making the loop non functional and confusing. The empty loop condition without a visible exit strategy beyond timeout significantly reduces readability and comprehension of the intended test flow","tokens":2111,"name":"114.jsnp"}
{"score":"100","reasoning":"The code snippet is a well-structured Java interface with a standard license header and clear Javadoc comment The interface name DownloadTypeIncomplete is descriptive and the purpose is evident from the documentation The long header is standard practice in open source projects and does not hinder comprehension thus the code is highly readable","tokens":3596,"name":"160.jsnp"}
{"score":"95","reasoning":"The code is a well-structured Java interface with clear method names following standard conventions. Public getters and setters are self-explanatory and logically grouped. Minor deduction for a redundant Javadoc comment that merely repeats the method name without adding value. The license header and brief interface comment provide context without cluttering readability. Overall highly comprehensible due to concise design and meaningful naming","tokens":1539,"name":"200.jsnp"}
{"score":"75","reasoning":"The initial fragment lacks context and has inconsistent indentation making it hard to understand However the test methods are well structured with clear names proper exception handling and appropriate assertions The fragment significantly reduces overall readability despite the tests being comprehensible","tokens":4280,"name":"178.jsnp"}
{"score":"95","reasoning":"Code demonstrates excellent readability with clear descriptive variable names and straightforward validation logic Each method follows a consistent pattern checking subject prefix then body for null using simple if else if structure Duplication between methods is minimal and acceptable for distinct validation contexts making overall comprehension effortless","tokens":1398,"name":"206.jsnp"}
{"score":"80","reasoning":"The code snippet has clear structure with logical grouping and meaningful method names enhancing readability However the Unicode escape u00bb for double angle quote reduces immediate comprehension and the magic number 30000 for timeout lacks context Slight deductions for these style issues but overall remains understandable within Selenium test framework context","tokens":4298,"name":"149.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear JavaBean conventions and consistent Javadoc comments detailing each method\u0027s purpose parameters and exceptions Proper naming conventions and structured documentation enhance comprehension Minor deduction for slightly repetitive comment phrasing and ambiguous meetups registration terminology which could be more precisely worded","tokens":1517,"name":"130.jsnp"}
{"score":"60","reasoning":"The code uses a complex control flow with label manipulation and switch fall-through which hinders readability Significantly The while-switch structure resembles outdated goto patterns making execution path difficult to follow Repetitive selenium calls and empty exception handling add verbosity without clarity Although indentation and variable names are adequate the overall logic flow is convoluted and hard to comprehend at a glance","tokens":1848,"name":"205.jsnp"}
{"score":"92","reasoning":"Code uses clear variable names and standard Swing layout practices. The i18n comment explains localization purpose though its bracket notation may confuse some readers. Logical structure with BorderLayout for label and text field placement enhances readability. Minimal complexity and proper component organization contribute to high comprehension but slightly unconventional comment format prevents a perfect score","tokens":1645,"name":"196.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear method names and straightforward delegation logic Consistent underscored field naming though non standard in Java is uniform and does not hinder comprehension Minimal complexity in methods like setAuthToken enhances understanding Lack of comments is offset by self explanatory code structure and single responsibility design The minor deduction accounts for unconventional variable prefixes which may slightly affect initial readability for developers accustomed to standard Java conventions","tokens":1427,"name":"139.jsnp"}
{"score":"95","reasoning":"The code demonstrates excellent readability with clear method names and straightforward logic. The class purpose is immediately evident as a response container for results or exceptions. Consistent underscore-prefixed field naming aligns with project conventions. The only minor flaw is the verbose hasError implementation using redundant if-else instead of direct boolean return. Overall structure is simple and highly comprehensible for its intended purpose","tokens":1635,"name":"163.jsnp"}
{"score":"55","reasoning":"The code snippet shows a polling loop for an iframe visibility check using Selenium The empty catch block for Exception swallows all errors without logging making debugging difficult and reducing readability The XPath string is long and unexplained but common in Selenium tests The Thread.sleep uses a magic number though 1000ms is standard The indentation is inconsistent Overall the pattern is recognizable but poor error handling lowers the score","tokens":2287,"name":"124.jsnp"}
{"score":"70","reasoning":"The empty catch block ignores all exceptions without logging or comments making error handling opaque and reducing debuggability However the polling loop structure is common in Selenium tests and the intent to wait for element visibility before breaking is reasonably clear despite the anti pattern","tokens":4452,"name":"105.jsnp"}
{"score":"55","reasoning":"The code contains an empty catch block which swallows exceptions without logging or handling making debugging difficult and violating best practices. Although the element check and sleep are clear the lack of error context reduces readability significantly. The break statement implies loop context not shown causing minor confusion. Overall poor maintainability despite simple structure","tokens":2231,"name":"218.jsnp"}
{"score":"65","reasoning":"The code snippet shows clear method names and consistent transactional annotations which aid understanding However excessive use of fully qualified class names like com liferay portlet bookmarks model BookmarksEntry creates significant visual clutter and line length issues reducing readability substantially The lack of import statements forces repetitive verbose declarations making it harder to focus on core logic structure despite logical method organization","tokens":1192,"name":"144.jsnp"}
{"score":"45","reasoning":"The code exhibits poor readability due to excessive verbosity with fully qualified class names and complex nested exception handling. Meaningful variable names are overshadowed by framework-specific patterns requiring Liferay knowledge. Lack of comments and the incomplete second method further hinder comprehension. The anti-pattern of catching generic exceptions to rethrow specific ones adds unnecessary complexity making it difficult to follow without domain expertise","tokens":1811,"name":"162.jsnp"}
{"score":"75","reasoning":"The code has logical structure and clear variable names but suffers from a critical typo in _proccessAttributes method name and non standard underscore prefix for private methods which reduces readability for Java developers. Lack of comments for complex logic and partial code snippet also contribute to moderate readability","tokens":1618,"name":"211.jsnp"}
{"score":"75","reasoning":"The code shows repetitive updatePortletPermissions calls with clear portlet names and permission actions. However magic string IDs like 8 and 20 lack context reducing readability. The abrupt end in getLayout method adds confusion. Overall pattern is easy to grasp but magic values and incomplete code lower the score","tokens":1310,"name":"127.jsnp"}
{"score":"90","reasoning":"The code snippet is well-structured with clear field names points and pointsAreLeftOfWindow which are self-explanatory However the abrupt ending without a closing brace slightly reduces readability as it leaves the class incomplete but the provided part is very easy to understand","tokens":1776,"name":"128.jsnp"}
{"score":"95","reasoning":"The code is a simple exception class with clear naming and standard structure However the class comment lacks a description of the exception\u0027s purpose only providing author information This minor documentation gap prevents a perfect score but overall the code is very easy to understand","tokens":3060,"name":"182.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear method names and relevant Javadoc for key methods explaining parameters and return values. However it uses raw Map type without generics reducing type clarity and lacks documentation for getName method. The I-prefixed interface name deviates slightly from standard Java conventions but remains understandable within its project context. Overall clean organization balances minor documentation gaps","tokens":940,"name":"216.jsnp"}
{"score":"90","reasoning":"The code snippet is concise and logically structured with clear variable names RUBY and value. The use of equals for comparison and descriptive exception message enhances understanding. The leading underscore in _value is a minor style deviation but does not significantly hinder readability. The absence of surrounding context is typical for snippets and does not obscure the straightforward conditional logic and error handling presented","tokens":1023,"name":"109.jsnp"}
{"score":"45","reasoning":"The snippet starts with confusing multiple closing braces without context. Method isBuddy returns int but name suggests boolean expectation causing semantic confusion. Inconsistent indentation and spacing around parameters and assignments. Variable peer_ip uses non-standard underscore in Java convention. Abrupt ending mid-method reduces comprehension. Structural issues and naming choices significantly hinder readability despite simple logic","tokens":1804,"name":"117.jsnp"}
{"score":"75","reasoning":"The code is well structured with clear method names and error handling but has inconsistent class references in static initializers using DeleteAliasAction in AliasAction class causing confusion The redundant i18n comment adds minor clutter","tokens":3244,"name":"137.jsnp"}
{"score":"70","reasoning":"The code snippet is concise with clear interface naming and relevant annotations indicating framework-specific behavior However the absence of method definitions within the interface reduces immediate comprehension for those unfamiliar with Eclipse Sapphire framework The annotations are descriptive but require domain knowledge to fully grasp their implications The author comment adds minimal value to understanding the code structure","tokens":1444,"name":"179.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear structure and comprehensive Javadoc explaining purpose parameters and behavior. Method names like getParameterSpec and getNames are self-explanatory. Logic is straightforward with minimal nesting and direct delegation to helper classes. Variable ecP is contextually understandable though slightly abbreviated. Minor deduction for raw Enumeration usage without generics which is outdated but doesn\u0027t significantly impact comprehension. Excellent documentation makes the code easy to follow for its intended cryptographic purpose","tokens":1495,"name":"122.jsnp"}
{"score":"95","reasoning":"Code is well-structured with clear variable names and logical flow. Proper null checks and fallbacks enhance robustness. Minor deductions for unconventional logger naming (_log) and split debug statement formatting. Unsupported methods are appropriately handled but lack explanatory comments. Overall highly readable and maintainable","tokens":1473,"name":"154.jsnp"}
{"score":"70","reasoning":"The code snippet shows inconsistent naming conventions with getURLExport using uppercase URL and getUrlTitle in lowercase affecting readability Minor redundancy in parameter names like liferayPortletRequest repeating framework name Lack of comments or Javadoc reduces clarity for unfamiliar developers though structure is simple and follows Java interface patterns","tokens":1353,"name":"195.jsnp"}
{"score":"88","reasoning":"The code exhibits strong readability with clear variable names and logical structure. Repetitive append patterns in StringBundler are straightforward but slightly verbose. Explicit null checks enhance comprehension though ternary operators could improve conciseness. Magic number 17 in StringBundler instantiation slightly reduces clarity. Framework-specific elements like StringPool.BLANK assume domain knowledge but don\u0027t severely hinder understanding. Consistent indentation and linear flow contribute to overall ease of comprehension despite minor verbosity in string construction","tokens":1637,"name":"197.jsnp"}
{"score":"40","reasoning":"The snippet starts with an incomplete parameter declaration fragment Category category which is invalid and confusing without context. Although the categoryRemoved method has excellent Javadoc documentation the initial error severely impairs comprehension. Unconventional method signature formatting splitting return type and name across lines adds unnecessary complexity. The presence of broken syntax at the beginning dominates the readability assessment","tokens":4303,"name":"118.jsnp"}
{"score":"90","reasoning":"The code is concise with clear variable names and logical flow. The null check and method call are straightforward. Minor deductions for the magic string \u0027Tunnel\u0027 and two null parameters which could benefit from named constants or comments for better context understanding despite domain knowledge","tokens":1470,"name":"185.jsnp"}
{"score":"95","reasoning":"The code is well-structured with clear variable names and logical flow. It demonstrates a straightforward test setup for a UI component. The only minor issue is the potential unfamiliarity with SQLAliasConnectionProperties class but its name is descriptive. The snippet ends abruptly but as a fragment it remains highly comprehensible.","tokens":3150,"name":"123.jsnp"}
{"score":"100","reasoning":"The snippet features a standard well-formatted copyright header which is clear and industry common The package declaration is precise and follows Java conventions Imports are specific not wildcard-based and logically grouped enhancing clarity Although the header is lengthy it is typical for open source projects and does not impede understanding The structure is professional and immediately comprehensible to developers","tokens":4232,"name":"134.jsnp"}
{"score":"70","reasoning":"The code has clear getter methods but suffers from a typo in toString PlaformMessage reducing readability Magic number 32767 lacks explanation and unclear abbreviations like cn hinder comprehension Variable naming inconsistency such as lSequenceNo with type prefix deviates from Java conventions toString structure is hard to follow due to minimal spacing and lack of field labels in string concatenation","tokens":2351,"name":"108.jsnp"}
{"score":"85","reasoning":"The code snippet demonstrates a retry loop waiting for a Selenium element visibility check The condition and break statement are clear indicating loop exit on success However the empty catch block swallows exceptions without logging which is poor practice for maintainability and debugging though it does not severely hinder initial comprehension The structure is consistent with standard retry patterns and the locator string is descriptive Minor readability deduction for the silent exception handling","tokens":3452,"name":"143.jsnp"}
{"score":"95","reasoning":"The first method demonstrates excellent readability with clear variable names visiblePlugins plugin and pluginSetting alongside straightforward filtering logic The incomplete second method signature is understandable but the abrupt termination after the opening brace is slightly disruptive though acceptable in a snippet context for academic research","tokens":6884,"name":"119.jsnp"}
{"score":"30","reasoning":"The code snippet starts with a broken string literal causing syntax confusion Undefined variable testEmailChecked and unexplained magic number 6 reduce clarity The continue statement lacks loop context Despite simple intent the presentation is poor","tokens":2998,"name":"129.jsnp"}
{"score":"75","reasoning":"The first two tests are clear and well-structured with proper assertions However testUpdateNew lacks assertions and has a misleading name while testUpdateExisting is incomplete in the snippet The code uses good naming and style but these flaws reduce overall comprehension","tokens":3851,"name":"120.jsnp"}
{"score":"58","reasoning":"The code snippet exhibits poor readability due to inconsistent indentation and excessive blank lines which disrupt visual flow. Variable names like bit and single-letter identifiers reduce clarity without contextual comments. The complex conditional expression lacks parentheses for explicit operator precedence making logic harder to parse. While the overall structure suggests string parsing logic the absence of meaningful comments and ambiguous terms like bit_contains_quotes hinder comprehension despite recognizable patterns for quote handling and escape sequences","tokens":1153,"name":"164.jsnp"}
