{"score":"82","reasoning":"The code demonstrates clear structure with descriptive class and method names aligning with test case purpose. Proper indentation and logical flow for Selenium test execution are present. However readability is slightly reduced by manual timeout handling with empty catch block which obscures error handling logic. The polling mechanism using Thread sleep instead of explicit waits adds unnecessary complexity. Variable names are meaningful but lack comments explaining timeout rationale. Overall comprehension remains good for experienced Java testers despite minor maintainability concerns","tokens":919,"name":"212.jsnp"}
{"score":"82","reasoning":"The code has clear structure and meaningful names like getColor and colorMap enhancing readability However commented out code and raw Map usage reduce clarity Exception handling swallows errors without logging which impacts maintainability Static colorMap usage is logical but lacks generics The class organization is straightforward with concise methods yet minor issues prevent a higher score","tokens":1101,"name":"166.jsnp"}
{"score":"20","reasoning":"The code snippet is incomplete starting with closing braces and a catch block without context. Empty catch for generic Exception is a severe anti-pattern hiding errors. Thread.sleep uses unexplained magic number 1000. Selenium XPath string is long but acceptable however the overall structure is broken with no comments or context making comprehension extremely difficult for maintainers","tokens":878,"name":"174.jsnp"}
{"score":"65","reasoning":"The code has logical structure but suffers from unclear macros like BETTER_THAN which obscure condition logic Magic numbers 0.2f and 0.4f lack explanation reducing understandability Variable names like dif are ambiguous without context Indentation is consistent but absence of comments explaining bias adjustment and fitness comparison hinders comprehension for unfamiliar readers","tokens":1218,"name":"112.jsnp"}
{"score":"92","reasoning":"Code demonstrates high readability with clear structure and meaningful identifiers. Consistent error checking at method starts enhances comprehension. Underscore-prefixed instance variables follow framework conventions without hindering understanding. Logical flow is evident despite incomplete try block in snippet. Variable names like portletModeException and getDefaultNamespace convey intent effectively. Minimal cognitive load required for Java developers familiar with portlet concepts","tokens":1478,"name":"131.jsnp"}
{"score":"92","reasoning":"The code is concise with clear method names and structure. The constructor has a commented assignment which slightly reduces readability by introducing potential confusion about intended functionality. The getIcon method is straightforward using descriptive paths and static references. Minor deduction for the dead code comment but overall well-organized and easy to follow due to meaningful naming and simplicity","tokens":1351,"name":"181.jsnp"}
{"score":"60","reasoning":"The code snippet exhibits moderate readability issues due to inconsistent indentation and an incomplete structure starting mid-method with a dangling comma. Variable names are descriptive but domain-specific abbreviations like MDR may confuse unfamiliar readers. The abrupt termination mid-logic and lack of contextual comments hinder comprehension. Framework-specific patterns are evident but require prior knowledge of portlet development. Formatting inconsistencies and partial code presentation significantly impact ease of understanding despite logical service utilizations","tokens":1707,"name":"186.jsnp"}
{"score":"65","reasoning":"The code snippet shows Selenium test automation with clear method names but lacks context for control flow such as the loop for the continue statement and the switch case structure The use of magic strings for element locators and timeouts reduces readability The regex in the assertion is complex and hard to read without comments Overall it is moderately readable for domain experts but challenging for general comprehension due to missing context and obscure identifiers","tokens":1171,"name":"193.jsnp"}
{"score":"35","reasoning":"The code snippet shows a retry mechanism for element visibility but the empty catch block swallows exceptions without logging causing significant debugging challenges and reducing readability The break statement implies a loop context which is absent in the snippet making comprehension difficult without surrounding code The fail timeout call is placed confusingly without clear context","tokens":1622,"name":"192.jsnp"}
{"score":"75","reasoning":"The code exhibits high repetition across methods with identical try-catch structures reducing readability. While consistent error handling makes patterns predictable the duplicated logic increases cognitive load. The _log.error(e e) usage may confuse readers due to redundant exception passing. Lack of abstraction for common error handling lowers maintainability and comprehension efficiency despite straightforward individual method logic","tokens":1219,"name":"140.jsnp"}
{"score":"97","reasoning":"The code exhibits high readability with clear getter methods and standard hashCode equals implementations following Java conventions Prime numbers and boolean handling in hashCode are conventional Javadoc comments provide context Consistent naming and structure enhance comprehension Minor deduction for equals method solely comparing getSimpleName which may confuse but code remains logically structured and easy to follow","tokens":1897,"name":"150.jsnp"}
{"score":"88","reasoning":"The code demonstrates clear structure with meaningful variable names and logical flow Control structures like try-catch and if-else are appropriately used for error handling and conditional logic Early returns simplify some paths but could slightly hinder readability for complex scenarios Consistent naming conventions and minimal nesting enhance comprehension Minor deductions for potential null handling ambiguity and lack of comments in critical sections","tokens":1935,"name":"101.jsnp"}
{"score":"92","reasoning":"Code is well formatted with meaningful names and logical flow. The static method shows clear intent until the snippet ends. The comment about constants is urgent but relevant. Incomplete snippet slightly hinders full comprehension but the present code is very readable.","tokens":2077,"name":"151.jsnp"}
{"score":"95","reasoning":"The code snippet demonstrates high readability with clear method names and concise Javadoc comments explaining functionality. Proper use of annotations like @AutoEscape adds context without clutter. Minor deduction for inconsistent capitalization in OAuth documentation comment which slightly reduces professionalism but does not impede understanding. Structure follows standard Java interface conventions making it immediately comprehensible to experienced developers","tokens":753,"name":"168.jsnp"}
{"score":"95","reasoning":"The code snippet consists of well-organized imports grouped logically by package hierarchy Liferay-specific utilities followed by standard Java libraries Explicit imports enhance clarity and maintainability without unnecessary wildcard usage Indentation and structure adhere to common Java conventions facilitating quick comprehension for developers familiar with the ecosystem","tokens":2000,"name":"208.jsnp"}
{"score":"75","reasoning":"The code exhibits clear method names and straightforward logic but suffers from significant repetition of null checks and logging across multiple methods violating DRY principle This redundancy increases cognitive load and maintenance difficulty despite otherwise simple structure and consistent error handling practices The lack of helper method extraction for repeated validation logic detracts from overall readability and comprehension efficiency","tokens":1503,"name":"116.jsnp"}
{"score":"80","reasoning":"The code uses common Selenium test patterns with clear intent: waiting for elements before interaction. Empty catch blocks are typical for test waits but poor practice as they hide errors. The first break lacks visible loop context causing minor confusion. The timed wait loop for Sign In is well-structured with explicit timeout. Overall flow is logical but readability suffers slightly from missing loop context and silent exception handling which could mislead beginners despite being conventional in test automation","tokens":2203,"name":"146.jsnp"}
{"score":"85","reasoning":"The code exhibits logical structure with clear method names and helpful comments Short variable names like lp am dm are used locally but context makes them understandable Anonymous inner class for listener is well contained String keys for parameters are typical in config code but require domain knowledge Minor readability issues prevent a higher score","tokens":2537,"name":"106.jsnp"}
{"score":"95","reasoning":"Clear class and method naming immediately conveys purpose selenium command specifies target URL explicitly logical test flow for front page validation minor deduction for absence of inline comments but overall highly comprehensible structure typical for test automation scenarios with straightforward action sequence","tokens":2220,"name":"191.jsnp"}
{"score":"75","reasoning":"The code is linear and uses RuntimeVariables for clarity but has repetitive waitForPageToLoad and loadRequiredJavaScriptModules calls that clutter the flow. The low-level wait loop with Thread.sleep instead of explicit waits reduces readability. Long file path string lacks line breaks making it hard to parse. Lack of comments or helper methods for repeated patterns increases cognitive load despite straightforward Selenium commands.","tokens":1536,"name":"198.jsnp"}
{"score":"70","reasoning":"The code has descriptive method names and clear test structure but starts with an orphaned assertEquals line causing confusion. Heavy use of framework-specific APIs DynamicQueryFactoryUtil etc requires domain knowledge. Helper methods like nextLong are non-standard. Overall readable for framework experts but challenging for general audience due to framework dependencies and the initial incomplete statement","tokens":1352,"name":"204.jsnp"}
{"score":"90","reasoning":"Clear variable and method names enhance readability Logical flow with proper indentation Slightly hindered by long parameter list in updateFileEntry but variables are descriptive Null parameter lacks context but overall code is well-structured and easy to follow for someone familiar with the framework","tokens":1147,"name":"135.jsnp"}
{"score":"60","reasoning":"The code has clear method names like selenium.clickAt but suffers from repetitive waitForPageToLoad and loadRequiredJavaScriptModules calls. Magic strings and complex XPaths like //input[@id\u003d\u0027_134_name\u0027] reduce readability. The label\u003d2 with continue and nested loops using timeout checks add confusion. Lack of abstraction for repeated actions and fragile selectors hinder comprehension despite logical flow","tokens":1298,"name":"157.jsnp"}
{"score":"35","reasoning":"The code uses a confusing while-switch structure with a static label variable creating an unclear control flow The infinite loop pattern with no label modification outside timeouts reduces readability Selenium timeout logic is standard but buried in non-idiomatic Java patterns making maintenance difficult for developers expecting conventional loop constructs Lack of comments explaining the unusual structure further hinders comprehension","tokens":1726,"name":"102.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear and consistent naming conventions. Each setter call is straightforward and self-explanatory making the initialization block easy to follow. The compareTo method logic is simple though slightly verbose with an unnecessary variable and conditional check which could be streamlined. Overall structure is linear and free of complex constructs enhancing comprehension for Java developers familiar with standard getter setter patterns","tokens":1232,"name":"183.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear method and variable names that convey intent effectively. The structure follows standard Java conventions using a constructor for initialization and an execute method for action. Logical flow is straightforward with minimal complexity. Slight deduction for verbose variable names like serverManagerContextPath which could be shortened without losing clarity but overall excellent comprehension","tokens":818,"name":"104.jsnp"}
{"score":"92","reasoning":"The code demonstrates strong readability with clear naming conventions and logical structure The nested i18n interface effectively organizes internationalized strings enhancing maintainability Static string manager setup follows consistent patterns common in Java applications However the nested interface approach for constants while clean might slightly confuse developers unfamiliar with this specific pattern but overall comprehension remains high due to descriptive identifiers and straightforward initialization","tokens":2699,"name":"172.jsnp"}
{"score":"75","reasoning":"The code has repetitive waiting loops which reduce readability. Magic numbers for timeout and sleep lack explanatory constants. However the test method name is descriptive and the overall structure is clear. The abrupt end of the snippet doesn\u0027t reflect on the code quality but the provided part shows room for improvement in refactoring and constants usage","tokens":1492,"name":"145.jsnp"}
{"score":"95","reasoning":"The code is well-structured with clear Java bean patterns and consistent naming. Fields and methods follow standard conventions making comprehension straightforward. Javadoc exists for primary getters setters though minimal. Minor readability deductions for missing Javadoc on index-based array methods and potential confusion from overloaded setArchiveFiles methods one for full array one for elements. Overall highly readable due to simplicity and logical organization","tokens":1607,"name":"188.jsnp"}
{"score":"40","reasoning":"The snippet starts with an incomplete syntactically invalid fragment causing immediate confusion. The subsequent conditional block is logically clear but the broken initial line severely impairs overall comprehension. Constants usage is good yet nested method calls with casting add unnecessary complexity reducing readability.","tokens":3272,"name":"133.jsnp"}
{"score":"92","reasoning":"The code is highly readable due to comprehensive Javadoc and clear naming The parameterized constructor has detailed comments explaining each parameter However the 7 parameters in the constructor and the no-arg constructor using nulls slightly reduce readability Overall very well structured and easy to comprehend","tokens":3578,"name":"221.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear variable and method names such as db updateIndexes and upgradeProcessClassNames Logical flow is evident through sequential resource loading and conditional checks The multi-line string concatenation for logging is slightly cumbersome but remains understandable Minor deduction for this formatting choice while overall structure remains straightforward and well-organized","tokens":3712,"name":"103.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear class and method naming following standard JUnit conventions. The structure is straightforward showing a test suite aggregation pattern. Descriptive test group names LoginTests and TagsTestPlan enhance comprehension. Minor deduction for version number 528 in class name lacking context and absence of comments explaining test selection rationale despite being self-explanatory to experienced developers. Proper indentation and minimal complexity contribute to ease of understanding","tokens":2037,"name":"176.jsnp"}
{"score":"70","reasoning":"The code demonstrates a logical sequence of Selenium test steps with clear action descriptions however repetitive waitForPageToLoad and loadRequiredJavaScriptModules calls increase verbosity. Cryptic XPath selectors like _125_keywords reduce clarity while the empty catch block in the timeout loop hides potential errors. Despite these issues the linear flow remains understandable for those familiar with Selenium patterns","tokens":2184,"name":"167.jsnp"}
{"score":"40","reasoning":"The Javadoc is clear and descriptive explaining the method purpose and edge case. However the first line getLeecherCount is an invalid standalone method call outside any method body causing major confusion. Method names are descriptive but the structural error mixing invocation with declaration severely hinders comprehension as it breaks Java syntax expectations making the snippet appear erroneous and hard to interpret correctly","tokens":1463,"name":"126.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with clear method names and concise logic Each method handles a single responsibility with straightforward permission checks and service calls Consistent indentation and standard Java patterns enhance comprehension Lack of method level documentation and class description slightly reduces accessibility for unfamiliar developers but overall structure remains highly understandable for experienced engineers","tokens":2421,"name":"175.jsnp"}
{"score":"90","reasoning":"The code is well-structured with clear class and method names following JUnit conventions. Test suite initialization is straightforward with logical test class ordering setup to teardown. Variable names are descriptive and indentation is consistent. Minor deduction for lack of comments explaining test sequence rationale and incomplete closing brace in snippet which slightly impacts completeness","tokens":694,"name":"199.jsnp"}
{"score":"55","reasoning":"The code is a Selenium test with clear step-by-step actions but suffers from poor readability due to magic numbers 30000 and 90 empty exception handling in wait loop and confusing control flow with label assignment and continue statement Hardcoded XPath strings reduce clarity Lack of comments and context from incomplete snippet further hinder understanding Typical test code issues but the label pattern is particularly problematic","tokens":2457,"name":"107.jsnp"}
{"score":"65","reasoning":"The code has moderate readability issues due to unclear control flow with unexplained label\u003d3 and continue statement without visible loop context. Missing switch/loop structure makes case 3 confusing. Magic numbers 90 and 1000 reduce clarity. Unicode escape is acceptable but inconsistent indentation and empty exception handling hinder comprehension. Selenium patterns are recognizable but anti-patterns like Thread.sleep loop affect maintainability","tokens":1119,"name":"217.jsnp"}
{"score":"70","reasoning":"The code exhibits moderate readability with consistent indentation and Javadoc usage However critical issues reduce comprehension Inconsistent parameter naming like min_value versus camelCase defaultValue violates Java conventions Some Javadoc lacks method descriptions entirely eg first method only lists parameters without explaining purpose The presence of unexplained 2 suffixes in method names adds confusion while sparse comments for parameters like labels hinder understanding Despite clear structure and partial parameter explanations these flaws significantly impact ease of comprehension","tokens":1611,"name":"201.jsnp"}
{"score":"50","reasoning":"The code snippet exhibits poor readability due to unexplained control flow with magic numbers label\u003d3 and label\u003d9 without context. Hard-coded long XPath expressions are difficult to parse and maintain. Repetitive selenium commands lack abstraction into helper methods increasing cognitive load. Variable names like suborganization2Present are insufficiently descriptive. The abrupt structure mixing continue statements with case labels creates confusion about program flow without surrounding loop or switch context","tokens":3069,"name":"152.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear method names like getQuestion and getQuestionsCount that immediately convey purpose Consistent use of meaningful variable names such as groupId and pollsQuestionPersistence enhances understanding Straightforward logic without nested complexities or obscure patterns aids comprehension Minor deduction for lack of comments though the simplicity reduces their necessity and potential truncation of first method name in snippet","tokens":4442,"name":"153.jsnp"}
{"score":"85","reasoning":"The code shows a standard Selenium test pattern with clear method naming and logical structure. The timeout loop for element visibility is common in UI testing. However the empty catch block for generic exception reduces clarity by obscuring potential errors without explanation. Despite this the flow remains understandable for experienced testers familiar with Selenium patterns","tokens":2210,"name":"209.jsnp"}
{"score":"60","reasoning":"The code has moderate readability issues. It uses magic numbers 90 and 1000 without explanation and repeats complex XPath selectors multiple times increasing error risk. The empty catch block swallows exceptions reducing debuggability. Thread sleep in loop is inefficient compared to explicit waits. Case 3 at end appears disconnected suggesting incomplete context. Lack of comments and meaningful variable names for selectors hinders comprehension despite logical selenium test flow","tokens":1088,"name":"215.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with proper try catch finally blocks and meaningful variable names enhancing readability However the boolean false parameter in QueryUtil list lacks clarity without context and Collections sort without explicit comparator may confuse Additionally the snippet starts abruptly but as a partial code segment it remains generally comprehensible for experienced Java developers","tokens":1802,"name":"202.jsnp"}
{"score":"78","reasoning":"The code snippet shows basic Selenium operations with clear method names but suffers from inconsistent indentation and incomplete structure. The Unicode escape for double angle quote is acceptable but the undeclared label variable and abrupt if block termination reduce readability. Moderate comprehension for Selenium-experienced developers despite these style issues","tokens":986,"name":"149.jsnp"}
{"score":"75","reasoning":"The code snippet includes a verbose license header with an incorrect project reference to Foobar instead of sqsc-isqlj causing confusion The imports are clear but the misleading comment reduces readability and comprehension accuracy Standard header practices are followed yet the inconsistency detracts from professional presentation and understanding","tokens":2121,"name":"190.jsnp"}
{"score":"100","reasoning":"Well documented getter setter methods with clear naming and standard Javadoc comments ensuring high readability and ease of comprehension","tokens":3693,"name":"136.jsnp"}
{"score":"75","reasoning":"The code demonstrates clear structure with meaningful method names like selenium.open and isElementPresent. However readability is hindered by an outdated manual wait loop using Thread.sleep instead of modern explicit waits. The empty catch block suppresses exceptions reducing debuggability. Hardcoded strings like user paths decrease maintainability. Standard Selenium test patterns are recognizable but the timeout handling logic requires careful reading to understand flow. Author comment adds minimal context. Overall moderately comprehensible for experienced Java testers but contains several anti-patterns","tokens":896,"name":"203.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with clear method and variable names like duringRecurrence1 and assertRecurrenceEquals which effectively convey intent. Logical test structure checks before during and after recurrence scenarios aiding comprehension. Minor deductions for undefined dtStart and durationOneHour variables requiring superclass context and ambiguous numeric parameters in getRecurrence call which could benefit from named constants or comments for immediate clarity without external references","tokens":1920,"name":"159.jsnp"}
{"score":"60","reasoning":"The code has moderate readability issues including duplicated loop structures for timeout handling which reduces maintainability Hardcoded timeout values like 90 and 30000 should be constants Magic strings such as _145_addApplication and link\u003dRequests Test Page lack clarity Swallowing exceptions without logging in the catch block hides potential errors making debugging difficult Inconsistent use of selenium commands and missing comments further hinder comprehension Although indentation is consistent the overall structure could benefit from helper methods to eliminate repetition","tokens":1152,"name":"220.jsnp"}
{"score":"75","reasoning":"The snippet starts mid constructor causing initial confusion due to missing context for _app and app assignment However the paintComponent remove and addImpl methods are well structured following Swing best practices with clear listener management and standard overrides The lack of constructor context reduces readability but the core component logic is straightforward and easy to comprehend for experienced developers","tokens":5019,"name":"170.jsnp"}
{"score":"85","reasoning":"Initial continue in isolated block is confusing and non-idiomatic. Inconsistent brace placement in conditionals with else on new line. Otherwise clear variable names and logical flow for schema setup. Redundant else block for boolean assignment slightly reduces clarity but overall structure is understandable with descriptive identifiers","tokens":2902,"name":"187.jsnp"}
{"score":"88","reasoning":"The code snippet demonstrates clear structure with standard getter setter methods and Javadoc comments However the comment uses inconsistent acronym formatting class p k instead of classPK or class PK which slightly reduces readability The method names are intuitive and the overall logic is straightforward making it mostly easy to comprehend despite minor documentation flaws","tokens":688,"name":"141.jsnp"}
{"score":"65","reasoning":"The code has clear method names indicating listener management but suffers from non-descriptive parameter names like l and inconsistent formatting with mixed brace placement and spacing. Empty methods and notSupported calls lack explanatory comments making intent unclear. Overloading addTrackerListener is acceptable but inconsistent handling of listener types reduces comprehension. Poor naming choices and missing context about why some methods are empty while others throw exceptions hinder readability despite straightforward structure","tokens":1044,"name":"138.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with meaningful variable names and consistent indentation. Exception handling follows a logical pattern using instanceof checks which is understandable though the long conditional with multiple ORs reduces readability slightly. Lack of comments explaining the exception handling strategy and the context of RoleConstants could hinder comprehension for less familiar developers. The flow is straightforward but could benefit from extracting complex conditions into helper methods for better clarity","tokens":1705,"name":"111.jsnp"}
{"score":"65","reasoning":"The code has moderate readability issues. Infinite loops with magic numbers 90 and 1000 lack explanatory constants. Repetitive long XPath strings reduce clarity and increase error risk. Empty catch block hides potential exceptions making debugging difficult. Inconsistent structure with incomplete second loop fragment. Proper timeout handling and extracted constants would improve comprehension. Formatting is consistent but critical elements lack documentation","tokens":996,"name":"113.jsnp"}
{"score":"60","reasoning":"The code exhibits moderate readability with consistent indentation and logical structure but suffers from critical issues. Empty catch blocks for UnsupportedOperationException and NoSuchFileEntryException obscure error handling intent making comprehension difficult. Non-descriptive exception variable names like uoe reduce clarity. Deeply nested conditionals and lack of explanatory comments increase cognitive load. While framework-specific patterns are present the absence of error logging in ignored exceptions significantly impacts maintainability and understanding for academic evaluation standards","tokens":2399,"name":"180.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method names like getMethodName and getRootPath. Variable names such as elements and storage are descriptive. The logic flow is straightforward with minimal complexity. Minor deductions for the broad exception throws and missing _METHOD_NAME constant definition in the snippet though typical for partial code. Overall structure follows Java conventions making comprehension effortless","tokens":1508,"name":"125.jsnp"}
{"score":"95","reasoning":"The code snippet is a well-structured Java interface with clear method names and comprehensive Javadoc comments explaining each function\u0027s purpose parameters and exceptions Minor issues include a typo statge instead of stage and slightly awkward phrasing in one comment but these do not significantly hinder understanding The consistent use of standard cryptographic terminology and exception handling enhances readability for developers familiar with Java security APIs","tokens":1163,"name":"184.jsnp"}
{"score":"98","reasoning":"The code exhibits excellent readability with clear method names getQuestionVotes and getQuestionVotesCount that precisely describe functionality Parameters like questionId start end are intuitively named The implementation is straightforward delegation to a well-named service instance _pollsVoteLocalService Minor deduction for fully qualified exception name which adds verbosity without significantly hindering comprehension The structure is clean and immediately understandable even for junior developers","tokens":1658,"name":"214.jsnp"}
{"score":"70","reasoning":"Generic variable names find and value lack context for regex patterns making initial part hard to understand. Complex regex not broken down with comments. Methods are well structured but commented out debug code reduces clarity. Overall readability hindered by obscure pattern building despite good Javadoc for setValue method","tokens":3279,"name":"177.jsnp"}
{"score":"35","reasoning":"The code snippet exhibits poor readability due to incomplete structure starting with closing braces lack of context and unclear variable names like obs and obj Underscored methods _send _disconnect suggest non standard conventions without explanation Static send method accessing _instance complicates understanding without singleton context Fragmented presentation and absence of comments severely hinder comprehension","tokens":1140,"name":"132.jsnp"}
{"score":"45","reasoning":"The code has repetitive XPath locators and empty catch blocks which hide errors making debugging hard. The infinite loops with timeout are non-idiomatic and lack comments. RuntimeVariables usage is unclear without context. No abstraction for repeated elements reduces maintainability. Typical generated Selenium code without refactoring for readability","tokens":1471,"name":"173.jsnp"}
{"score":"100","reasoning":"The code snippet exhibits excellent readability with clear structure and meaningful naming conventions The purpose of aggregating test suites is immediately evident following standard JUnit patterns The abrupt termination is typical for snippets and does not impede understanding of the core logic presented","tokens":3217,"name":"207.jsnp"}
{"score":"95","reasoning":"The code is concise with clear method names indicating purpose. The constructor properly delegates to superclass. The getICMPHeaderByteLength method correctly returns 8 as standard ICMP header length. Minor deduction for using magic number 8 without named constant which slightly reduces readability for unfamiliar readers despite being standard knowledge in networking context","tokens":826,"name":"213.jsnp"}
{"score":"65","reasoning":"Code has inconsistent indentation and ambiguous variable names like bit. Critical condition lacks parentheses for clarity risking misinterpretation of and or precedence. Logic for quote handling is complex but partially mitigated by descriptive flags like bit contains quotes. Incomplete context hinders full assessment","tokens":1730,"name":"164.jsnp"}
{"score":"70","reasoning":"The code demonstrates logical flow for Selenium testing but suffers from significant readability issues. Key problems include duplicated timeout loops which reduce maintainability and comprehension. Empty catch blocks obscure error handling intent making debugging unclear. Use of non-standard RuntimeVariables without context adds confusion. While indentation and structure are consistent the repeated patterns and lack of comments hinder ease of understanding. Variable names like second are acceptable but overall the code would benefit from helper methods to eliminate redundancy and improve clarity","tokens":1514,"name":"110.jsnp"}
{"score":"75","reasoning":"The initial code fragment lacks context and method signature causing confusion however the test methods are well written with clear intent and proper exception handling","tokens":3005,"name":"178.jsnp"}
{"score":"95","reasoning":"The code snippet is highly readable with a clear interface name DownloadTypeIncomplete and concise purpose comment explaining its role in registration. The extensive license header is standard for GPL projects and does not obstruct comprehension of the core functionality. The empty interface structure is acceptable as a marker interface for plugin systems. Minor deduction for the lengthy license comment reducing code density but overall very clear and well-structured","tokens":2585,"name":"160.jsnp"}
{"score":"100","reasoning":"The code snippet features three clearly named method declarations with intuitive return types. Each method name precisely conveys its purpose getInterval getMinInterval and getTimeUntilNextUpdate without ambiguity. The consistent formatting despite line breaks between return types and method names remains highly readable. Self-explanatory naming eliminates the need for additional comments making comprehension immediate and effortless for any developer familiar with basic Java conventions. This represents exemplary readability","tokens":2586,"name":"158.jsnp"}
{"score":"65","reasoning":"The code exhibits moderate readability with clear Selenium test structure but suffers from magic numbers 90 and 1000 duplicated timeout loops and empty exception handling which obscure intent Long XPath expressions and hard-coded strings reduce clarity Lack of comments explaining test flow and absence of helper methods for repeated patterns increase cognitive load despite consistent indentation and logical sequencing of test steps","tokens":1839,"name":"194.jsnp"}
{"score":"65","reasoning":"The code snippet has clear variable names and straightforward logic within the synchronized block. However it is incomplete ending abruptly in the middle of an else block without closing braces. This makes the overall structure unclear and hinders comprehension of the intended flow. The abrupt ending is a major flaw for readability as it leaves the logical sequence unresolved and creates syntactic ambiguity. While the existing lines are well formatted the lack of closure significantly impacts understanding","tokens":3176,"name":"156.jsnp"}
{"score":"100","reasoning":"The code is a straightforward Java setter method with clear naming conventions and proper Javadoc documentation. The method name explicitly describes its purpose matching the parameter and field names. The implementation is minimal and logically sound with no unnecessary complexity. Javadoc provides standard API documentation expected in professional Java development. The structure follows common patterns making it instantly recognizable and easy to understand for developers familiar with JavaBeans conventions. No ambiguous elements or convoluted logic present","tokens":698,"name":"161.jsnp"}
{"score":"95","reasoning":"Clear structure with descriptive variable names and straightforward logic. Repetitive date handling slightly reduces efficiency but remains easy to follow. Simple conditionals and linear flow enhance comprehension. Use of Long MIN VALUE as null placeholder is common practice though minor context could help","tokens":1944,"name":"142.jsnp"}
{"score":"78","reasoning":"Code logic is clear removing quotes and trailing separators but inconsistent spacing around variables and assignments reduces readability. The comment uses informal language stuff up which is unprofessional. Variable changed is vague but context helps. Overall comprehensible with minor effort","tokens":2947,"name":"115.jsnp"}
{"score":"98","reasoning":"Class and constant names are extremely clear making comprehension immediate Missing class description comment is minor but does not hinder understanding of activity keys 1 and 5","tokens":3933,"name":"189.jsnp"}
{"score":"92","reasoning":"The code demonstrates clear structure with well-named variables and methods. Consistent underscore prefixing for fields aids in distinguishing instance variables. Minimal logic in methods enhances readability. Comments for empty initialize uninitialize methods provide useful context. Slightly hindered by non-Javadoc comments and abbreviated field names like _myscrolledPanel which could be more descriptive. Overall straightforward and easy to follow for experienced developers","tokens":1454,"name":"147.jsnp"}
{"score":"70","reasoning":"The code has clear step-by-step selenium commands but suffers from significant repetition in timeout loops reducing readability Magic numbers like 90 and 1000 lack context Empty exception handlers obscure error handling logic Inconsistent waits with Threadsleep instead of explicit waits add confusion Well indented but duplicated patterns could be refactored into helper methods for better comprehension","tokens":1578,"name":"210.jsnp"}
{"score":"90","reasoning":"The code demonstrates clear structure with meaningful variable names KaleoTimer model and soapModels enhancing readability The for-each loop is straightforward and follows standard Java conventions The toArray conversion is idiomatic though slightly dense for beginners The empty constructor is minimal but appropriate for the context No unnecessary complexity or obscure patterns are present making comprehension efficient for experienced Java developers","tokens":842,"name":"171.jsnp"}
{"score":"20","reasoning":"The snippet starts with a closing brace creating immediate confusion about context. Abstract method declaration lacks enclosing abstract class visibility making it appear invalid. toString method uses undefined variable string and unexplained Hex utility without imports or class context. Critical elements missing prevent comprehension of purpose or correctness leading to very poor readability","tokens":1439,"name":"169.jsnp"}
{"score":"65","reasoning":"The code has moderate readability issues. The infinite loop with manual timeout handling is non-idiomatic Selenium usage; modern explicit waits would improve clarity. Empty catch block hides exceptions reducing debuggability. Thread.sleep usage is discouraged in favor of dynamic waits. Method name lacks descriptive context about the assertion purpose. Basic structure is understandable but poor error handling and outdated patterns hinder comprehension","tokens":1089,"name":"219.jsnp"}
{"score":"98","reasoning":"The code demonstrates excellent readability with clear variable names and logical structure. Each setter call is well formatted and the conditional block is appropriately separated by blank lines. The sequence is straightforward. Minor deduction for the length of the setter sequence without explicit section comments but overall very strong.","tokens":4062,"name":"148.jsnp"}
{"score":"70","reasoning":"The code implements a polling loop for element visibility but has significant readability issues The empty catch block swallows all exceptions without logging or explanation making debugging difficult and reducing maintainability Catching broad Exception type instead of specific exceptions further obscures intent Despite simple structure the anti-pattern hinders comprehension for maintainers","tokens":3391,"name":"105.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with clear naming conventions like pnlName and lblName adhering to Swing component prefixes. The BorderLayout usage is standard and logical for label input pairing. The i18n comment explains string localization intent though its bracket syntax is slightly unconventional. Minimal complexity with linear structure aids comprehension. Missing context for s_stringMgr and pnlEdit slightly impacts clarity but remains understandable within a snippet context","tokens":878,"name":"196.jsnp"}
{"score":"95","reasoning":"The code is a well-structured Java interface with clear method names that effectively communicate their purpose such as setSourceSession and getDestSession. Consistent naming conventions and logical grouping of source destination related methods enhance readability. Minor deductions for using abbreviated Dest instead of Destination and a slightly redundant comment for getScriptFileManager which does not add significant value beyond the method name. Overall the interface is straightforward and easy to comprehend","tokens":1654,"name":"200.jsnp"}
{"score":"65","reasoning":"The code uses a non-standard control flow with a while loop and switch on a mutable label variable leading to confusing execution paths The label jumping between cases reduces readability significantly The empty for loop condition and lack of descriptive variable names for control flow add complexity Although Selenium commands are clear the overall structure with nested loops switch and continue statements makes comprehension challenging for maintainers","tokens":1341,"name":"205.jsnp"}
{"score":"45","reasoning":"The code exhibits poor readability due to non-standard control flow with labels and continues causing confusing jumps between cases. An empty catch block swallows exceptions without logging or handling severely impacting maintainability. Repeated complex XPath locators are not abstracted into constants increasing visual noise. Fixed Thread.sleep usage and cryptic regex assertions further reduce clarity. Although individual Selenium commands are recognizable the overall structure is messy and error-prone","tokens":2254,"name":"121.jsnp"}
{"score":"90","reasoning":"Code exhibits clear structure with descriptive variable names and straightforward validation logic. Repetition between similar methods slightly reduces readability but consistent patterns aid comprehension. Proper use of error handling with explicit parameter checks. Minor deductions for duplicated code blocks and lengthy variable names impacting conciseness without compromising understanding","tokens":1534,"name":"206.jsnp"}
{"score":"50","reasoning":"The code snippet has clear class and method names and consistent formatting but is critically incomplete ending mid for loop This breaks comprehension as the loop body and test logic are missing The timeout pattern is recognizable but without the awaited condition the test purpose remains unclear","tokens":2707,"name":"114.jsnp"}
{"score":"95","reasoning":"The code demonstrates strong readability with clear structure meaningful names and appropriate Javadoc comments. The method logic is straightforward with well-handled exception logging. Minor deduction due to inconsistent use of DeleteAliasAction class in static initializers within AliasAction causing slight confusion. Overall excellent organization and comprehension ease","tokens":1742,"name":"137.jsnp"}
{"score":"95","reasoning":"The code exhibits excellent readability with clear method names following Java bean conventions. Standard underscore-prefixed field naming is conventional and easily understood. Logic is straightforward with minimal cognitive load despite slightly verbose hasError implementation. Self-explanatory methods eliminate need for comments. Incomplete snippet missing field declarations is minor issue not significantly impacting comprehension of the presented structure","tokens":1304,"name":"163.jsnp"}
{"score":"95","reasoning":"Code is minimal and highly readable with clear class name LockException indicating its purpose Inheritance from PortalException is standard and constructor is straightforward Javadoc lacks descriptive explanation of exception purpose beyond author tag slightly reducing documentation quality but code structure remains exceptionally easy to comprehend","tokens":1733,"name":"182.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability through consistent repetitive structure and descriptive class names that clearly indicate test purposes. Each line follows an identical pattern making it instantly recognizable. Minor deduction as numeric suffixes in some class names like AddMBMessage1Tag1Test could be slightly more descriptive but remain understandable within context. Overall extremely easy to comprehend with no complex logic or ambiguous elements","tokens":1853,"name":"155.jsnp"}
{"score":"30","reasoning":"The code contains an unnecessary try-catch block with an empty handler which swallows exceptions without explanation making debugging difficult The break statement lacks loop context causing ambiguity Although the condition is clear the redundant structure and poor error handling severely reduce readability and comprehension","tokens":2067,"name":"218.jsnp"}
{"score":"75","reasoning":"The code demonstrates logical structure with clear method flow but suffers from inconsistent indentation and excessive verbosity due to fully qualified class names. Nested exception handling is correct yet overly complex with redundant checks. Lack of comments and abrupt truncation of the second method hinder immediate comprehension despite generally meaningful variable names and standard Java patterns used in Liferay framework context","tokens":1873,"name":"162.jsnp"}
{"score":"75","reasoning":"The code has clear structure and descriptive variable names but suffers from non-standard Java naming conventions with leading underscores in private methods and a misspelling in _proccessAttributes. Lack of comments makes regex logic in _isEventAttribute unclear. The use of Collections.EMPTY_LIST and fixed-size list is acceptable but could be confusing. Overall moderately readable with room for improvement in naming and documentation","tokens":1796,"name":"211.jsnp"}
{"score":"40","reasoning":"The snippet starts with multiple dangling closing braces without context making it appear broken and confusing. The method isBuddy returns int but its name suggests a boolean which is misleading. Variable peer_ip uses underscore against Java convention. However the indentation is good and the assignment is clear. Overall the lack of context and confusing structure severely hampers comprehension","tokens":1516,"name":"117.jsnp"}
{"score":"65","reasoning":"The code snippet shows a well-structured Java interface with clear naming conventions and relevant annotations from Eclipse Sapphire framework. However it lacks method definitions or properties within the interface body making its purpose ambiguous. The incomplete structure with an open brace and no functional content reduces comprehension. Annotations like GenerateImpl are meaningful for domain experts but may confuse others. Author comment adds little value for understanding logic. Overall moderate readability due to good organization but significantly hindered by missing implementation details essential for full context","tokens":1381,"name":"179.jsnp"}
{"score":"92","reasoning":"The code snippet is concise with clear class and field names indicating its purpose for graph connection points The boolean field name is descriptive though slightly long The absence of methods is noted but the provided structure is highly readable and easy to comprehend despite being incomplete","tokens":1799,"name":"128.jsnp"}
{"score":"65","reasoning":"Code structure is logical with clear method names and consistent transactional annotations However excessive use of fully qualified class names like com liferay portal kernel exception PortalException significantly reduces readability by adding verbosity and visual clutter Lack of imports makes comprehension harder despite good parameter naming and organization","tokens":1966,"name":"144.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with clear method names testCreate testRemove etc. following standard testing patterns. Variables like newSCProductVersion are self-explanatory. Helper methods nextLong randomString abstract test data generation effectively. Minor deductions for testUpdateNew lacking assertions and testUpdateExisting being incomplete in the snippet which slightly reduces clarity. Overall structure is logical and easy to follow for Java developers familiar with unit testing frameworks.","tokens":1956,"name":"120.jsnp"}
{"score":"60","reasoning":"The code snippet shows a Selenium polling pattern but suffers from poor readability due to an empty catch block that silently swallows exceptions without explanation making debugging difficult. The XPath string is excessively long and split awkwardly across lines with inconsistent indentation. While the break condition is clear the lack of error handling context and brittle hardcoded ID reduce overall comprehension especially for less experienced developers","tokens":3080,"name":"124.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear structure and excellent Javadoc documentation explaining purpose parameters and return values. Method names like getParameterSpec are self-explanatory and logic is straightforward with minimal complexity. The only minor deduction is for the slightly terse variable name ecP though it remains acceptable in cryptographic context. Overall very easy to comprehend for Java developers","tokens":1135,"name":"122.jsnp"}
{"score":"45","reasoning":"Empty catch block swallows exceptions making debugging impossible Magic string for element locator lacks clarity and context Inconsistent indentation and missing surrounding structure reduce readability Core wait logic is discernible but poor practices significantly hinder comprehension and maintainability","tokens":2248,"name":"143.jsnp"}
{"score":"95","reasoning":"Code is concise with clear conditional logic and descriptive error message. Proper use of constants and straightforward method structure enhance readability. Minor deduction for non-standard _value variable naming convention which slightly deviates from typical Java camelCase practices but remains understandable","tokens":1782,"name":"109.jsnp"}
{"score":"95","reasoning":"The code demonstrates excellent readability through consistent repetitive structure and clear method naming Each updatePortletPermissions call follows a uniform pattern with well-organized permission arrays String literals for portlet IDs are standard in Liferay context though constants could marginally improve maintainability Formatting uses proper indentation and line breaks for multi-permission entries making it instantly comprehensible The abrupt end does not detract from the evaluated portion which is logically structured and self-explanatory","tokens":2605,"name":"127.jsnp"}
{"score":"98","reasoning":"Code demonstrates excellent readability with proper JavaBean conventions and comprehensive Javadoc. Minor documentation inconsistency using lowercase for meetups registration instead of proper noun capitalization. All parameters and exceptions clearly documented ensuring high comprehension","tokens":3173,"name":"130.jsnp"}
{"score":"90","reasoning":"The code is well-structured with clear interface and method names. Javadoc comments effectively explain each method\u0027s purpose including parameter details and return value semantics. The package name is descriptive though lengthy. Minor deduction for using raw Map type without generics despite adequate documentation explaining its structure. Authors are credited aiding maintenance context. Overall highly readable with only slight room for modernization","tokens":1750,"name":"216.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with clear structure and meaningful variable names. Logical flow is straightforward: null check key get locale fetch value and conditional logging. Proper indentation and concise methods enhance comprehension. Minor deduction for the verbose string concatenation in debug logging which could be improved with String format but remains understandable. Unsupported operation methods are appropriately minimal and clear","tokens":2027,"name":"154.jsnp"}
{"score":"88","reasoning":"The code demonstrates clear structure and logical flow with descriptive variable names enhancing readability. Repetitive append patterns and null checks are straightforward but slightly verbose. Magic number 17 in StringBundler instantiation lacks explanation potentially confusing unfamiliar readers. Consistent indentation and explicit null handling improve comprehension despite minor redundancy in conditional assignments. Overall well-organized for maintenance and understanding","tokens":1636,"name":"197.jsnp"}
{"score":"20","reasoning":"The snippet starts with an invalid syntax dangling string literal causing confusion The long non descriptive locator name hampers readability The continue statement and label assignment lack loop context The RuntimeVariables replace with empty string serves no clear purpose Overall the code is hard to understand due to broken structure and missing context","tokens":2403,"name":"129.jsnp"}
{"score":"95","reasoning":"Code demonstrates clear delegation pattern with straightforward method implementations. Minor deduction for non standard underscore prefixed field names which deviate from typical Java conventions but remain consistent. The setAuthToken method null handling is logical though a brief comment could enhance clarity. Overall structure is concise and easy to follow without unnecessary complexity","tokens":3328,"name":"139.jsnp"}
{"score":"75","reasoning":"The code snippet consists of method declarations with clear purpose but suffers from redundant parameter naming LiferayPortletRequest liferayPortletRequest repeats type information unnecessarily. Method names like getURLExport follow camelCase with proper acronym casing while getUrlTitle shows inconsistent casing for URL. The throws Exception declaration is broad but common in interfaces. Lack of context or implementation limits full assessment but overall structure is understandable despite minor readability issues in naming conventions","tokens":1316,"name":"195.jsnp"}
{"score":"100","reasoning":"The snippet features standard copyright and license comments which are clear and well-structured. The package declaration is descriptive and follows Java conventions. Imports are organized one per line from logical package hierarchies making dependencies immediately visible. All elements adhere to industry best practices with no ambiguous naming or complex structures. The minimal content is exceptionally easy to comprehend due to its conventional formatting and absence of unnecessary complexity. This represents ideal boilerplate readability for Java source files.","tokens":3780,"name":"134.jsnp"}
{"score":"95","reasoning":"The code snippet is well-structured with clear variable names and logical flow It demonstrates standard Swing practices for creating a test UI The indentation is consistent and the steps are easy to follow Although the snippet is incomplete missing closing braces the provided lines are highly readable and self-explanatory The absence of the SQLAliasConnectionProperties import is a minor issue but the class name is descriptive enough Overall the code is straightforward and easy to comprehend","tokens":3626,"name":"123.jsnp"}
{"score":"65","reasoning":"Code shows consistent remote service call pattern but requires Liferay framework knowledge. Exception handling is repetitive yet standard. Second method incomplete missing return statement causing confusion. Non idiomatic method names with underscores. Overall structure clear but framework specific and incomplete part lowers readability","tokens":5092,"name":"165.jsnp"}
{"score":"65","reasoning":"The code features clear getter methods but toString implementation is problematic with magic number 32767 unclear purpose and possible typo Plaform instead of Platform String concatenation style is hard to read Abbreviations like cn and AZID lack explanatory context reducing comprehension despite logical method organization and proper encapsulation practices","tokens":2046,"name":"108.jsnp"}
{"score":"95","reasoning":"Code is highly readable with clear variable names puncher and logical flow. Meaningful method names like getNATPuncher and punch enhance comprehension. Minor deductions for non-idiomatic return parentheses usage and magic string Tunnel which could be a constant. Null check is straightforward and concise.","tokens":2086,"name":"185.jsnp"}
{"score":"80","reasoning":"The first method is well-structured with clear naming and logical flow making it highly readable However the incomplete second method and missing class closing brace disrupt structural comprehension despite readable signature elements","tokens":7726,"name":"119.jsnp"}
{"score":"90","reasoning":"The code has a minor style issue with space before closing parenthesis in method parameters but is otherwise well documented and formatted clearly The incomplete initial fragment is acceptable in a snippet context","tokens":6744,"name":"118.jsnp"}
