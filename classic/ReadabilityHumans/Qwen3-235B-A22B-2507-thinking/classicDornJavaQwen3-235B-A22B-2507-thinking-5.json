{"score":"88","reasoning":"The code demonstrates strong readability with clear variable names logical flow and consistent indentation Early returns simplify control structure Meaningful method names enhance comprehension Limited exception handling details and minor complexity in nested conditionals prevent a higher score but overall structure is clean and maintainable","tokens":1044,"name":"101.jsnp"}
{"score":"80","reasoning":"The code is concise with clear method names and logical structure however the commented-out assignment in the constructor reduces readability as it introduces unnecessary noise and potential confusion about its purpose without explanation Dead code should be removed to maintain clarity The getIcon method is straightforward but the presence of inactive code detracts from overall comprehension","tokens":891,"name":"181.jsnp"}
{"score":"60","reasoning":"The code exhibits poor readability due to unconventional control flow using a while loop with a switch-case structure for a single label which complicates understanding. The busy-wait loop with Thread.sleep is non-idiomatic and inefficient. Although Selenium commands are clear the unnecessary label variable and convoluted structure hinder comprehension. Lack of comments explaining the test logic further reduces clarity despite standard method naming conventions","tokens":1053,"name":"102.jsnp"}
{"score":"88","reasoning":"The code exhibits clear structure with meaningful class and variable names. Proper use of comments explains internationalization setup. The nested i18n interface for string constants is well-documented though slightly unconventional. Resource key indirection requires external files for full context but follows standard i18n practices. SerialVersionUID inclusion shows attention to detail. Constructor is straightforward but snippet ends prematurely limiting full assessment","tokens":1225,"name":"172.jsnp"}
{"score":"95","reasoning":"The code snippet consists of well-organized import statements with clear package hierarchies and no syntax errors. Each import is explicitly declared on separate lines enhancing readability. The logical grouping of Liferay-specific utilities followed by standard Java libraries demonstrates good structure. However the heavy reliance on domain-specific Liferay classes may require framework knowledge for full comprehension slightly reducing accessibility for general audiences","tokens":1116,"name":"208.jsnp"}
{"score":"65","reasoning":"The code demonstrates a Selenium test loop with timeout handling but suffers from poor readability due to magic numbers 90 and 1000 without explanation empty catch block suppressing exceptions and unconventional infinite loop structure using for instead of while Proper comments and constants would improve clarity however the selenium operations follow recognizable testing patterns for experienced developers","tokens":1222,"name":"212.jsnp"}
{"score":"92","reasoning":"The code excels in readability with comprehensive Javadoc explaining each parameter in the constructor particularly the seven parameters which are clearly described. Method and variable names are descriptive and consistent. The structure follows standard Java conventions with logical grouping of constructors and accessors. Minor deductions for the long parameter list in the constructor which slightly impacts clarity despite good documentation and inconsistent use of \u0027a\u0027 prefix in some parameter names like aColumnName versus catalog. Overall very easy to comprehend due to excellent comments and clean organization","tokens":1394,"name":"221.jsnp"}
{"score":"75","reasoning":"Repeated null checks and logging across methods reduce readability through redundancy. Clear method names and logical flow aid comprehension but absence of a shared validation helper increases verbosity and maintenance effort. Abrupt code termination in final method slightly impacts clarity despite otherwise straightforward structure","tokens":1426,"name":"116.jsnp"}
{"score":"70","reasoning":"The code is linear and uses descriptive method names which aid comprehension However excessive repetition of waitForPageToLoad and loadRequiredJavaScriptModules reduces readability The timeout loop with empty catch block and hardcoded values like 30000 and file paths also hinder clarity despite clear sequential flow and meaningful identifiers for test data","tokens":1696,"name":"198.jsnp"}
{"score":"35","reasoning":"The code snippet lacks context with abrupt start and incomplete case structure making flow comprehension difficult. Inconsistent indentation magic strings like _15_rowIds and hardcoded timeouts reduce clarity. Unexplained label usage and continue statement without visible loop context confuse control flow. Repetitive waitForPageToLoad calls could be refactored. Selenium commands are recognizable but overall structure is fragmented and poorly organized for readability","tokens":1449,"name":"193.jsnp"}
{"score":"85","reasoning":"The code snippet demonstrates good structure with meaningful variable names like update_dir and found_failure. Standard Java conventions are followed including proper indentation and clear method naming. However the abrupt ending mid-method hinders full comprehension as the logic for processing files is incomplete. The comment about changing constants is informal but not obstructive. Overall readability is strong despite the snippet truncation limiting complete understanding of the implementation flow","tokens":1588,"name":"151.jsnp"}
{"score":"95","reasoning":"Code exhibits strong readability with descriptive method names like testDynamicQueryByProjectionMissing and clear variable naming. Logical flow in test methods is easy to follow with focused responsibilities. Helper method addRatingsEntry reduces duplication. Minor deduction for abrupt ending in the last method which may cause confusion but overall structure is clean and self-explanatory without needing excessive comments. Consistent style and meaningful assertions enhance comprehension.","tokens":1672,"name":"204.jsnp"}
{"score":"45","reasoning":"The code has repetitive selenium steps with long xpaths reducing readability Magic numbers like label 3 and 9 lack context The abrupt start and end without loop or switch context confuses flow Variable names for booleans are good but overall structure is messy due to lack of abstraction for repeated actions and complex regex in assertions","tokens":1772,"name":"152.jsnp"}
{"score":"90","reasoning":"The code demonstrates clear structure with consistent indentation and logical flow across methods. Variable names like comp and constraints are concise yet meaningful. Use of _listener is consistent though underscore prefix may slightly hinder readability for some. Methods are short with straightforward operations making comprehension easy. Lack of comments is mitigated by self-explanatory logic. Minor deduction for unconventional instance variable naming style","tokens":1470,"name":"170.jsnp"}
{"score":"95","reasoning":"Code exhibits high readability with clear method names and consistent structure Each method is concise and focused on a single responsibility The persistence layer interaction is straightforward and follows standard patterns Minor deduction for missing method signature in first block but overall logic is easily comprehensible without complex constructs or ambiguous naming","tokens":1591,"name":"153.jsnp"}
{"score":"85","reasoning":"The code demonstrates good structure with clear method names and logical flow for color caching. However readability is impacted by a commented-out log statement in exception handling which creates confusion. The silent exception swallowing without explanation reduces comprehension. Static colorMap usage lacks thread-safety comments though acceptable in context. Variable names are adequate but sID could be more descriptive. Overall well-organized but minor issues prevent higher score","tokens":1814,"name":"166.jsnp"}
{"score":"95","reasoning":"Code exhibits high readability with clear method names setGadgetKey and getServiceName following Java conventions Javadoc for getServiceName explains purpose despite minor typo o auth instead of OAuth The incomplete Javadoc visibility for setGadgetKey in snippet is negligible as method signature is self-explanatory Annotation usage is framework-appropriate and unobtrusive Overall structure is clean and easily comprehensible","tokens":1602,"name":"168.jsnp"}
{"score":"72","reasoning":"The code has logical structure and helpful comments but suffers from non-descriptive variable names like am and dm raw ArrayList usage without generics and confusing temporary lists parameter_group and disable_on_install The lack of generics reduces type clarity and the variable names require extra effort to decipher The flow is sequential but the purpose of some collections is not immediately clear","tokens":2057,"name":"106.jsnp"}
{"score":"75","reasoning":"Code structure is clear with consistent indentation and logical flow but readability hindered by placeholder BETTER_THAN requiring context guessing. Magic numbers 0.2f and 0.4f lack explanation. Variable dif is ambiguous without definition. Descriptive names like trialFitness help but undefined terms and non-standard syntax reduce comprehension despite good organization","tokens":1879,"name":"112.jsnp"}
{"score":"75","reasoning":"The code is procedural and actions are clear but uses magic numbers like 30000 and 90. The waiting loop is outdated and error-prone compared to explicit waits. RuntimeVariables usage lacks context. Overall readable for Selenium experts but could be improved with constants and modern waiting techniques. Score reflects moderate readability with room for improvement","tokens":1095,"name":"167.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear getter methods following standard Java conventions. Consistent naming and structure enhance comprehension. The hashCode and equals implementations are correct and well-commented adhering to best practices. Minor deductions for non-standard underscore-prefixed field names which slightly deviate from typical Java style but do not significantly hinder understanding. The logic is straightforward and well-organized","tokens":2038,"name":"150.jsnp"}
{"score":"40","reasoning":"The snippet starts with an incomplete expression WorkflowConstants.CONTEXT_ENTRY_CLASS_NAME)); causing immediate confusion due to dangling parentheses and semicolon. This breaks comprehension flow. The subsequent if-statement is logically clear but suffers from deeply nested method calls GetterUtil.getLongString)workflowContext.get) and explicit casting which reduce readability. The inconsistent indentation further complicates visual parsing. Critical lack of context around the initial fragment severely impacts overall understandability despite descriptive constant names","tokens":1873,"name":"133.jsnp"}
{"score":"78","reasoning":"The code is mostly readable with clear sequential Selenium commands but has drawbacks. Brittle XPath locators like //span[@title\u003d\u0027Actions\u0027]/ul/li/strong/a/span reduce maintainability. Repeated loadRequiredJavaScriptModules calls after each page load seem redundant without explanation. RuntimeVariables.replace usage lacks context making its purpose unclear. The abrupt label\u003d2 continue suggests missing loop context which disrupts flow comprehension. Timeout loop using counters is outdated compared to explicit waits but remains understandable. Overall logical flow for a test script but could improve with better element selectors and reduced repetition.","tokens":1468,"name":"157.jsnp"}
{"score":"95","reasoning":"Code is highly readable with clear consistent setter chains and straightforward logic Minor deductions for repetitive setter calls and a redundant variable in compareTo method which slightly reduces conciseness without hindering understanding","tokens":1166,"name":"183.jsnp"}
{"score":"72","reasoning":"The code demonstrates standard Selenium test structure with a timeout loop for element visibility. However readability is hindered by empty exception handling which obscures error logic and magic numbers 90 1000 without constants. Method name is descriptive but lack of explanatory comments for timeout mechanism and swallowed exceptions reduces maintainability. Standard Java conventions are followed but poor error handling practices lower comprehension score","tokens":1043,"name":"209.jsnp"}
{"score":"15","reasoning":"The code snippet is incomplete with orphaned closing braces making context unclear. Empty catch block for Exception hides errors and is dangerous practice. Thread.sleep uses magic number 1000 without explanation. Long XPath string not abstracted into constants reduces readability. These critical flaws severely hinder comprehension and maintenance efforts despite simple structure","tokens":2035,"name":"174.jsnp"}
{"score":"80","reasoning":"The code exhibits consistent structure across methods with clear try-catch blocks making error handling predictable However repetitive exception handling logic duplicates the same pattern three times increasing verbosity without adding value While the uniformity aids initial comprehension the lack of abstraction for common error handling reduces readability slightly as maintenance would require updating multiple identical blocks","tokens":2159,"name":"140.jsnp"}
{"score":"85","reasoning":"The code follows standard Java bean conventions with clear naming and proper encapsulation. However readability is slightly hindered by verbose fully qualified class names and potentially confusing method overloading where getArchiveFiles serves dual purposes for array and index access. Javadoc comments are present but somewhat redundant for basic getters setters. The structure is logical but the index based methods could cause comprehension issues for new readers","tokens":1403,"name":"188.jsnp"}
{"score":"95","reasoning":"The code exhibits excellent readability with clear method and parameter names that convey intent. The constructor properly initializes state and the execute method follows a logical pattern of storing old value before update. Variable names like serverManagerContextPath are descriptive without being overly verbose. Minor deduction because the oldServerManagerContextPath field declaration isn\u0027t shown in the snippet causing slight initial context gap but overall structure remains highly comprehensible","tokens":1166,"name":"104.jsnp"}
{"score":"35","reasoning":"The code snippet is part of a Selenium test with significant readability issues. It starts mid-switch case causing immediate confusion about context. Hardcoded strings magic numbers like 90 and 1000 and complex xpaths reduce clarity. The wait loop uses an empty catch block which is bad practice. Jumping between cases via label assignment is non standard and hard to follow. Inconsistent indentation and lack of comments further hinder comprehension. Although test automation patterns are recognizable the implementation choices make it difficult to read and maintain","tokens":1592,"name":"107.jsnp"}
{"score":"55","reasoning":"The code snippet contains an empty catch block which swallows exceptions without logging or handling making debugging difficult and reducing readability The break statement implies a loop context not visible in the snippet causing confusion The fail timeout call is clear but poor exception practice and missing structural context significantly hinder comprehension Best practices are violated by ignoring exceptions","tokens":2202,"name":"192.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear variable names like tablesSQL and indexesSQL that immediately convey purpose. Logical flow is straightforward with consistent indentation and minimal nesting. Descriptive method calls such as db.updateIndexes enhance comprehension. The conditional checks in upgradeProcess are easy to follow. Minor deduction for abrupt snippet ending affecting completeness but presented code remains exceptionally clear and well-structured for maintenance","tokens":2546,"name":"103.jsnp"}
{"score":"90","reasoning":"The code demonstrates clear structure with meaningful class and method names following JUnit conventions The suite method logically aggregates test components using descriptive test suite references like LoginTests and TagsTestPlan Minimal complexity enhances readability though the numeric suffix 528 in class name slightly reduces immediate clarity without contextual knowledge Proper indentation and standard patterns contribute to strong comprehension despite being a partial snippet","tokens":1657,"name":"176.jsnp"}
{"score":"70","reasoning":"The code shows consistent formatting and clear method names but suffers from incomplete Javadoc lacking parameter descriptions Despite helpful inline comments for encoding_type and defaultValue the absence of explanatory text in documentation significantly hampers comprehension for new developers Underscore in parameter names like resource_name deviates from Java conventions and the unexplained 2 suffix in method names adds minor confusion","tokens":1683,"name":"201.jsnp"}
{"score":"65","reasoning":"The code snippet exhibits clear method names that are descriptive and follow Java conventions however the unconventional line breaks between return types and method names significantly hinder readability by disrupting standard formatting expectations This structure forces unnecessary cognitive load to parse each declaration reducing overall comprehension efficiency despite the logical naming","tokens":792,"name":"158.jsnp"}
{"score":"95","reasoning":"The test method is well-structured with clear variable names for test cases before during and after recurrence The use of descriptive method names and constants enhances readability The only minor issue is the lack of self-explanatory parameters in getRecurrence call but the test data clarifies the intent Overall very easy to comprehend for a unit test","tokens":1529,"name":"159.jsnp"}
{"score":"60","reasoning":"The code exhibits moderate readability issues due to repetitive waiting loops that could be refactored into a helper method. Manual timeout handling with Thread.sleep instead of explicit waits reduces clarity. Lack of in-method comments makes test flow harder to follow. However selenium method names are descriptive and structure is linear. Duplicated loop logic and swallowed exceptions without logging significantly hinder comprehension for maintainability.","tokens":2105,"name":"145.jsnp"}
{"score":"50","reasoning":"The code snippet starts mid statement causing confusion and ends abruptly The variable rule is used without declaration in the snippet The serveResource method is clear but incomplete Overall the fragment lacks context making comprehension difficult despite good naming conventions in parts","tokens":3084,"name":"186.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method and variable names following Java conventions Logical grouping of related properties enhances comprehension Consistent indentation and straightforward linear flow without complex logic aid understanding Minor deductions for potential domain-specific terms like Plid and ambiguous variable now which may require context for full clarity However the structure remains clean and easy to follow for experienced developers","tokens":1345,"name":"148.jsnp"}
{"score":"85","reasoning":"The code exhibits clear structure with standard try-catch-finally blocks and descriptive variable names like session and orderByComparator. Logic for query execution and caching is straightforward for Java developers familiar with ORM patterns. However the abrupt snippet start end causes minor context confusion regarding list variable declaration and missing closing braces. SQL concatenation approach is acceptable but could use parameterized queries for safety","tokens":1818,"name":"202.jsnp"}
{"score":"35","reasoning":"The code snippet lacks essential context with abrupt control flow mixing loop continue and switch case labels without enclosing structures causing significant confusion Hardcoded values like 90 and 1000 reduce clarity Inconsistent indentation and missing comments exacerbate readability issues despite standard Selenium operations being recognizable The Unicode character usage is acceptable but overall comprehension is severely hindered by structural ambiguity","tokens":1675,"name":"217.jsnp"}
{"score":"65","reasoning":"The code has logical structure and descriptive variable names but suffers from poor readability due to empty catch blocks without explanations which obscure error handling intent Deeply nested conditionals and non standard underscore prefixed private methods reduce comprehension Consistent indentation helps but swallowed exceptions and lack of comments hinder understanding of critical flow decisions","tokens":1683,"name":"180.jsnp"}
{"score":"55","reasoning":"The code has significant readability issues due to empty catch blocks that hide errors magic numbers without explanation and an incomplete second loop structure truncating critical logic Thread sleep usage instead of explicit waits reduces maintainability Hardcoded XPaths and lack of comments further hinder comprehension despite consistent indentation and clear selenium method calls","tokens":1321,"name":"220.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with logical flow for a Selenium test case. Proper indentation and meaningful variable names like second enhance readability. The timeout loop is a common pattern in UI testing though the magic numbers 90 and 1000 would benefit from named constants. The empty catch block reduces clarity slightly as it suppresses exceptions without logging but is typical in Selenium wait logic. Overall the purpose is easily understood by experienced Java testers","tokens":1256,"name":"203.jsnp"}
{"score":"75","reasoning":"The code structure is clear with meaningful class and method names but the test name implies adding a front page while the provided snippet only opens home page and loads modules without any addition steps causing confusion about the test purpose The abrupt end without completion of test logic reduces comprehension despite good formatting and standard selenium usage","tokens":3227,"name":"191.jsnp"}
{"score":"85","reasoning":"The code demonstrates strong readability with clear variable names and logical flow. Proper indentation and line breaks in the long method call enhance comprehension despite numerous parameters. The use of descriptive method names like getFieldsMap and updateFileEntry aids understanding. However the presence of a null parameter without context slightly reduces clarity as its purpose is ambiguous. Overall the structure adheres to good practices making it relatively easy to follow for developers familiar with similar frameworks","tokens":2768,"name":"135.jsnp"}
{"score":"65","reasoning":"The code has clear method structure and helpful comments for setValue but suffers from complex regex patterns built via string concatenation without inline explanations. Variable names like find and match are too generic for regex contexts. The incomplete snippet and commented debug statements reduce readability. Experienced Java developers might comprehend it with effort but beginners would struggle especially with the regex groups and replacement logic","tokens":2203,"name":"177.jsnp"}
{"score":"45","reasoning":"The code snippet exhibits significant readability issues. It contains an unused RuntimeVariables.replace call an empty catch block that hides errors duplicated complex XPath strings and incomplete context with case 3. These elements create confusion hinder debugging and reduce maintainability. While the waiting loop structure is clear the poor practices and lack of comments make comprehension difficult despite the straightforward Selenium test purpose","tokens":1876,"name":"215.jsnp"}
{"score":"50","reasoning":"The code exhibits poor readability due to inconsistent indentation spacing and lack of comments explaining why some methods are empty while others call notSupported(). Method names follow conventions but absence of documentation makes it unclear which features are intentionally unimplemented versus placeholders. Empty method bodies create ambiguity about expected behavior without contextual clues. Inconsistent parameter spacing like DownloadTrackerListener\tl further reduces scanability. While structure is logically grouped the missing rationale for partial implementation severely hinders comprehension","tokens":911,"name":"138.jsnp"}
{"score":"72","reasoning":"The code uses polling loops for waiting which is clear in the second loop but the first part lacks loop header context Empty catch blocks are bad practice as they hide errors and reduce debuggability The timeout mechanism is explicit but ignoring all exceptions without comment makes comprehension difficult Overall functional but readability hampered by anti patterns","tokens":3593,"name":"146.jsnp"}
{"score":"90","reasoning":"The code snippet demonstrates clear structure with standard Java getter setter patterns and appropriate Javadoc comments. Method names are self explanatory following camelCase convention. The minor deduction comes from inconsistent terminology in Javadoc using class p k instead of classPK which may cause slight confusion. The isNew method lacks documentation but its purpose is intuitively clear. Overall the code is简洁 and adheres to common Java practices making it highly readable for experienced developers","tokens":755,"name":"141.jsnp"}
{"score":"92","reasoning":"The code snippet is well-structured with clear variable names like _objectNameCache and _mBeanServer enhancing readability. Consistent indentation and logical flow within the synchronized block make comprehension straightforward. The if-else logic for cache handling is easy to follow. Minor deduction due to abrupt ending without closing braces which may cause momentary confusion despite being a snippet. No comments but naming sufficiently explains intent.","tokens":1791,"name":"156.jsnp"}
{"score":"55","reasoning":"The code has critical readability issues: empty catch block swallows exceptions making debugging impossible and hiding errors. Hard-coded Thread.sleep is inefficient and non-adaptive. Break statement lacks loop context. No comments explain the polling purpose. While structure is simple the anti-patterns severely hinder comprehension and maintenance. Violates Selenium best practices by not using explicit waits.","tokens":1263,"name":"105.jsnp"}
{"score":"90","reasoning":"The code demonstrates strong readability with consistent indentation clear variable names and logical flow The exception handling is well-structured using instanceof checks for specific errors like PrincipalException and NoSuchRoleException Business rules such as blocking Organization_USER and SITE_MEMBER roles are explicit though minor improvements could include multi-catch syntax for cleaner exception grouping and brief comments explaining non-obvious role restrictions Overall the snippet is concise and easy to comprehend for experienced Java developers","tokens":2018,"name":"111.jsnp"}
{"score":"82","reasoning":"The code is well-structured with clear method names and logical flow for Selenium automation. Good indentation and descriptive boolean variable advancedVisible enhance readability. However the abrupt ending with unexplained label variable assignment reduces comprehension. Unicode escape » is acceptable but actual character might improve clarity. Minor issues prevent higher score.","tokens":2041,"name":"149.jsnp"}
{"score":"97","reasoning":"Highly readable code with clear structure and meaningful names. Logic is straightforward following standard service patterns. Minor points off for no inline comments on permission check dependencies but variable names make it understandable.","tokens":3273,"name":"175.jsnp"}
{"score":"100","reasoning":"The code features well-structured getter and setter methods with clear Javadoc documentation explaining each parameter and return value Standard Java naming conventions enhance readability The repetitive pattern is consistent and expected for such boilerplate code A minor artifact at the start is recognizable as a comment fragment and does not hinder comprehension of the straightforward logic Overall the snippet is exceptionally clear and easy to understand","tokens":4110,"name":"136.jsnp"}
{"score":"92","reasoning":"The code snippet is highly readable with clear Javadoc comments explaining each method\u0027s purpose parameters and exceptions Method names like getAlgorithmName and doFinal are descriptive and follow standard conventions Parameter names such as inOff and len are conventional in cryptographic contexts though slightly terse The structure is consistent and well-organized Minor deductions for a typo in comment final statge and very short parameter name in which could be more explicit but overall excellent comprehension for its domain","tokens":1354,"name":"184.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear method names that directly convey their purpose. Parameter names like questionId start and end are intuitive especially in pagination context. The implementation is concise delegation to a service layer which enhances maintainability. Minor deduction for fully qualified exception names adding verbosity but overall structure is clean and easy to comprehend without unnecessary complexity","tokens":1278,"name":"214.jsnp"}
{"score":"45","reasoning":"The code has non idiomatic loops with empty conditions and internal timeout checks making flow hard to follow Empty catch blocks hide errors reducing debuggability Long repeated XPath strings clutter the code and lack abstraction RuntimeVariables usage is unclear without context Duplication of similar wait loops without helper methods increases complexity and maintenance burden Overall structure is functional but poor readability due to these issues","tokens":1360,"name":"173.jsnp"}
{"score":"60","reasoning":"The code snippet includes a detailed license header but incorrectly references Foobar instead of the actual project name sqsc-isqlj causing confusion The two import statements are clear however the documentation error significantly impairs comprehension and reduces readability despite proper structure","tokens":3099,"name":"190.jsnp"}
{"score":"68","reasoning":"The code has clear structure but the condition c \u003d\u003d  || c \u003d\u003d  \u0026\u0026 i\u003d\u003d0 || chars i-1 !\u003d \\ lacks parentheses causing operator precedence ambiguity which is error prone and hard to read. Variable names like bit and quote are acceptable but inconsistent indentation and incomplete snippet reduce clarity. The escape flag is set but unused in visible context adding confusion. Critical flaw in condition logic significantly impacts comprehension.","tokens":1346,"name":"164.jsnp"}
{"score":"100","reasoning":"The code is a straightforward Java setter method with clear naming conventions and proper Javadoc documentation. The method name explicitly describes its purpose while the parameter name matches the instance variable. The implementation is minimal and follows standard Java bean patterns without unnecessary complexity. The Javadoc provides basic but sufficient context despite minor redundancy with the method name. Formatting adheres to common indentation practices and the logic is immediately understandable even for novice developers","tokens":599,"name":"161.jsnp"}
{"score":"90","reasoning":"The code is logically structured with clear variable and constant names facilitating comprehension. Minor readability issues include missing spaces after \u0027if\u0027 and \u0027!\u003d\u0027 operators which slightly hinder flow. The consistent use of descriptive terms like schemaLoadInfo and SQLAliasSchemaDetailProperties aids understanding. The boolean assignment for loadProcedures is safe but could be more concise by direct assignment instead of if-else. Overall the flow is straightforward for an experienced developer despite small style inconsistencies.","tokens":3238,"name":"187.jsnp"}
{"score":"40","reasoning":"The snippet starts with an invalid standalone method call getLeecherCount outside any method context causing immediate confusion The Javadoc for getBadNATCount is clear but the method declaration is split across lines unusually The invalid construct dominates comprehension making the code appear erroneous and difficult to interpret despite decent documentation","tokens":3099,"name":"126.jsnp"}
{"score":"90","reasoning":"The code exhibits high readability with clear variable names and logical flow. Repetitive null checks for dates follow a consistent pattern enhancing comprehension. Minor deductions for duplicated date handling logic and use of Long.MIN_VALUE without explanatory comments. The name validation step is straightforward but slightly redundant by reassigning after initial set. Overall structure is linear and easy to follow with no complex nesting or obscure constructs","tokens":1279,"name":"142.jsnp"}
{"score":"85","reasoning":"Code is structured with clear Selenium test steps but suffers from repetitive loops and empty exception handling. Variable names are meaningful and flow is logical for test automation. Lack of helper functions for repeated wait logic reduces readability slightly. Common Selenium patterns aid comprehension for experienced users.","tokens":1423,"name":"110.jsnp"}
{"score":"70","reasoning":"The snippet starts with an incomplete method fragment causing immediate confusion due to missing context and inconsistent indentation. The two test methods are well-structured with clear JUnit patterns and proper exception handling for boundary cases. However the initial fragment significantly impairs initial comprehension despite the tests being logically sound and readable. The dangling code creates unnecessary cognitive load for the reader","tokens":2567,"name":"178.jsnp"}
{"score":"95","reasoning":"The code snippet demonstrates high readability with clear structure and meaningful naming conventions such as testSuite and suite method. It follows standard JUnit patterns for test aggregation making it easy to comprehend for developers familiar with testing frameworks. The indentation is consistent and logic flow is straightforward with two addTest calls. Minor deductions are for the class name UnitConverterTestPlan potentially causing slight confusion since it aggregates PortletTestPlan and UnitTestPlan without explicit context. The author comment does not impact readability but adds no functional value. Overall the snippet is clean well organized and effectively communicates its purpose","tokens":2985,"name":"207.jsnp"}
{"score":"55","reasoning":"The code uses brittle XPath selectors with index-based paths like div[8] which reduce maintainability and clarity. It employs outdated Selenium RC patterns instead of modern WebDriver practices. Empty catch blocks hide exceptions making debugging difficult. The timeout loops with Thread.sleep are inefficient and less readable than explicit waits. Lack of comments or descriptive variables increases cognitive load. Hardcoded strings and complex nested method calls further hinder comprehension despite logical test flow","tokens":1592,"name":"194.jsnp"}
{"score":"70","reasoning":"The code has clear structure with repetitive wait loops for element presence a common Selenium pattern However magic numbers like 90 and 1000 lack explanation reducing clarity Empty catch blocks hide potential errors impacting debuggability Duplicated loop logic could be refactored into a helper method for better readability and maintenance Variable names are adequate but comments explaining timeout rationale would improve comprehension","tokens":1144,"name":"210.jsnp"}
{"score":"30","reasoning":"Code has critical readability issues: empty exception handling swallows errors hardcoded waits/XPaths reduce maintainability complex regex and non-DRY selectors. Brittle locators with fixed indices and labeled continue statements hinder comprehension. Lack of comments and context increases cognitive load despite some clear variable names","tokens":1278,"name":"121.jsnp"}
{"score":"40","reasoning":"The snippet is highly fragmented with orphaned code blocks lacking context. Missing class structure method headers and field declarations make comprehension difficult. While standard conventions like underscore for private fields are used the incomplete nature with dangling braces and no comments severely hinders understanding. The static send method is clear but the initial disconnect call has no surrounding method definition. Overall poor readability due to critical missing context","tokens":1600,"name":"132.jsnp"}
{"score":"100","reasoning":"The code snippet demonstrates excellent readability with a clear class name AdminActivityKeys and self-explanatory constant names ADD_KB_ARTICLE and ADD_KB_COMMENT following Java naming conventions The purpose is immediately evident without ambiguity The numbering gap between constants is a common pattern in key-based systems and does not hinder comprehension for experienced developers The minimal Javadoc provides context without cluttering the code","tokens":2891,"name":"189.jsnp"}
{"score":"85","reasoning":"The code demonstrates clear structure with logical method organization and appropriate encapsulation. Field names like _prefs are concise though slightly ambiguous without context. Minimal comments such as Do Nothing add little value but the straightforward logic in methods like applyChanges remains easy to follow. Javadoc references non-Javadoc without descriptive explanations reducing documentation quality. Consistent naming conventions and simple control flow enhance readability despite minor stylistic choices like underscore-prefixed variables","tokens":1494,"name":"147.jsnp"}
{"score":"95","reasoning":"The code snippet features a standard license header which is lengthy but expected in open source projects. The interface is well-documented with concise Javadoc explaining its purpose for datasource registration. The interface name DownloadTypeIncomplete is meaningful and self-explanatory. The abrupt end without method declarations is acceptable for a partial snippet. Overall structure follows Java conventions making it highly readable despite the verbose license preamble","tokens":2180,"name":"160.jsnp"}
{"score":"100","reasoning":"The code exhibits excellent readability with clear method names and minimal complexity. The constructor efficiently delegates to super class while getICMPHeaderByteLength directly returns the standard ICMP header length of 8 bytes. The implementation follows common patterns without unnecessary elements making it immediately understandable even for developers new to network programming","tokens":1435,"name":"213.jsnp"}
{"score":"30","reasoning":"The snippet starts with a closing brace causing immediate confusion. Abstract method implies an abstract class but class declaration is missing. toString uses undefined variable string with poor naming. Critical context like class structure and variable declarations absent making comprehension very difficult. Hex.encode usage lacks clarity without library context.","tokens":1219,"name":"169.jsnp"}
{"score":"92","reasoning":"The code is a well-structured Java interface with clear method names that effectively convey their purpose such as setSourceSession and getDestSelectedDatabaseObjects. Minimal but sufficient Javadoc comments provide context without clutter. The consistent naming convention and logical grouping of source/destination session methods enhance comprehension. Lack of detailed comments on all methods slightly reduces readability but the self-explanatory design maintains high clarity for experienced developers","tokens":1121,"name":"200.jsnp"}
{"score":"85","reasoning":"The code is highly repetitive with clear method calls adding test suites which aids predictability However inconsistent test class naming conventions eg AddMBMessage1Tag1Test vs AddMBMessageATagTest reduce clarity Slight improvement needed in naming consistency for optimal readability but structure remains straightforward and easy to follow","tokens":879,"name":"155.jsnp"}
{"score":"60","reasoning":"Clear class and method names with standard test setup actions However the for loop is abruptly cut off missing the critical condition being waited for and loop body beyond timeout check This incomplete structure makes the test logic impossible to follow and significantly reduces comprehension despite otherwise conventional Selenium test patterns","tokens":1741,"name":"114.jsnp"}
{"score":"72","reasoning":"The code has consistent structure and thorough exception handling but suffers from significant repetition in exception blocks. Method names lack clarity and framework-specific patterns like MethodHandler and ClpSerializer reduce readability for unfamiliar developers. Boilerplate code could be abstracted to improve maintainability and comprehension.","tokens":1552,"name":"165.jsnp"}
{"score":"85","reasoning":"The first method shows strong readability with clear variable names logical flow and meaningful generics usage However the abrupt end of the second method creates structural incompleteness leading to confusion about its implementation and reducing overall comprehension despite the otherwise clean code structure","tokens":2642,"name":"119.jsnp"}
{"score":"90","reasoning":"The code is a clear wrapper implementation with straightforward delegation. Field names use underscores which is non-standard in Java but consistent here. Methods are short and purpose is evident. The setAuthToken logic handling null by reverting to original is simple but the non-standard naming slightly reduces readability. Overall very comprehensible with minimal cognitive load","tokens":998,"name":"139.jsnp"}
{"score":"82","reasoning":"The code demonstrates clear naming conventions and consistent structure for null checks and error handling. However the setPortletMode method is incomplete with a broken method call spanning multiple lines and missing closing braces which significantly hinders comprehension of that critical section. The rest of the code is well formatted and logically straightforward","tokens":5348,"name":"131.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear variable names like models and soapModels and a straightforward for-each loop structure The conversion logic using toSoapModel is intuitive and follows standard Java practices The toArray method call is correctly implemented with proper type specification The empty constructor is simple and appropriate for the context Minor deduction for lack of contextual comments but overall very clean and easy to comprehend","tokens":1436,"name":"171.jsnp"}
{"score":"95","reasoning":"The code shows excellent structure with clear component naming pnlName lblName txtName following GUI conventions. BorderLayout usage is logical and standard. Internationalization via s_stringMgr is properly implemented though the i18n comment format is slightly cryptic. Minor deduction for s_ prefix in s_stringMgr which deviates from typical Java naming standards but remains understandable. txtName assignment without declaration is acceptable in context. Overall highly readable and maintainable","tokens":1357,"name":"196.jsnp"}
{"score":"75","reasoning":"The code has logical structure and meaningful variable names but suffers from poor practices affecting readability. Empty catch blocks hide exceptions making debugging unclear. Magic numbers 90 and 1000 lack explanatory constants. Absence of in-method comments reduces comprehension despite clear test flow. Standard Selenium patterns are used but anti-patterns like silent exception swallowing lower overall clarity for maintainability","tokens":1870,"name":"219.jsnp"}
{"score":"95","reasoning":"The code exhibits high readability with clear variable and method names that precisely convey their purpose. Logical flow is straightforward with consistent indentation and proper line breaks for parameter alignment. Minimal repetition between similar validation methods slightly impacts conciseness but each method remains self-explanatory without needing comments. Validator usage follows common patterns enhancing comprehension for Java developers familiar with such frameworks","tokens":1720,"name":"206.jsnp"}
{"score":"65","reasoning":"The code exhibits clear method naming and logical structure but suffers from severely reduced readability due to excessive fully qualified class names instead of imports. Repetitive verbose exceptions and annotations create visual noise. Parameter lists are inconsistently formatted across lines. While method purposes are discernible the constant package prefixes hinder quick comprehension making the interface feel cluttered and unnecessarily complex for maintenance or understanding","tokens":1512,"name":"144.jsnp"}
{"score":"95","reasoning":"The code exhibits excellent readability with consistent Javadoc comments detailing each method\u0027s purpose parameters and exceptions Method names follow standard Java conventions clearly indicating getter setter functionality The documentation thoroughly explains behavior including the SystemException for getUserUuid Minor repetition in comments is standard for such interfaces and does not hinder comprehension The structure is clean and immediately understandable for developers familiar with JavaBeans patterns","tokens":1724,"name":"130.jsnp"}
{"score":"85","reasoning":"The code is well-structured with clear interface naming and concise Javadoc explaining each method\u0027s purpose. However the use of raw Map type without generics reduces type safety and comprehension. Minimal imports and focused responsibilities enhance readability but the raw collection type and non-standard I-prefix interface name slightly lower the score","tokens":923,"name":"216.jsnp"}
{"score":"88","reasoning":"The code snippet demonstrates good readability with clear interface naming and proper use of annotations from the Eclipse Sapphire framework. The structure follows Java conventions with appropriate indentation and imports. However the absence of method declarations within the interface may confuse readers unfamiliar with Sapphires annotation-driven model generation approach requiring prior framework knowledge for full comprehension","tokens":962,"name":"179.jsnp"}
{"score":"92","reasoning":"The code exhibits high readability with clear method names like getParameterSpec and getNames. Well-structured indentation and descriptive variable names such as ecP enhance comprehension. Comprehensive Javadoc comments explain each method\u0027s purpose and parameters effectively. Minor deduction for using raw Enumeration type without generics which slightly reduces modern code clarity. Null handling is straightforward and logically presented. Overall the code follows strong Java conventions making it easy to understand for experienced developers","tokens":948,"name":"122.jsnp"}
{"score":"60","reasoning":"The code contains a critical anti-pattern with an empty catch block that swallows all exceptions making debugging impossible and obscuring failure scenarios The break statement implies loop context not visible reducing clarity Thread sleep for polling is common but the ignored exceptions severely impact readability as potential errors during element check are hidden without logging or handling","tokens":1972,"name":"218.jsnp"}
{"score":"65","reasoning":"The code snippet implements a polling loop for element visibility but uses an empty catch block which swallows exceptions making debugging difficult and reducing comprehension. The complex XPath string is necessary but the inconsistent indentation and lack of error handling lower readability significantly. The structure is functional yet the silent exception suppression obscures potential issues hindering maintainability and understanding.","tokens":2139,"name":"124.jsnp"}
{"score":"75","reasoning":"The field names points and pointsAreLeftOfWindow are clear and follow Java conventions enhancing readability. However the class is incomplete with no methods or comments to explain context or behavior limiting full comprehension. The boolean field name is descriptive but lacks clarity on what window it refers to without additional documentation or usage examples","tokens":1666,"name":"128.jsnp"}
{"score":"78","reasoning":"The code demonstrates clear structure with consistent repetition of updatePortletPermissions calls making permission assignments easy to follow. Magic numbers for portlet IDs reduce readability as they lack contextual meaning. JDBC section uses common abbreviations con/ps/rs which are recognizable but could be more explicit. Proper indentation and logical grouping of permissions enhance comprehension despite minor drawbacks in self-documenting identifiers","tokens":1896,"name":"127.jsnp"}
{"score":"55","reasoning":"The code uses a confusing state machine pattern with label variable and continue jumps making flow hard to follow Long Selenium command blocks without decomposition Magic numbers present though Selenium steps are clear for domain experts","tokens":2360,"name":"205.jsnp"}
{"score":"25","reasoning":"The snippet starts with multiple unexplained closing braces causing immediate confusion. The method isBuddy returns int despite its boolean-suggesting name creating semantic inconsistency. Inconsistent indentation and abrupt transition from closing blocks to method declaration disrupt flow. Only the single peer.getIp line is clear but overall structure lacks context making comprehension very difficult","tokens":1639,"name":"117.jsnp"}
{"score":"98","reasoning":"Excellent structure with clear method names and straightforward logic. Minor deduction for string literal usage instead of constant for parameter name in getRootPath. Code follows Java conventions with meaningful variable names and minimal complexity. Highly comprehensible despite minor style improvement opportunity.","tokens":3783,"name":"125.jsnp"}
{"score":"92","reasoning":"Clear structure with descriptive variable names. Repetitive append and setter patterns are straightforward despite verbosity. Null checks are simple and consistent. Framework-specific elements like StringBundler and StringPool may require context but do not significantly hinder understanding. Logical flow is easy to follow with no complex logic or nested conditions","tokens":1221,"name":"197.jsnp"}
{"score":"30","reasoning":"The code snippet starts with an orphaned string literal causing immediate confusion. The continue statement implies a loop structure not visible in the snippet making control flow unclear. Variable testEmailChecked and label assignment lack context. RuntimeVariables.replace with empty string serves no apparent purpose. Despite simple selenium click structure the fragmentary nature missing declarations and ambiguous jumps severely hinder comprehension. Overall poor readability due to incomplete context and structural issues","tokens":1526,"name":"129.jsnp"}
{"score":"45","reasoning":"The code uses non-standard loop structure with empty for condition and empty catch block hiding exceptions Magic numbers 90 and 1000 lack context making timeout logic unclear Abrupt termination of second loop mid-body severely impacts comprehension as reader cannot discern intended flow Despite recognizable Selenium wait pattern the incomplete structure and poor error handling reduce readability significantly","tokens":3714,"name":"113.jsnp"}
{"score":"50","reasoning":"The snippet starts with an invalid line Category category ); which is syntactically incorrect and confusing. Although the method Javadoc is clear and well-structured the initial error severely disrupts comprehension. The misplaced fragment creates ambiguity about code structure making it difficult to parse despite good documentation for the actual method declaration","tokens":3058,"name":"118.jsnp"}
{"score":"100","reasoning":"The code is extremely concise and clear The class name LockException immediately conveys its purpose The minimal structure with a standard constructor calling super is easy to understand The Javadoc includes author which is acceptable though a description would be ideal but the absence does not hinder comprehension","tokens":2762,"name":"182.jsnp"}
{"score":"75","reasoning":"The code shows clear test structure for create and remove operations with meaningful names and standard assertions However testUpdateNew is misleading as it only creates an entity without update or assertions causing confusion The update existing test setup is clear but the snippet ends prematurely Overall good readability marred by one poorly designed test method","tokens":2264,"name":"120.jsnp"}
{"score":"78","reasoning":"Code has clear getter methods but toString contains magic numbers and unclear abbreviations like cn. sendAZID lacks descriptive naming. Inconsistent formatting in string concatenation reduces readability. Some fields use non-intuitive prefixes lSequenceNo. Overall structure is logical but minor clarity issues lower score","tokens":1293,"name":"108.jsnp"}
{"score":"95","reasoning":"The code snippet demonstrates high readability with clear conditional logic and exception handling. Using RUBY.getValue().equals(value) prevents null pointer exceptions and follows safe comparison practices. The getValue method is concise and self-explanatory. Minor deduction for the non-standard _value field naming convention in Java which slightly reduces familiarity though remains understandable. Overall structure is logical and easy to follow","tokens":1659,"name":"109.jsnp"}
{"score":"85","reasoning":"Inconsistent method naming getURLExport vs getUrlTitle violates Java camelCase conventions for acronyms reducing readability Slightly verbose parameter names but clear within Liferay context Broad exception handling acceptable for interface declarations Overall straightforward but naming inconsistency lowers score","tokens":1456,"name":"195.jsnp"}
{"score":"50","reasoning":"The code snippet has inconsistent indentation with the string literal unnecessarily split across lines and indented too deeply causing visual clutter The empty catch block lacks comments making it unclear why exceptions are ignored and what they might represent Thread sleep placement is logical but the missing try block context and poor structure choices significantly hinder comprehension despite the simple polling intent","tokens":2508,"name":"143.jsnp"}
{"score":"95","reasoning":"The code snippet clearly demonstrates a JUnit test suite setup by adding multiple test classes Despite being incomplete missing closing braces the pattern is standard and easily recognizable by experienced developers The class and method names are descriptive The simplicity and common structure make it highly readable","tokens":5433,"name":"199.jsnp"}
{"score":"90","reasoning":"The code demonstrates high readability with clear variable names frame props panel and logical step-by-step UI setup flow. Structure is straightforward showing application initialization frame creation panel configuration and display settings. Minimal comments beyond standard Javadoc and abrupt ending without closing braces slightly reduce perfection but the concise purpose-focused implementation remains easily comprehensible for its test UI context","tokens":2890,"name":"123.jsnp"}
{"score":"95","reasoning":"The code demonstrates high readability with clear structure and meaningful variable names. Logical flow in get method is easy to follow: null check context locale handling and value retrieval. Consistent indentation and standard Java patterns enhance comprehension. Minor deduction for split debug statement formatting which slightly disrupts visual flow but remains understandable. Unsupported operations are clearly indicated with standard exceptions","tokens":2238,"name":"154.jsnp"}
{"score":"70","reasoning":"Excessive whitespace and inconsistent formatting reduce readability significantly The comment about trailing separators is cut off The snippet ends with an incomplete if statement Core logic is understandable but the poor style hinders comprehension","tokens":5156,"name":"115.jsnp"}
{"score":"100","reasoning":"The code exhibits exceptional readability with clear method names and straightforward logic. Each method serves an obvious purpose: getters setters and error checking are self-explanatory. The hasError implementation while verbose is explicit and easy to follow. The structure adheres to standard Java bean conventions making it instantly familiar. Despite the snippet being incomplete the provided methods convey their intent effectively without ambiguity. Minor verbosity in hasError does not hinder comprehension","tokens":3463,"name":"163.jsnp"}
{"score":"75","reasoning":"The code has clear variable names and straightforward logic but suffers from non-standard Java conventions such as spaces inside if condition parentheses and unnecessary parentheses in return statements. Inconsistent spacing around operators and lack of context for null parameters reduce readability. Indentation is mostly consistent but minor formatting issues hinder immediate comprehension for experienced Java developers","tokens":1961,"name":"185.jsnp"}
{"score":"78","reasoning":"The code demonstrates good structure with meaningful variable names and consistent indentation but has significant flaws. A critical typo in _proccessAttributes method name reduces readability and causes confusion. Non-standard leading underscores for private methods deviate from Java conventions. Lack of comments increases cognitive load despite modular logic. These issues moderately hinder comprehension for Java developers.","tokens":3514,"name":"211.jsnp"}
{"score":"75","reasoning":"The abstract class AliasAction incorrectly uses DeleteAliasAction for logger and string manager initialization causing confusion about design intent Despite good structure error handling and clear comments for static fields the inconsistency significantly impairs comprehension as it breaks abstraction and suggests a potential bug in resource initialization","tokens":4211,"name":"137.jsnp"}
{"score":"100","reasoning":"The provided code snippet includes a standard copyright header and necessary imports formatted clearly with one import per line It follows Java conventions making it highly readable and easy to comprehend The structure is professional and common in enterprise codebases with no readability issues in the given portion","tokens":4407,"name":"134.jsnp"}
{"score":"50","reasoning":"The code uses framework-specific boilerplate for remote service calls with nested try-catch blocks and repetitive instanceof checks which reduce readability. Variable names are clear but the complex exception handling structure requires significant effort to comprehend without Liferay context. The outer SystemException catch adds redundancy making the flow harder to follow for general Java developers","tokens":4743,"name":"162.jsnp"}
